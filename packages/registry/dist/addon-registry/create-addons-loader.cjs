"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/addon-registry/create-addons-loader.ts
var create_addons_loader_exports = {};
__export(create_addons_loader_exports, {
  createAddonsLoader: () => createAddonsLoader,
  getAddonsLoaderCode: () => getAddonsLoaderCode,
  nameFromPackage: () => nameFromPackage
});
module.exports = __toCommonJS(create_addons_loader_exports);
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_tmp = __toESM(require("tmp"), 1);
var import_crypto_random_string = __toESM(require("crypto-random-string"), 1);
var titleCase = (w) => w.slice(0, 1).toUpperCase() + w.slice(1, w.length);
function nameFromPackage(name) {
  name = name.replace(/[@~./\\:\s]/gi, "") || (0, import_crypto_random_string.default)({ length: 10, characters: "abcdefghijk" });
  return name.split("-").map((w, i) => i > 0 ? titleCase(w) : w).join("");
}
function getAddonsLoaderCode(addons, addonsInfo, loadProjectConfig) {
  let buf = `/*
Don't change this file manually.
It is autogenerated by @plone/registry.
Instead, change the "addons" registration in the app.
*/

`;
  if (loadProjectConfig) {
    buf += `const projectConfigLoader = require('@root/config');
`;
  }
  let configsToLoad = [], counter = 0;
  addons.forEach((addonConfigString) => {
    let extras = [];
    const addonConfigLoadInfo = addonConfigString.split(":");
    const pkgName = addonConfigLoadInfo[0];
    const defaultImport = nameFromPackage(pkgName);
    if (addonConfigLoadInfo.length > 1) {
      extras = addonConfigLoadInfo[1].split(",");
    }
    extras = extras.map((name) => [name, `${name}${counter++}`]);
    const line = `import ${defaultImport}${extras.length ? `, { ${extras.map((ex) => {
      return `${ex[0]} as ${ex[1]}`;
    }).join(", ")} }` : ""} from '${pkgName}';
`;
    buf += line;
    configsToLoad = [
      ...configsToLoad,
      defaultImport,
      ...extras.map((ex) => ex[1])
    ];
  });
  buf += `
${addonsInfo ? `const addonsInfo = ${JSON.stringify(addonsInfo)}` : "const addonsInfo = {}"};
export { addonsInfo };
`;
  buf += `
const safeWrapper = (func) => (config) => {
  const res = func(config);
  if (typeof res === 'undefined') {
    throw new Error("Configuration function doesn't return config");
  }
  return res;
}

${loadProjectConfig ? "" : "const projectConfigLoader = false;"}
const projectConfig = (config) => {
  return projectConfigLoader && typeof projectConfigLoader.default === "function" ? projectConfigLoader.default(config) : config;
}

const load = (config) => {
  const addonLoaders = [${configsToLoad.join(", ")}];
  if(!addonLoaders.every((el) => typeof el === "function")) {
    throw new TypeError(
      'Each addon has to provide a function applying its configuration to the projects configuration.',
    );
  }
  return projectConfig(addonLoaders.reduce((acc, apply) => safeWrapper(apply)(acc), config));
};
export default load;
`;
  return buf;
}
function createAddonsLoader(addons, addonsInfo, {
  tempInProject,
  loadProjectConfig = false
} = {}) {
  let addonsLoaderPath;
  if (tempInProject) {
    addonsLoaderPath = import_path.default.join(process.cwd(), "registry.loader.js");
  } else {
    addonsLoaderPath = import_tmp.default.tmpNameSync({ postfix: ".js" });
  }
  const code = getAddonsLoaderCode(addons, addonsInfo, loadProjectConfig);
  import_fs.default.writeFileSync(addonsLoaderPath, code);
  return addonsLoaderPath;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createAddonsLoader,
  getAddonsLoaderCode,
  nameFromPackage
});
