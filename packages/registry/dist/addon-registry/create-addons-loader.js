// src/addon-registry/create-addons-loader.ts
import fs from "fs";
import path from "path";
import tmp from "tmp";
import cryptoRandomString from "crypto-random-string";
var titleCase = (w) => w.slice(0, 1).toUpperCase() + w.slice(1, w.length);
function nameFromPackage(name) {
  name = name.replace(/[@~./\\:\s]/gi, "") || cryptoRandomString({ length: 10, characters: "abcdefghijk" });
  return name.split("-").map((w, i) => i > 0 ? titleCase(w) : w).join("");
}
function getAddonsLoaderCode(addons, addonsInfo, loadProjectConfig) {
  let buf = `/*
Don't change this file manually.
It is autogenerated by @plone/registry.
Instead, change the "addons" registration in the app.
*/

`;
  if (loadProjectConfig) {
    buf += `const projectConfigLoader = require('@root/config');
`;
  }
  let configsToLoad = [], counter = 0;
  addons.forEach((addonConfigString) => {
    let extras = [];
    const addonConfigLoadInfo = addonConfigString.split(":");
    const pkgName = addonConfigLoadInfo[0];
    const defaultImport = nameFromPackage(pkgName);
    if (addonConfigLoadInfo.length > 1) {
      extras = addonConfigLoadInfo[1].split(",");
    }
    extras = extras.map((name) => [name, `${name}${counter++}`]);
    const line = `import ${defaultImport}${extras.length ? `, { ${extras.map((ex) => {
      return `${ex[0]} as ${ex[1]}`;
    }).join(", ")} }` : ""} from '${pkgName}';
`;
    buf += line;
    configsToLoad = [
      ...configsToLoad,
      defaultImport,
      ...extras.map((ex) => ex[1])
    ];
  });
  buf += `
${addonsInfo ? `const addonsInfo = ${JSON.stringify(addonsInfo)}` : "const addonsInfo = {}"};
export { addonsInfo };
`;
  buf += `
const safeWrapper = (func) => (config) => {
  const res = func(config);
  if (typeof res === 'undefined') {
    throw new Error("Configuration function doesn't return config");
  }
  return res;
}

${loadProjectConfig ? "" : "const projectConfigLoader = false;"}
const projectConfig = (config) => {
  return projectConfigLoader && typeof projectConfigLoader.default === "function" ? projectConfigLoader.default(config) : config;
}

const load = (config) => {
  const addonLoaders = [${configsToLoad.join(", ")}];
  if(!addonLoaders.every((el) => typeof el === "function")) {
    throw new TypeError(
      'Each addon has to provide a function applying its configuration to the projects configuration.',
    );
  }
  return projectConfig(addonLoaders.reduce((acc, apply) => safeWrapper(apply)(acc), config));
};
export default load;
`;
  return buf;
}
function createAddonsLoader(addons, addonsInfo, {
  tempInProject,
  loadProjectConfig = false
} = {}) {
  let addonsLoaderPath;
  if (tempInProject) {
    addonsLoaderPath = path.join(process.cwd(), "registry.loader.js");
  } else {
    addonsLoaderPath = tmp.tmpNameSync({ postfix: ".js" });
  }
  const code = getAddonsLoaderCode(addons, addonsInfo, loadProjectConfig);
  fs.writeFileSync(addonsLoaderPath, code);
  return addonsLoaderPath;
}
export {
  createAddonsLoader,
  getAddonsLoaderCode,
  nameFromPackage
};
