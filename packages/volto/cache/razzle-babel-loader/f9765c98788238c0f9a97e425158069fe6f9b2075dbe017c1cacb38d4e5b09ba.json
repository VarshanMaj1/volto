{"ast":null,"code":"import isBoolean from 'lodash/isBoolean';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport { getBoolean } from '@plone/volto/helpers/Vocabularies/Vocabularies';\nimport { defineMessages } from 'react-intl';\nconst messages = defineMessages({\n  no_value: {\n    \"id\": \"No value\",\n    \"defaultMessage\": \"No value\"\n  }\n});\n\n/**\n * Prepares a vocab endpoint query for tokens based on passed value.\n *\n * This can be used to facilitate querying a vocabulary endpoint for labels,\n * given some token values. This assumes that the value has already been\n * normalized by normalizeValue.\n */\nexport function convertValueToVocabQuery(value) {\n  var _value$value;\n  if (isString(value) || isBoolean(value)) return {\n    token: value.toString()\n  };\n  if (!value) return {};\n  if (Array.isArray(value)) {\n    return {\n      tokens: value.map(v => {\n        var _v$value;\n        return isObject(v) ? (_v$value = v.value) !== null && _v$value !== void 0 ? _v$value : v.token : isString(v) || isBoolean(v) ? v : null;\n      }).filter(f => f !== null)\n    };\n  }\n  const token = (_value$value = value.value) !== null && _value$value !== void 0 ? _value$value : value.token;\n  return isString(token) ? {\n    token\n  } : {};\n}\n\n/**\n * Normalizes provided value to a \"best representation\" value, as accepted by\n * react-select. In this case, it is an object of shape `{ label, value }`\n */\nexport function normalizeSingleSelectOption(value, intl) {\n  var _ref, _ref2, _value$token, _ref3, _ref4, _ref5;\n  if (!value) return value;\n  if (Array.isArray(value)) {\n    // assuming [token, title] pair.\n    if (value.length === 2) return {\n      value: value[0],\n      label: value[1] || value[0]\n    };\n    throw new Error(`Unknown value type of select widget: ${value}`);\n  }\n  const token = (_ref = (_ref2 = (_value$token = value.token) !== null && _value$token !== void 0 ? _value$token : value.value) !== null && _ref2 !== void 0 ? _ref2 : value.UID) !== null && _ref !== void 0 ? _ref : 'no-value';\n  const label = (_ref3 = (_ref4 = (_ref5 = value.title && value.title !== 'None' ? value.title : undefined) !== null && _ref5 !== void 0 ? _ref5 : value.label) !== null && _ref4 !== void 0 ? _ref4 : value.token) !== null && _ref3 !== void 0 ? _ref3 : intl.formatMessage(messages.no_value);\n  return {\n    value: token,\n    label\n  };\n}\nexport const normalizeChoices = (items, intl) => items.map(item => normalizeSingleSelectOption(item, intl));\n\n/**\n * Given the value from the API, it normalizes to a value valid to use in react-select.\n * This is necessary because of the inconsistencies in p.restapi vocabularies implementations as\n * they need to adapt to react-select public interface.\n * @function normalizeValue\n * @param {array} choices The choices\n * @param {string|object|boolean|array} value The value\n * @returns {Object} An object of shape {label: \"\", value: \"\"} (or an array)\n */\nexport function normalizeValue(choices, value, intl) {\n  choices = normalizeChoices(choices || [], intl);\n  const choiceMap = Object.assign({}, ...choices.map(({\n    label,\n    value\n  }) => ({\n    [value]: label\n  })));\n  if (!isObject(value) && isBoolean(value)) {\n    // We have a boolean value, which means we need to provide a \"No value\"\n    // option\n    const label = choiceMap[getBoolean(value)];\n    return label ? {\n      label,\n      value\n    } : {};\n  }\n  if (value === 'no-value') {\n    return {\n      label: intl.formatMessage(messages.no_value),\n      value: 'no-value'\n    };\n  }\n  if (value === undefined || !value || value.length === 0) return null;\n  if (Array.isArray(value)) {\n    // a list of values, like ['foo', 'bar'];\n    return value.map(v => normalizeValue(choices, v, intl));\n  }\n  if (isObject(value)) {\n    // an object like `{label, value}` or `{ title, value }`\n    return normalizeSingleSelectOption(value, intl);\n  }\n\n  // fallback: treat value as a token and look it up in choices\n  return Object.keys(choiceMap).includes(value) ? {\n    label: choiceMap[value],\n    value\n  } : {\n    label: value,\n    value\n  };\n}","map":{"version":3,"names":["isBoolean","isObject","isString","getBoolean","defineMessages","messages","no_value","convertValueToVocabQuery","value","_value$value","token","toString","Array","isArray","tokens","map","v","_v$value","filter","f","normalizeSingleSelectOption","intl","_ref","_ref2","_value$token","_ref3","_ref4","_ref5","length","label","Error","UID","title","undefined","formatMessage","normalizeChoices","items","item","normalizeValue","choices","choiceMap","Object","assign","keys","includes"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Widgets/SelectUtils.js"],"sourcesContent":["import isBoolean from 'lodash/isBoolean';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport { getBoolean } from '@plone/volto/helpers/Vocabularies/Vocabularies';\nimport { defineMessages } from 'react-intl';\n\nconst messages = defineMessages({\n  no_value: {\n    id: 'No value',\n    defaultMessage: 'No value',\n  },\n});\n\n/**\n * Prepares a vocab endpoint query for tokens based on passed value.\n *\n * This can be used to facilitate querying a vocabulary endpoint for labels,\n * given some token values. This assumes that the value has already been\n * normalized by normalizeValue.\n */\nexport function convertValueToVocabQuery(value) {\n  if (isString(value) || isBoolean(value)) return { token: value.toString() };\n\n  if (!value) return {};\n\n  if (Array.isArray(value)) {\n    return {\n      tokens: value\n        .map((v) =>\n          isObject(v)\n            ? v.value ?? v.token\n            : isString(v) || isBoolean(v)\n              ? v\n              : null,\n        )\n        .filter((f) => f !== null),\n    };\n  }\n\n  const token = value.value ?? value.token;\n  return isString(token) ? { token } : {};\n}\n\n/**\n * Normalizes provided value to a \"best representation\" value, as accepted by\n * react-select. In this case, it is an object of shape `{ label, value }`\n */\nexport function normalizeSingleSelectOption(value, intl) {\n  if (!value) return value;\n\n  if (Array.isArray(value)) {\n    // assuming [token, title] pair.\n    if (value.length === 2)\n      return { value: value[0], label: value[1] || value[0] };\n\n    throw new Error(`Unknown value type of select widget: ${value}`);\n  }\n\n  const token = value.token ?? value.value ?? value.UID ?? 'no-value';\n  const label =\n    (value.title && value.title !== 'None' ? value.title : undefined) ??\n    value.label ??\n    value.token ??\n    intl.formatMessage(messages.no_value);\n\n  return {\n    value: token,\n    label,\n  };\n}\n\nexport const normalizeChoices = (items, intl) =>\n  items.map((item) => normalizeSingleSelectOption(item, intl));\n\n/**\n * Given the value from the API, it normalizes to a value valid to use in react-select.\n * This is necessary because of the inconsistencies in p.restapi vocabularies implementations as\n * they need to adapt to react-select public interface.\n * @function normalizeValue\n * @param {array} choices The choices\n * @param {string|object|boolean|array} value The value\n * @returns {Object} An object of shape {label: \"\", value: \"\"} (or an array)\n */\nexport function normalizeValue(choices, value, intl) {\n  choices = normalizeChoices(choices || [], intl);\n  const choiceMap = Object.assign(\n    {},\n    ...choices.map(({ label, value }) => ({\n      [value]: label,\n    })),\n  );\n\n  if (!isObject(value) && isBoolean(value)) {\n    // We have a boolean value, which means we need to provide a \"No value\"\n    // option\n    const label = choiceMap[getBoolean(value)];\n    return label\n      ? {\n          label,\n          value,\n        }\n      : {};\n  }\n\n  if (value === 'no-value') {\n    return {\n      label: intl.formatMessage(messages.no_value),\n      value: 'no-value',\n    };\n  }\n\n  if (value === undefined || !value || value.length === 0) return null;\n\n  if (Array.isArray(value)) {\n    // a list of values, like ['foo', 'bar'];\n    return value.map((v) => normalizeValue(choices, v, intl));\n  }\n\n  if (isObject(value)) {\n    // an object like `{label, value}` or `{ title, value }`\n    return normalizeSingleSelectOption(value, intl);\n  }\n\n  // fallback: treat value as a token and look it up in choices\n  return Object.keys(choiceMap).includes(value)\n    ? { label: choiceMap[value], value }\n    : { label: value, value };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[{"id":"No value","defaultMessage":"No value"}]}},"sourceType":"module","externalDependencies":[]}