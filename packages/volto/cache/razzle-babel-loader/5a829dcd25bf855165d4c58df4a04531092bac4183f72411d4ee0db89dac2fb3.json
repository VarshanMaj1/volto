{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport castArray from 'lodash/castArray';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from '@plone/volto-slate/utils/lists';\nimport { makeEditor } from '@plone/volto-slate/utils/editor';\nimport { LI } from '@plone/volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = castArray(types);\n  return Editor.nodes(editor, _objectSpread({\n    match: n => {\n      return types.includes(n.type);\n    }\n  }, options));\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0])\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const {\n      anchor\n    } = editor.selection;\n    return anchor.offset > 0 ? false : anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    var _editor$selection;\n    const anchor = ((_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor) || {};\n\n    // the last block node in the editor\n    const [node] = Node.last(editor, []);\n    if (\n    // if the node with the selection is the last block node\n    Node.get(editor, anchor.path) === node &&\n    // if the collapsed selection is at the end of the last block node\n    anchor.offset === node.text.length) {\n      return true;\n    }\n  }\n  return false;\n}\nconst defaultListItemValue = () => {\n  const {\n    slate\n  } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n  const {\n    slate\n  } = config.settings;\n  const range = Editor.range(editor, Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor, Editor.end(editor, []));\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  const newEditor = makeEditor();\n  newEditor.children = cloneDeep(editor.children);\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  const newEditor = makeEditor();\n  newEditor.children = cloneDeep(editor.children);\n  return Editor.fragment(newEditor, Editor.range(newEditor, [], Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor));\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const {\n    selection\n  } = editor;\n  const savedSelection = editor.getSavedSelection();\n  const range = ReactEditor.isFocused(editor) ? selection || (useSavedSelection ? savedSelection : null) : savedSelection;\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n  const res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: {\n          path,\n          offset: (leaf.text || '').length\n        },\n        focus: {\n          path,\n          offset: (leaf.text || '').length\n        }\n      };\n      return newSel;\n    }\n    return defaultSelection;\n  }\n}","map":{"version":3,"names":["castArray","cloneDeep","Editor","Transforms","Range","Node","ReactEditor","isCursorInList","makeEditor","LI","config","getSelectionNodesByType","editor","types","options","nodes","_objectSpread","match","n","includes","type","isNodeInSelection","getSelectionNodesArrayByType","Array","from","getMaxRange","maxRange","anchor","start","focus","end","selectAll","select","isCursorAtBlockStart","selection","isCollapsed","offset","path","reduce","acc","x","isCursorAtBlockEnd","_editor$selection","node","last","get","text","length","defaultListItemValue","slate","settings","dv","defaultValue","getFragmentFromStartOfSelectionToEndOfEditor","initialSelection","range","isBackward","newEditor","children","fragment","getFragmentFromBeginningOfEditorToStartOfSelection","hasRangeSelection","useSavedSelection","savedSelection","getSavedSelection","isFocused","res","isExpanded","parseDefaultSelection","defaultSelection","first","newSel","leaf"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/utils/selection.js"],"sourcesContent":["import castArray from 'lodash/castArray';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from '@plone/volto-slate/utils/lists';\nimport { makeEditor } from '@plone/volto-slate/utils/editor';\nimport { LI } from '@plone/volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = castArray(types);\n\n  return Editor.nodes(editor, {\n    match: (n) => {\n      return types.includes(n.type);\n    },\n    ...options,\n  });\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0]),\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const { anchor } = editor.selection;\n    return anchor.offset > 0\n      ? false\n      : anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const anchor = editor.selection?.anchor || {};\n\n    // the last block node in the editor\n    const [node] = Node.last(editor, []);\n\n    if (\n      // if the node with the selection is the last block node\n      Node.get(editor, anchor.path) === node &&\n      // if the collapsed selection is at the end of the last block node\n      anchor.offset === node.text.length\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst defaultListItemValue = () => {\n  const { slate } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  const { slate } = config.settings;\n  const range = Editor.range(\n    editor,\n    Range.isBackward(initialSelection)\n      ? initialSelection.focus\n      : initialSelection.anchor,\n    Editor.end(editor, []),\n  );\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  const newEditor = makeEditor();\n  newEditor.children = cloneDeep(editor.children);\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  const newEditor = makeEditor();\n  newEditor.children = cloneDeep(editor.children);\n\n  return Editor.fragment(\n    newEditor,\n    Editor.range(\n      newEditor,\n      [],\n      Range.isBackward(initialSelection)\n        ? initialSelection.focus\n        : initialSelection.anchor,\n    ),\n  );\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const { selection } = editor;\n  const savedSelection = editor.getSavedSelection();\n\n  const range = ReactEditor.isFocused(editor)\n    ? selection || (useSavedSelection ? savedSelection : null)\n    : savedSelection;\n\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n\n  const res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\n\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: { path, offset: 0 },\n        focus: { path, offset: 0 },\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: { path, offset: (leaf.text || '').length },\n        focus: { path, offset: (leaf.text || '').length },\n      };\n      return newSel;\n    }\n    return defaultSelection;\n  }\n}\n"],"mappings":";;;;;AAAA,OAAOA,SAAS,MAAM,kBAAkB;AACxC,OAAOC,SAAS,MAAM,kBAAkB;AACxC,SAASC,MAAM,EAAEC,UAAU,EAAEC,KAAK,EAAEC,IAAI,QAAQ,OAAO;AACvD,SAASC,WAAW,QAAQ,aAAa;AACzC,SAASC,cAAc,QAAQ,gCAAgC;AAC/D,SAASC,UAAU,QAAQ,iCAAiC;AAC5D,SAASC,EAAE,QAAQ,8BAA8B;AACjD,OAAOC,MAAM,MAAM,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuBA,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACnED,KAAK,GAAGb,SAAS,CAACa,KAAK,CAAC;EAExB,OAAOX,MAAM,CAACa,KAAK,CAACH,MAAM,EAAAI,aAAA;IACxBC,KAAK,EAAGC,CAAC,IAAK;MACZ,OAAOL,KAAK,CAACM,QAAQ,CAACD,CAAC,CAACE,IAAI,CAAC;IAC/B;EAAC,GACEN,OAAO,CACX,CAAC;AACJ;;AAEA;AACA;AACA;AACA,OAAO,SAASO,iBAAiBA,CAACT,MAAM,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC7D,MAAM,CAACG,KAAK,CAAC,GAAGN,uBAAuB,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,CAAC;EAC/D,OAAO,CAAC,CAACG,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,4BAA4BA,CAACV,MAAM,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxE,OAAOS,KAAK,CAACC,IAAI,CAACb,uBAAuB,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,CAAC,CAAC;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,WAAWA,CAACb,MAAM,EAAE;EAClC,MAAMc,QAAQ,GAAG;IACfC,MAAM,EAAEzB,MAAM,CAAC0B,KAAK,CAAChB,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;IACjCiB,KAAK,EAAE3B,MAAM,CAAC4B,GAAG,CAAClB,MAAM,EAAE,CAAC,CAAC,CAAC;EAC/B,CAAC;EACD,OAAOc,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,SAASA,CAACnB,MAAM,EAAE;EAChCT,UAAU,CAAC6B,MAAM,CAACpB,MAAM,EAAEa,WAAW,CAACb,MAAM,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqB,oBAAoBA,CAACrB,MAAM,EAAE;EAC3C;;EAEA,IAAIA,MAAM,CAACsB,SAAS,IAAI9B,KAAK,CAAC+B,WAAW,CAACvB,MAAM,CAACsB,SAAS,CAAC,EAAE;IAC3D,MAAM;MAAEP;IAAO,CAAC,GAAGf,MAAM,CAACsB,SAAS;IACnC,OAAOP,MAAM,CAACS,MAAM,GAAG,CAAC,GACpB,KAAK,GACLT,MAAM,CAACU,IAAI,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAKD,GAAG,GAAGC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;IACpD;EACF;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA,CAAC7B,MAAM,EAAE;EACzC;;EAEA;EACA,IAAIA,MAAM,CAACsB,SAAS,IAAI9B,KAAK,CAAC+B,WAAW,CAACvB,MAAM,CAACsB,SAAS,CAAC,EAAE;IAAA,IAAAQ,iBAAA;IAC3D,MAAMf,MAAM,GAAG,EAAAe,iBAAA,GAAA9B,MAAM,CAACsB,SAAS,cAAAQ,iBAAA,uBAAhBA,iBAAA,CAAkBf,MAAM,KAAI,CAAC,CAAC;;IAE7C;IACA,MAAM,CAACgB,IAAI,CAAC,GAAGtC,IAAI,CAACuC,IAAI,CAAChC,MAAM,EAAE,EAAE,CAAC;IAEpC;IACE;IACAP,IAAI,CAACwC,GAAG,CAACjC,MAAM,EAAEe,MAAM,CAACU,IAAI,CAAC,KAAKM,IAAI;IACtC;IACAhB,MAAM,CAACS,MAAM,KAAKO,IAAI,CAACG,IAAI,CAACC,MAAM,EAClC;MACA,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AAEA,MAAMC,oBAAoB,GAAGA,CAAA,KAAM;EACjC,MAAM;IAAEC;EAAM,CAAC,GAAGvC,MAAM,CAACwC,QAAQ;EACjC,MAAMC,EAAE,GAAGF,KAAK,CAACG,YAAY,CAAC,CAAC;EAC/BD,EAAE,CAAC,CAAC,CAAC,CAAC/B,IAAI,GAAGX,EAAE;EACf,OAAO0C,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,4CAA4CA,CAC1DzC,MAAM,EACN0C,gBAAgB,EAChB;EACA,IAAI,OAAOA,gBAAgB,KAAK,WAAW,EAAE;IAC3CA,gBAAgB,GAAG1C,MAAM,CAACsB,SAAS;EACrC;EAEA,MAAM;IAAEe;EAAM,CAAC,GAAGvC,MAAM,CAACwC,QAAQ;EACjC,MAAMK,KAAK,GAAGrD,MAAM,CAACqD,KAAK,CACxB3C,MAAM,EACNR,KAAK,CAACoD,UAAU,CAACF,gBAAgB,CAAC,GAC9BA,gBAAgB,CAACzB,KAAK,GACtByB,gBAAgB,CAAC3B,MAAM,EAC3BzB,MAAM,CAAC4B,GAAG,CAAClB,MAAM,EAAE,EAAE,CACvB,CAAC;;EAED;EACA;EACA,IAAIR,KAAK,CAAC+B,WAAW,CAACoB,KAAK,CAAC,EAAE;IAC5B,IAAIhD,cAAc,CAACK,MAAM,CAAC,EAAE;MAC1B,OAAOoC,oBAAoB,CAAC,CAAC;IAC/B,CAAC,MAAM;MACL,OAAOC,KAAK,CAACG,YAAY,CAAC,CAAC;IAC7B;EACF;;EAEA;EACA,MAAMK,SAAS,GAAGjD,UAAU,CAAC,CAAC;EAC9BiD,SAAS,CAACC,QAAQ,GAAGzD,SAAS,CAACW,MAAM,CAAC8C,QAAQ,CAAC;EAC/C,OAAOxD,MAAM,CAACyD,QAAQ,CAACF,SAAS,EAAEF,KAAK,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,kDAAkDA,CAChEhD,MAAM,EACN0C,gBAAgB,EAChB;EACA,IAAI,OAAOA,gBAAgB,KAAK,WAAW,EAAE;IAC3CA,gBAAgB,GAAG1C,MAAM,CAACsB,SAAS;EACrC;;EAEA;EACA;EACA,MAAMuB,SAAS,GAAGjD,UAAU,CAAC,CAAC;EAC9BiD,SAAS,CAACC,QAAQ,GAAGzD,SAAS,CAACW,MAAM,CAAC8C,QAAQ,CAAC;EAE/C,OAAOxD,MAAM,CAACyD,QAAQ,CACpBF,SAAS,EACTvD,MAAM,CAACqD,KAAK,CACVE,SAAS,EACT,EAAE,EACFrD,KAAK,CAACoD,UAAU,CAACF,gBAAgB,CAAC,GAC9BA,gBAAgB,CAACzB,KAAK,GACtByB,gBAAgB,CAAC3B,MACvB,CACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkC,iBAAiBA,CAACjD,MAAM,EAAEkD,iBAAiB,GAAG,IAAI,EAAE;EAClE,MAAM;IAAE5B;EAAU,CAAC,GAAGtB,MAAM;EAC5B,MAAMmD,cAAc,GAAGnD,MAAM,CAACoD,iBAAiB,CAAC,CAAC;EAEjD,MAAMT,KAAK,GAAGjD,WAAW,CAAC2D,SAAS,CAACrD,MAAM,CAAC,GACvCsB,SAAS,KAAK4B,iBAAiB,GAAGC,cAAc,GAAG,IAAI,CAAC,GACxDA,cAAc;EAElB,IAAI,CAACR,KAAK,EAAE;IACV;IACA;EACF;EAEA,MAAMW,GAAG,GAAG9D,KAAK,CAAC+D,UAAU,CAACZ,KAAK,CAAC;EACnC;EACA,OAAOW,GAAG;AACZ;AAEA,OAAO,SAASE,qBAAqBA,CAACxD,MAAM,EAAEyD,gBAAgB,EAAE;EAC9D,IAAIA,gBAAgB,EAAE;IACpB,IAAIA,gBAAgB,KAAK,OAAO,EAAE;MAChC,MAAM,GAAGhC,IAAI,CAAC,GAAGhC,IAAI,CAACiE,KAAK,CAAC1D,MAAM,EAAE,EAAE,CAAC;MACvC,MAAM2D,MAAM,GAAG;QACb5C,MAAM,EAAE;UAAEU,IAAI;UAAED,MAAM,EAAE;QAAE,CAAC;QAC3BP,KAAK,EAAE;UAAEQ,IAAI;UAAED,MAAM,EAAE;QAAE;MAC3B,CAAC;MACD,OAAOmC,MAAM;IACf;IACA,IAAIF,gBAAgB,KAAK,KAAK,EAAE;MAC9B,MAAM,CAACG,IAAI,EAAEnC,IAAI,CAAC,GAAGhC,IAAI,CAACuC,IAAI,CAAChC,MAAM,EAAE,EAAE,CAAC;MAC1C,MAAM2D,MAAM,GAAG;QACb5C,MAAM,EAAE;UAAEU,IAAI;UAAED,MAAM,EAAE,CAACoC,IAAI,CAAC1B,IAAI,IAAI,EAAE,EAAEC;QAAO,CAAC;QAClDlB,KAAK,EAAE;UAAEQ,IAAI;UAAED,MAAM,EAAE,CAACoC,IAAI,CAAC1B,IAAI,IAAI,EAAE,EAAEC;QAAO;MAClD,CAAC;MACD,OAAOwB,MAAM;IACf;IACA,OAAOF,gBAAgB;EACzB;AACF","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}