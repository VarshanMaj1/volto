{"ast":null,"code":"import _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from '@plone/volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers/Url/Url';\nimport { validateFileUploadSize } from '@plone/volto/helpers/FormValidation/FormValidation';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\nimport { IMAGE } from '@plone/volto-slate/constants';\nexport const insertImage = (editor, url, {\n  typeImg = IMAGE\n} = {}) => {\n  const image = {\n    type: typeImg,\n    url,\n    children: [{\n      text: ''\n    }]\n  };\n  Transforms.insertNodes(editor, image);\n};\nexport const isImageUrl = url => {\n  if (!isUrl(url)) return false;\n  const ext = new URL(url).pathname.split('.').pop();\n  return imageExtensions.includes(ext);\n};\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result;\n\n  // if (url) insertImage(editor, url);\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    uploadContent,\n    pathname\n  } = blockProps;\n\n  // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName\n    }\n  };\n  uploadContent(url, content, block);\n};\nexport const withDeserializers = editor => {\n  var _editor$dataTransferH;\n  editor.htmlTagsToSlate = _objectSpread(_objectSpread({}, editor.htmlTagsToSlate), {}, {\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2')\n  });\n  const handleFiles = ((_editor$dataTransferH = editor.dataTransferHandlers) === null || _editor$dataTransferH === void 0 ? void 0 : _editor$dataTransferH.files) || (() => true);\n  editor.dataTransferHandlers = _objectSpread(_objectSpread({}, editor.dataTransferHandlers), {}, {\n    files: files => {\n      const unprocessed = [];\n      const {\n        intl\n      } = editor.getBlockProps();\n      for (const file of files) {\n        if (!validateFileUploadSize(file, intl.formatMessage)) return;\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n      return handleFiles(unprocessed);\n    }\n  });\n  return editor;\n};","map":{"version":3,"names":["isUrl","imageExtensions","blockTagDeserializer","getBaseUrl","validateFileUploadSize","v4","uuid","Transforms","IMAGE","insertImage","editor","url","typeImg","image","type","children","text","insertNodes","isImageUrl","ext","URL","pathname","split","pop","includes","onImageLoad","reader","data","result","fields","match","blockProps","getBlockProps","block","uploadContent","uploadId","uploadFileName","uploadTitle","content","title","encoding","filename","withDeserializers","_editor$dataTransferH","htmlTagsToSlate","_objectSpread","H1","handleFiles","dataTransferHandlers","files","unprocessed","intl","file","formatMessage","FileReader","mime","addEventListener","readAsDataURL","push"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/blocks/Text/extensions/withDeserializers.js"],"sourcesContent":["import isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from '@plone/volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers/Url/Url';\nimport { validateFileUploadSize } from '@plone/volto/helpers/FormValidation/FormValidation';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\n\nimport { IMAGE } from '@plone/volto-slate/constants';\n\nexport const insertImage = (editor, url, { typeImg = IMAGE } = {}) => {\n  const image = { type: typeImg, url, children: [{ text: '' }] };\n  Transforms.insertNodes(editor, image);\n};\n\nexport const isImageUrl = (url) => {\n  if (!isUrl(url)) return false;\n\n  const ext = new URL(url).pathname.split('.').pop();\n\n  return imageExtensions.includes(ext);\n};\n\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result;\n\n  // if (url) insertImage(editor, url);\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const { block, uploadContent, pathname } = blockProps;\n\n  // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName,\n    },\n  };\n\n  uploadContent(url, content, block);\n};\n\nexport const withDeserializers = (editor) => {\n  editor.htmlTagsToSlate = {\n    ...editor.htmlTagsToSlate,\n\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2'),\n  };\n\n  const handleFiles = editor.dataTransferHandlers?.files || (() => true);\n\n  editor.dataTransferHandlers = {\n    ...editor.dataTransferHandlers,\n    files: (files) => {\n      const unprocessed = [];\n      const { intl } = editor.getBlockProps();\n      for (const file of files) {\n        if (!validateFileUploadSize(file, intl.formatMessage)) return;\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n\n      return handleFiles(unprocessed);\n    },\n  };\n\n  return editor;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}