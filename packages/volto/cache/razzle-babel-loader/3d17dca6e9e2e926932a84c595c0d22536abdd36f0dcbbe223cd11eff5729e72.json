{"ast":null,"code":"import { Editor, Transforms, Node } from 'slate';\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = elementType => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n    const rangeRef = Editor.rangeRef(editor, selection);\n    const res = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      mode: 'highest',\n      at: selection\n    }));\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(editor, {\n        data\n      }, {\n        at: path ? path : null,\n        match: path ? n => n.type === elementType : null\n      });\n    } else {\n      Transforms.wrapNodes(editor, {\n        type: elementType,\n        data\n      }, {\n        split: true,\n        at: selection,\n        match: node => {\n          return Node.string(node).length !== 0;\n        }\n      });\n    }\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    setTimeout(() => {\n      Transforms.select(editor, sel);\n      editor.setSavedSelection(sel);\n    });\n    return true;\n  }\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array.\n * It identifies the current target element and expands the selection to it, in\n * case the selection was just partial. This allows a \"clear and reassign\"\n * operation, for example for the Link plugin.\n *\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let [link] = Editor.nodes(editor, {\n    at: selection,\n    match: node => (node === null || node === void 0 ? void 0 : node.type) === elementType\n  });\n  const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n  if (!link && !isAtStart) return false;\n  if (!link) {\n    try {\n      link = Editor.previous(editor, {\n        at: selection.anchor.path\n      });\n    } catch (ex) {\n      link = [];\n    }\n  }\n  const [, path] = link;\n  const [start, end] = Editor.edges(editor, path);\n  const range = {\n    anchor: start,\n    focus: end\n  };\n  const ref = Editor.rangeRef(editor, range);\n  Transforms.select(editor, range);\n  Transforms.unwrapNodes(editor, {\n    match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n    at: range\n  });\n  const current = ref.current;\n  ref.unref();\n  return current;\n};\nexport const _isActiveElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      at: selection\n    }) || []);\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n  if (selection) {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = elementType => (editor, direction = 'any') => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n      at: selection\n    }));\n  } catch (e) {\n    return null;\n  }\n  if (found.length) return found[0];\n  if (!selection) return null;\n  if (direction === 'any' || direction === 'backward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n  if (direction === 'any' || direction === 'forward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["Editor","Transforms","Node","_insertElement","elementType","editor","data","getSavedSelection","selection","rangeRef","res","Array","from","nodes","match","n","type","mode","at","length","path","setNodes","wrapNodes","split","node","string","sel","JSON","parse","stringify","current","setTimeout","select","setSavedSelection","_unwrapElement","link","isAtStart","anchor","offset","focus","previous","ex","start","end","edges","range","ref","unwrapNodes","isArray","includes","unref","_isActiveElement","found","e","_getActiveElement","direction","console","warn","next"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/elementEditor/utils.js"],"sourcesContent":["import { Editor, Transforms, Node } from 'slate';\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = (elementType) => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n\n    const rangeRef = Editor.rangeRef(editor, selection);\n\n    const res = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        mode: 'highest',\n        at: selection,\n      }),\n    );\n\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(\n        editor,\n        { data },\n        {\n          at: path ? path : null,\n          match: path ? (n) => n.type === elementType : null,\n        },\n      );\n    } else {\n      Transforms.wrapNodes(\n        editor,\n        { type: elementType, data },\n        {\n          split: true,\n          at: selection,\n          match: (node) => {\n            return Node.string(node).length !== 0;\n          },\n        },\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n\n    setTimeout(() => {\n      Transforms.select(editor, sel);\n      editor.setSavedSelection(sel);\n    });\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array.\n * It identifies the current target element and expands the selection to it, in\n * case the selection was just partial. This allows a \"clear and reassign\"\n * operation, for example for the Link plugin.\n *\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let [link] = Editor.nodes(editor, {\n    at: selection,\n    match: (node) => node?.type === elementType,\n  });\n  const isAtStart =\n    selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n  if (!link && !isAtStart) return false;\n\n  if (!link) {\n    try {\n      link = Editor.previous(editor, {\n        at: selection.anchor.path,\n      });\n    } catch (ex) {\n      link = [];\n    }\n  }\n\n  const [, path] = link;\n  const [start, end] = Editor.edges(editor, path);\n  const range = { anchor: start, focus: end };\n\n  const ref = Editor.rangeRef(editor, range);\n\n  Transforms.select(editor, range);\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      Array.isArray(elementType)\n        ? elementType.includes(n.type)\n        : n.type === elementType,\n    at: range,\n  });\n\n  const current = ref.current;\n  ref.unref();\n\n  return current;\n};\n\nexport const _isActiveElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        at: selection,\n      }) || [],\n    );\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n\n  if (selection) {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement =\n  (elementType) =>\n  (editor, direction = 'any') => {\n    const selection = editor.selection || editor.getSavedSelection();\n    let found = [];\n\n    try {\n      found = Array.from(\n        Editor.nodes(editor, {\n          match: (n) =>\n            Array.isArray(elementType)\n              ? elementType.includes(n.type)\n              : n.type === elementType,\n          at: selection,\n        }),\n      );\n    } catch (e) {\n      return null;\n    }\n\n    if (found.length) return found[0];\n\n    if (!selection) return null;\n\n    if (direction === 'any' || direction === 'backward') {\n      const { path } = selection.anchor;\n      const isAtStart =\n        selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n      if (isAtStart) {\n        let found;\n        try {\n          found = Editor.previous(editor, {\n            at: path,\n          });\n        } catch (ex) {\n          // eslint-disable-next-line no-console\n          console.warn('Unable to find previous node', editor, path);\n          return;\n        }\n        if (found && found[0] && found[0].type === elementType) {\n          if (\n            (Array.isArray(elementType) &&\n              elementType.includes(found[0].type)) ||\n            found[0].type === elementType\n          ) {\n            return found;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (direction === 'any' || direction === 'forward') {\n      const { path } = selection.anchor;\n      const isAtStart =\n        selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n      if (isAtStart) {\n        let found;\n        try {\n          found = Editor.next(editor, {\n            at: path,\n          });\n        } catch (e) {\n          // eslint-disable-next-line\n          console.warn('Unable to find next node', editor, path);\n          return;\n        }\n        if (found && found[0] && found[0].type === elementType) {\n          if (\n            (Array.isArray(elementType) &&\n              elementType.includes(found[0].type)) ||\n            found[0].type === elementType\n          ) {\n            return found;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,UAAU,EAAEC,IAAI,QAAQ,OAAO;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAIC,WAAW,IAAK,CAACC,MAAM,EAAEC,IAAI,KAAK;EAC/D,IAAID,MAAM,CAACE,iBAAiB,CAAC,CAAC,EAAE;IAC9B,MAAMC,SAAS,GAAGH,MAAM,CAACG,SAAS,IAAIH,MAAM,CAACE,iBAAiB,CAAC,CAAC;IAEhE,MAAME,QAAQ,GAAGT,MAAM,CAACS,QAAQ,CAACJ,MAAM,EAAEG,SAAS,CAAC;IAEnD,MAAME,GAAG,GAAGC,KAAK,CAACC,IAAI,CACpBZ,MAAM,CAACa,KAAK,CAACR,MAAM,EAAE;MACnBS,KAAK,EAAGC,CAAC,IAAKA,CAAC,CAACC,IAAI,KAAKZ,WAAW;MACpCa,IAAI,EAAE,SAAS;MACfC,EAAE,EAAEV;IACN,CAAC,CACH,CAAC;IAED,IAAIE,GAAG,CAACS,MAAM,EAAE;MACd,MAAM,GAAGC,IAAI,CAAC,GAAGV,GAAG,CAAC,CAAC,CAAC;MACvBT,UAAU,CAACoB,QAAQ,CACjBhB,MAAM,EACN;QAAEC;MAAK,CAAC,EACR;QACEY,EAAE,EAAEE,IAAI,GAAGA,IAAI,GAAG,IAAI;QACtBN,KAAK,EAAEM,IAAI,GAAIL,CAAC,IAAKA,CAAC,CAACC,IAAI,KAAKZ,WAAW,GAAG;MAChD,CACF,CAAC;IACH,CAAC,MAAM;MACLH,UAAU,CAACqB,SAAS,CAClBjB,MAAM,EACN;QAAEW,IAAI,EAAEZ,WAAW;QAAEE;MAAK,CAAC,EAC3B;QACEiB,KAAK,EAAE,IAAI;QACXL,EAAE,EAAEV,SAAS;QACbM,KAAK,EAAGU,IAAI,IAAK;UACf,OAAOtB,IAAI,CAACuB,MAAM,CAACD,IAAI,CAAC,CAACL,MAAM,KAAK,CAAC;QACvC;MACF,CACF,CAAC;IACH;IAEA,MAAMO,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACpB,QAAQ,CAACqB,OAAO,CAAC,CAAC;IAExDC,UAAU,CAAC,MAAM;MACf9B,UAAU,CAAC+B,MAAM,CAAC3B,MAAM,EAAEqB,GAAG,CAAC;MAC9BrB,MAAM,CAAC4B,iBAAiB,CAACP,GAAG,CAAC;IAC/B,CAAC,CAAC;IAEF,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMQ,cAAc,GAAI9B,WAAW,IAAMC,MAAM,IAAK;EACzD,MAAMG,SAAS,GAAGH,MAAM,CAACG,SAAS,IAAIH,MAAM,CAACE,iBAAiB,CAAC,CAAC;EAChE,IAAI,CAAC4B,IAAI,CAAC,GAAGnC,MAAM,CAACa,KAAK,CAACR,MAAM,EAAE;IAChCa,EAAE,EAAEV,SAAS;IACbM,KAAK,EAAGU,IAAI,IAAK,CAAAA,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAER,IAAI,MAAKZ;EAClC,CAAC,CAAC;EACF,MAAMgC,SAAS,GACb5B,SAAS,CAAC6B,MAAM,CAACC,MAAM,KAAK,CAAC,IAAI9B,SAAS,CAAC+B,KAAK,CAACD,MAAM,KAAK,CAAC;EAE/D,IAAI,CAACH,IAAI,IAAI,CAACC,SAAS,EAAE,OAAO,KAAK;EAErC,IAAI,CAACD,IAAI,EAAE;IACT,IAAI;MACFA,IAAI,GAAGnC,MAAM,CAACwC,QAAQ,CAACnC,MAAM,EAAE;QAC7Ba,EAAE,EAAEV,SAAS,CAAC6B,MAAM,CAACjB;MACvB,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOqB,EAAE,EAAE;MACXN,IAAI,GAAG,EAAE;IACX;EACF;EAEA,MAAM,GAAGf,IAAI,CAAC,GAAGe,IAAI;EACrB,MAAM,CAACO,KAAK,EAAEC,GAAG,CAAC,GAAG3C,MAAM,CAAC4C,KAAK,CAACvC,MAAM,EAAEe,IAAI,CAAC;EAC/C,MAAMyB,KAAK,GAAG;IAAER,MAAM,EAAEK,KAAK;IAAEH,KAAK,EAAEI;EAAI,CAAC;EAE3C,MAAMG,GAAG,GAAG9C,MAAM,CAACS,QAAQ,CAACJ,MAAM,EAAEwC,KAAK,CAAC;EAE1C5C,UAAU,CAAC+B,MAAM,CAAC3B,MAAM,EAAEwC,KAAK,CAAC;EAChC5C,UAAU,CAAC8C,WAAW,CAAC1C,MAAM,EAAE;IAC7BS,KAAK,EAAGC,CAAC,IACPJ,KAAK,CAACqC,OAAO,CAAC5C,WAAW,CAAC,GACtBA,WAAW,CAAC6C,QAAQ,CAAClC,CAAC,CAACC,IAAI,CAAC,GAC5BD,CAAC,CAACC,IAAI,KAAKZ,WAAW;IAC5Bc,EAAE,EAAE2B;EACN,CAAC,CAAC;EAEF,MAAMf,OAAO,GAAGgB,GAAG,CAAChB,OAAO;EAC3BgB,GAAG,CAACI,KAAK,CAAC,CAAC;EAEX,OAAOpB,OAAO;AAChB,CAAC;AAED,OAAO,MAAMqB,gBAAgB,GAAI/C,WAAW,IAAMC,MAAM,IAAK;EAC3D,MAAMG,SAAS,GAAGH,MAAM,CAACG,SAAS,IAAIH,MAAM,CAACE,iBAAiB,CAAC,CAAC;EAChE,IAAI6C,KAAK;EACT,IAAI;IACFA,KAAK,GAAGzC,KAAK,CAACC,IAAI,CAChBZ,MAAM,CAACa,KAAK,CAACR,MAAM,EAAE;MACnBS,KAAK,EAAGC,CAAC,IAAKA,CAAC,CAACC,IAAI,KAAKZ,WAAW;MACpCc,EAAE,EAAEV;IACN,CAAC,CAAC,IAAI,EACR,CAAC;EACH,CAAC,CAAC,OAAO6C,CAAC,EAAE;IACV;IACA;IACA,OAAO,KAAK;EACd;EACA,IAAID,KAAK,CAACjC,MAAM,EAAE,OAAO,IAAI;EAE7B,IAAIX,SAAS,EAAE;IACb,MAAM;MAAEY;IAAK,CAAC,GAAGZ,SAAS,CAAC6B,MAAM;IACjC,MAAMD,SAAS,GACb5B,SAAS,CAAC6B,MAAM,CAACC,MAAM,KAAK,CAAC,IAAI9B,SAAS,CAAC+B,KAAK,CAACD,MAAM,KAAK,CAAC;IAE/D,IAAIF,SAAS,EAAE;MACb,IAAI;QACFgB,KAAK,GAAGpD,MAAM,CAACwC,QAAQ,CAACnC,MAAM,EAAE;UAC9Ba,EAAE,EAAEE;UACJ;QACF,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOqB,EAAE,EAAE;QACXW,KAAK,GAAG,EAAE;MACZ;MACA,IAAIA,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,KAAKZ,WAAW,EAAE;QACtD,OAAO,IAAI;MACb;IACF;EACF;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMkD,iBAAiB,GAC3BlD,WAAW,IACZ,CAACC,MAAM,EAAEkD,SAAS,GAAG,KAAK,KAAK;EAC7B,MAAM/C,SAAS,GAAGH,MAAM,CAACG,SAAS,IAAIH,MAAM,CAACE,iBAAiB,CAAC,CAAC;EAChE,IAAI6C,KAAK,GAAG,EAAE;EAEd,IAAI;IACFA,KAAK,GAAGzC,KAAK,CAACC,IAAI,CAChBZ,MAAM,CAACa,KAAK,CAACR,MAAM,EAAE;MACnBS,KAAK,EAAGC,CAAC,IACPJ,KAAK,CAACqC,OAAO,CAAC5C,WAAW,CAAC,GACtBA,WAAW,CAAC6C,QAAQ,CAAClC,CAAC,CAACC,IAAI,CAAC,GAC5BD,CAAC,CAACC,IAAI,KAAKZ,WAAW;MAC5Bc,EAAE,EAAEV;IACN,CAAC,CACH,CAAC;EACH,CAAC,CAAC,OAAO6C,CAAC,EAAE;IACV,OAAO,IAAI;EACb;EAEA,IAAID,KAAK,CAACjC,MAAM,EAAE,OAAOiC,KAAK,CAAC,CAAC,CAAC;EAEjC,IAAI,CAAC5C,SAAS,EAAE,OAAO,IAAI;EAE3B,IAAI+C,SAAS,KAAK,KAAK,IAAIA,SAAS,KAAK,UAAU,EAAE;IACnD,MAAM;MAAEnC;IAAK,CAAC,GAAGZ,SAAS,CAAC6B,MAAM;IACjC,MAAMD,SAAS,GACb5B,SAAS,CAAC6B,MAAM,CAACC,MAAM,KAAK,CAAC,IAAI9B,SAAS,CAAC+B,KAAK,CAACD,MAAM,KAAK,CAAC;IAE/D,IAAIF,SAAS,EAAE;MACb,IAAIgB,KAAK;MACT,IAAI;QACFA,KAAK,GAAGpD,MAAM,CAACwC,QAAQ,CAACnC,MAAM,EAAE;UAC9Ba,EAAE,EAAEE;QACN,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOqB,EAAE,EAAE;QACX;QACAe,OAAO,CAACC,IAAI,CAAC,8BAA8B,EAAEpD,MAAM,EAAEe,IAAI,CAAC;QAC1D;MACF;MACA,IAAIgC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,KAAKZ,WAAW,EAAE;QACtD,IACGO,KAAK,CAACqC,OAAO,CAAC5C,WAAW,CAAC,IACzBA,WAAW,CAAC6C,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,CAAC,IACrCoC,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,KAAKZ,WAAW,EAC7B;UACA,OAAOgD,KAAK;QACd;MACF,CAAC,MAAM;QACL,OAAO,IAAI;MACb;IACF;EACF;EAEA,IAAIG,SAAS,KAAK,KAAK,IAAIA,SAAS,KAAK,SAAS,EAAE;IAClD,MAAM;MAAEnC;IAAK,CAAC,GAAGZ,SAAS,CAAC6B,MAAM;IACjC,MAAMD,SAAS,GACb5B,SAAS,CAAC6B,MAAM,CAACC,MAAM,KAAK,CAAC,IAAI9B,SAAS,CAAC+B,KAAK,CAACD,MAAM,KAAK,CAAC;IAE/D,IAAIF,SAAS,EAAE;MACb,IAAIgB,KAAK;MACT,IAAI;QACFA,KAAK,GAAGpD,MAAM,CAAC0D,IAAI,CAACrD,MAAM,EAAE;UAC1Ba,EAAE,EAAEE;QACN,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOiC,CAAC,EAAE;QACV;QACAG,OAAO,CAACC,IAAI,CAAC,0BAA0B,EAAEpD,MAAM,EAAEe,IAAI,CAAC;QACtD;MACF;MACA,IAAIgC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,KAAKZ,WAAW,EAAE;QACtD,IACGO,KAAK,CAACqC,OAAO,CAAC5C,WAAW,CAAC,IACzBA,WAAW,CAAC6C,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,CAAC,IACrCoC,KAAK,CAAC,CAAC,CAAC,CAACpC,IAAI,KAAKZ,WAAW,EAC7B;UACA,OAAOgD,KAAK;QACd;MACF,CAAC,MAAM;QACL,OAAO,IAAI;MACb;IACF;EACF;EAEA,OAAO,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}