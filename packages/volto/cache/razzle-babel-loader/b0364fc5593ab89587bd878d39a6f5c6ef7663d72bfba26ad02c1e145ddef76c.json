{"ast":null,"code":"const _excluded = [\"data\", \"intl\", \"navRoot\", \"contentType\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Blocks helper.\n * @module helpers/Blocks\n */\n\nimport omit from 'lodash/omit';\nimport without from 'lodash/without';\nimport endsWith from 'lodash/endsWith';\nimport find from 'lodash/find';\nimport isObject from 'lodash/isObject';\nimport keys from 'lodash/keys';\nimport merge from 'lodash/merge';\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers/Extensions';\nimport { insertInArray, removeFromArray } from '@plone/volto/helpers/Utils/Utils';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return find(keys(props), key => key !== 'volto.blocks' && endsWith(key, 'blocks')) || null;\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return find(keys(props), key => key !== 'volto.blocks' && endsWith(key, 'blocks_layout')) || null;\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return find(keys(props), key => key !== 'volto.blocks' && endsWith(key, 'blocks')) !== undefined;\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  var _blocks$blocksConfig$;\n  const {\n    blocks\n  } = config;\n  const blockType = data['@type'];\n  const check = (_blocks$blocksConfig$ = blocks.blocksConfig[blockType]) === null || _blocks$blocksConfig$ === void 0 ? void 0 : _blocks$blocksConfig$.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = properties => {\n  var _properties$blocksLay, _properties$blocksLay2;\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return ((_properties$blocksLay = properties[blocksLayoutFieldname]) === null || _properties$blocksLay === void 0 ? void 0 : (_properties$blocksLay2 = _properties$blocksLay.items) === null || _properties$blocksLay2 === void 0 ? void 0 : _properties$blocksLay2.map(n => [n, properties[blocksFieldName][n]])) || [];\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination)\n    }\n  });\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @param {Object} intl intl object.\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId, intl) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  let newFormData = _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: without(formData[blocksLayoutFieldname].items, blockId)\n    },\n    [blocksFieldname]: omit(formData[blocksFieldname], [blockId])\n  });\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0, {}, intl);\n  }\n  return newFormData;\n}\n\n/**\n * Adds a block to the blocks form\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @param {Object} blocksConfig Blocks configuration.\n * @param {Object} intl intl object.\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index, blocksConfig, intl) {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n  let value = applyBlockDefaults({\n    data: {\n      '@type': type\n    },\n    intl: _dummyIntl\n  });\n  return [id, applyBlockInitialValue({\n    id,\n    value,\n    blocksConfig,\n    formData: _objectSpread(_objectSpread({}, formData), {}, {\n      [blocksLayoutFieldname]: {\n        items: [...formData[blocksLayoutFieldname].items.slice(0, insert), id, ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []), ...formData[blocksLayoutFieldname].items.slice(insert)]\n      },\n      [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n        [id]: value\n      }, type !== settings.defaultBlockType && {\n        [idTrailingBlock]: {\n          '@type': settings.defaultBlockType\n        }\n      }),\n      selected: id\n    }),\n    intl\n  })];\n}\n\n/**\n * Gets an initial value for a block, based on configuration\n *\n * This allows blocks that need complex initial data structures to avoid having\n * to call `onChangeBlock` at their creation time, as this is prone to racing\n * issue on block data storage.\n */\nexport const applyBlockInitialValue = ({\n  id,\n  value,\n  blocksConfig,\n  formData,\n  intl\n}) => {\n  var _blocksConfig$type;\n  const type = value['@type'];\n  blocksConfig = blocksConfig || config.blocks.blocksConfig;\n  if ((_blocksConfig$type = blocksConfig[type]) !== null && _blocksConfig$type !== void 0 && _blocksConfig$type.initialValue) {\n    value = blocksConfig[type].initialValue({\n      id,\n      value,\n      formData,\n      intl\n    });\n    const blocksFieldname = getBlocksFieldname(formData);\n    formData[blocksFieldname][id] = value;\n  }\n  return formData;\n};\n\n/**\n * Mutate block, changes the block @type\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @param {Object} blocksConfig Blocks configuration.\n * @param {Object} intl intl object.\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value, blocksConfig, intl) {\n  const {\n    settings\n  } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n  value = applyBlockDefaults({\n    data: value,\n    intl: _dummyIntl\n  });\n  let newFormData;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    newFormData = applyBlockInitialValue({\n      id,\n      value,\n      blocksConfig,\n      formData: _objectSpread(_objectSpread({}, formData), {}, {\n        [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n          [id]: value || null\n        })\n      }),\n      intl\n    });\n    if (!blockHasValue(block)) {\n      return newFormData;\n    }\n  }\n  const idTrailingBlock = uuid();\n  newFormData = applyBlockInitialValue({\n    id,\n    value,\n    blocksConfig,\n    formData: _objectSpread(_objectSpread({}, formData), {}, {\n      [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n        [id]: value || null,\n        [idTrailingBlock]: {\n          '@type': settings.defaultBlockType\n        }\n      }),\n      [blocksLayoutFieldname]: {\n        items: [...formData[blocksLayoutFieldname].items.slice(0, index), idTrailingBlock, ...formData[blocksLayoutFieldname].items.slice(index)]\n      }\n    }),\n    intl\n  });\n  return newFormData;\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @param {Object} current Current block\n * @param {number} offset offset position\n * @param {Object} blocksConfig Blocks configuration.\n * @param {Object} intl intl object.\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(formData, id, value, current = {}, offset = 0, blocksConfig, intl) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n  value = applyBlockDefaults({\n    data: value,\n    intl: _dummyIntl\n  });\n  const newBlockId = uuid();\n  const newFormData = applyBlockInitialValue({\n    id: newBlockId,\n    value,\n    blocksConfig,\n    formData: _objectSpread(_objectSpread({}, formData), {}, {\n      [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n        [newBlockId]: value || null,\n        [id]: _objectSpread(_objectSpread({}, formData[blocksFieldname][id]), current)\n      }),\n      [blocksLayoutFieldname]: {\n        items: [...formData[blocksLayoutFieldname].items.slice(0, index + offset), newBlockId, ...formData[blocksLayoutFieldname].items.slice(index + offset)]\n      }\n    }),\n    intl\n  });\n  return [newBlockId, newFormData];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null\n    })\n  });\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType\n      }\n    },\n    blocks_layout: {\n      items: [id]\n    }\n  };\n}\n\n/**\n * Generate empty blocks blocks/blocks_layout pair given the type\n * (could be empty, if not type given) and the number of blocks\n * @function blocksFormGenerator\n * @param {number} number How many blocks to generate of the type (could be \"empty\", if no type provided)\n * @param {string} type The type of the blocks\n * @return {Object} blocks/blocks_layout pair filled with the generated blocks\n */\nexport function blocksFormGenerator(number, type) {\n  const idMap = [...Array(number).keys()].map(() => uuid());\n  const start = {\n    blocks: {},\n    blocks_layout: {\n      items: idMap\n    }\n  };\n  return _objectSpread(_objectSpread({}, start), {}, {\n    blocks: Object.fromEntries(start.blocks_layout.items.map(item => [item, {\n      '@type': type || 'empty'\n    }]))\n  });\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys((blockdata === null || blockdata === void 0 ? void 0 : blockdata.data) || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\nlet _logged = false;\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({\n  data = {},\n  schema,\n  intl\n}) {\n  if (!intl && !_logged) {\n    // Old code that doesn't pass intl doesn't get ObjectWidget defaults\n    // eslint-disable-next-line no-console\n    console.warn(`You should pass intl to any applySchemaDefaults call. By failing to pass\n      the intl object, your ObjectWidget fields will not get default values\n      extracted from their schema.`);\n    _logged = true;\n  }\n  const derivedData = merge(Object.keys(schema.properties).reduce((accumulator, currentField) => {\n    return typeof schema.properties[currentField].default !== 'undefined' ? _objectSpread(_objectSpread({}, accumulator), {}, {\n      [currentField]: schema.properties[currentField].default\n    }) : intl && schema.properties[currentField].schema && !(schema.properties[currentField].widget === 'object_list') // TODO: this should be renamed as itemSchema\n    ? _objectSpread(_objectSpread({}, accumulator), {}, {\n      [currentField]: _objectSpread({}, applySchemaDefaults({\n        data: _objectSpread(_objectSpread({}, data[currentField]), accumulator[currentField]),\n        schema: typeof schema.properties[currentField].schema === 'function' ? schema.properties[currentField].schema({\n          data: accumulator[currentField],\n          formData: accumulator[currentField],\n          intl\n        }) : schema.properties[currentField].schema,\n        intl\n      }))\n    }) : accumulator;\n  }, {}), data);\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults(_ref, blocksConfig) {\n  let {\n      data,\n      intl,\n      navRoot,\n      contentType\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  // We pay attention to not break on a missing (invalid) block.\n  const block_type = data === null || data === void 0 ? void 0 : data['@type'];\n  const {\n    blockSchema\n  } = (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n  let schema = typeof blockSchema === 'function' ? blockSchema(_objectSpread({\n    data,\n    intl\n  }, rest)) : blockSchema;\n  schema = applySchemaEnhancer({\n    schema,\n    formData: data,\n    intl,\n    navRoot,\n    contentType\n  });\n  return applySchemaDefaults({\n    data,\n    schema,\n    intl\n  });\n}\n\n/**\n * Converts a name+value style pair (ex: color/red) to a classname,\n * such as \"has--color--red\"\n *\n * This can be expanded via the style names, by suffixing them with special\n * converters. See config.settings.styleClassNameConverters. Examples:\n *\n * styleToClassName('theme:noprefix', 'primary') returns \"primary\"\n * styleToClassName('inverted:bool', true) returns 'inverted'\n * styleToClassName('inverted:bool', false) returns ''\n */\nexport const styleToClassName = (key, value, prefix = '') => {\n  const converters = config.settings.styleClassNameConverters;\n  const [name, ...convIds] = key.split(':');\n  return (convIds.length ? convIds : ['default']).map(id => converters[id]).reduce((acc, conv) => conv(acc, value, prefix), name);\n};\nexport const buildStyleClassNamesFromData = (obj = {}, prefix = '') => {\n  // style wrapper object has the form:\n  // const styles = {\n  //   color: 'red',\n  //   backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n\n  return Object.entries(obj).filter(([k, v]) => !k.startsWith('--')).reduce((acc, [k, v]) => [...acc, ...(isObject(v) ? buildStyleClassNamesFromData(v, `${prefix}${k}--`) : [styleToClassName(k, v, prefix)])], []).filter(v => !!v);\n};\n\n/**\n * Generate classNames from extenders\n *\n * @function buildStyleClassNamesExtenders\n * @param {Object} params An object with data, content and block (current block id)\n * @return {Array} Extender classNames resultant array\n */\nexport const buildStyleClassNamesExtenders = ({\n  block,\n  content,\n  data,\n  classNames\n}) => {\n  return config.settings.styleClassNameExtenders.reduce((acc, extender) => extender({\n    block,\n    content,\n    data,\n    classNames: acc\n  }), classNames);\n};\n\n/**\n * Converts a name+value style pair (ex: color/red) to a pair of [k, v],\n * such as [\"color\", \"red\"] so it can be converted back to an object.\n * For now, only covering the 'CSSProperty' use case.\n */\nexport const styleDataToStyleObject = (key, value, prefix = '') => {\n  if (prefix) {\n    return [`--${prefix}${key.replace('--', '')}`, value];\n  } else {\n    return [key, value];\n  }\n};\n\n/**\n * Generate styles object from data\n *\n * @function buildStyleObjectFromData\n * @param {Object} data A block data object\n * @param {string} prefix The prefix (could be dragged from a recursive call, initially empty)\n * @return {Object} The style object ready to be passed as prop\n */\nexport const buildStyleObjectFromData = (data = {}, prefix = '') => {\n  // style wrapper object has the form:\n  // const styles = {\n  //   color: 'red',\n  //   '--background-color': '#AABBCC',\n  // }\n  // Returns: {'--background-color: '#AABBCC'}\n\n  function recursiveBuildStyleObjectFromData(obj, prefix) {\n    return Object.fromEntries(Object.entries(obj).filter(([k, v]) => k.startsWith('--') || isObject(v)).reduce((acc, [k, v]) => [...acc,\n    // Kept for easy debugging\n    // ...(() => {\n    //   if (isObject(v)) {\n    //     return Object.entries(\n    //       buildStyleObjectFromData(\n    //         v,\n    //         `${k.endsWith(':noprefix') ? '' : `${prefix}${k}--`}`,\n    //       ),\n    //     );\n    //   }\n    //   return [styleDataToStyleObject(k, v, prefix)];\n    // })(),\n    ...(isObject(v) ? Object.entries(recursiveBuildStyleObjectFromData(v, `${k.endsWith(':noprefix') ? '' : `${prefix}${k}--`}` // We don't add a prefix if the key ends with the marker suffix\n    )) : [styleDataToStyleObject(k, v, prefix)])], []).filter(v => !!v));\n  }\n\n  // If the block has a `@type`, it's a full data block object\n  // Then apply the style enhancers\n  if (data['@type']) {\n    const styleObj = data.styles || {};\n    const stylesFromCSSproperties = recursiveBuildStyleObjectFromData(styleObj, prefix);\n    let stylesFromObjectStyleEnhancers = {};\n    const enhancers = config.getUtilities({\n      type: 'styleWrapperStyleObjectEnhancer'\n    });\n    enhancers.forEach(({\n      method\n    }) => {\n      stylesFromObjectStyleEnhancers = _objectSpread(_objectSpread({}, stylesFromObjectStyleEnhancers), method(data));\n    });\n    return _objectSpread(_objectSpread({}, stylesFromCSSproperties), stylesFromObjectStyleEnhancers);\n  } else {\n    return recursiveBuildStyleObjectFromData(data, prefix);\n  }\n};\n\n/**\n * Find a matching style by name given a style definition\n *\n * @function findStyleByName\n * @param {Object} styleDefinitions An object with the style definitions\n * @param {string} name The name of the style to find\n * @return {Object} The style object of the matching name\n */\nexport function findStyleByName(styleDefinitions, name) {\n  var _styleDefinitions$fin;\n  return (_styleDefinitions$fin = styleDefinitions.find(color => color.name === name)) === null || _styleDefinitions$fin === void 0 ? void 0 : _styleDefinitions$fin.style;\n}\n\n/**\n * Return previous/next blocks given the content object and the current block id\n *\n * @function getPreviousNextBlock\n * @param {Object} params An object with the content object and block (current block id)\n * @return {Array} An array with the signature [previousBlock, nextBlock]\n */\nexport const getPreviousNextBlock = ({\n  content,\n  block\n}) => {\n  const previousBlock = content['blocks'][content['blocks_layout'].items[content['blocks_layout'].items.indexOf(block) - 1]];\n  const nextBlock = content['blocks'][content['blocks_layout'].items[content['blocks_layout'].items.indexOf(block) + 1]];\n  return [previousBlock, nextBlock];\n};\n\n/**\n * Check if a block is a container block\n * check blocks from data as well since some add-ons use that\n * such as @eeacms/volto-tabs-block\n */\nexport function isBlockContainer(block) {\n  return block && (hasBlocksData(block) || block.hasOwnProperty('data') && hasBlocksData(block.data));\n}\n\n/**\n * Given a `block` object and a list of block types, return a list of block ids matching the types\n *\n * @function findBlocks\n * @param {Object} types A list with the list of types to be matched\n * @return {Array} An array of block ids\n */\nexport function findBlocks(blocks = {}, types, result = []) {\n  Object.keys(blocks).forEach(blockId => {\n    var _block$data;\n    const block = blocks[blockId];\n    // check blocks from data as well since some add-ons use that\n    // such as @eeacms/volto-tabs-block\n    const child_blocks = block.blocks || ((_block$data = block.data) === null || _block$data === void 0 ? void 0 : _block$data.blocks);\n    if (types.includes(block['@type'])) {\n      result.push(blockId);\n    } else if (isBlockContainer(block)) {\n      findBlocks(child_blocks, types, result);\n    }\n  });\n  return result;\n}\n\n/**\n * Build a block's hierarchy that the order tab can understand and uses\n */\nexport const getBlocksHierarchy = properties => {\n  var _properties$blocksLay3, _properties$blocksLay4;\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return (_properties$blocksLay3 = properties[blocksLayoutFieldname]) === null || _properties$blocksLay3 === void 0 ? void 0 : (_properties$blocksLay4 = _properties$blocksLay3.items) === null || _properties$blocksLay4 === void 0 ? void 0 : _properties$blocksLay4.map(n => {\n    var _properties$blocksFie;\n    return {\n      id: n,\n      title: (_properties$blocksFie = properties[blocksFieldName][n]) === null || _properties$blocksFie === void 0 ? void 0 : _properties$blocksFie['@type'],\n      data: properties[blocksFieldName][n],\n      children: isBlockContainer(properties[blocksFieldName][n]) ? getBlocksHierarchy(properties[blocksFieldName][n]) : []\n    };\n  });\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlockEnhanced(formData, {\n  source,\n  destination\n}) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const blocksFieldName = getBlocksFieldname(formData);\n\n  // If either one of source and destination are present\n  // (Moves intra-container or container <-> main container)\n  if (source.parent || destination.parent) {\n    // Move from a container to the main container\n    if (source.parent && !destination.parent) {\n      let clonedFormData = _objectSpread({}, formData);\n      clonedFormData[blocksFieldName][source.id] = formData[blocksFieldName][source.parent][blocksFieldName][source.id];\n      clonedFormData[blocksLayoutFieldname].items = insertInArray(formData[blocksLayoutFieldname].items, source.id, destination.position);\n\n      // Remove the source block from the source parent\n      const sourceContainer = findContainer(clonedFormData, {\n        containerId: source.parent\n      });\n      delete sourceContainer[blocksFieldName][source.id];\n      sourceContainer[blocksLayoutFieldname].items = removeFromArray(sourceContainer[blocksLayoutFieldname].items, source.position);\n      return clonedFormData;\n    }\n\n    // Move from the main container to an inner container\n    if (!source.parent && destination.parent) {\n      let clonedFormData = _objectSpread({}, formData);\n      const destinationContainer = findContainer(clonedFormData, {\n        containerId: destination.parent\n      });\n      destinationContainer[blocksFieldName][source.id] = clonedFormData[blocksFieldName][source.id];\n      destinationContainer[blocksLayoutFieldname].items = insertInArray(destinationContainer[blocksLayoutFieldname].items, source.id, destination.position);\n\n      // Remove the source block from the source parent\n      delete clonedFormData[blocksFieldName][source.id];\n      clonedFormData[blocksLayoutFieldname].items = removeFromArray(clonedFormData[blocksLayoutFieldname].items, source.position);\n      return clonedFormData;\n    }\n\n    // Move within the same container (except moves within the main container)\n    if (source.parent === destination.parent) {\n      let clonedFormData = _objectSpread({}, formData);\n      const destinationContainer = findContainer(clonedFormData, {\n        containerId: destination.parent\n      });\n      destinationContainer[blocksLayoutFieldname].items = move(destinationContainer[blocksLayoutFieldname].items, source.position, destination.position);\n      return clonedFormData;\n    }\n\n    // Move between containers\n    if (source.parent !== destination.parent) {\n      let clonedFormData = _objectSpread({}, formData);\n      const destinationContainer = findContainer(clonedFormData, {\n        containerId: destination.parent\n      });\n      destinationContainer[blocksFieldName][source.id] = formData[blocksFieldName][source.parent][blocksFieldName][source.id];\n      destinationContainer[blocksLayoutFieldname].items = insertInArray(destinationContainer[blocksLayoutFieldname].items, source.id, destination.position);\n\n      // Remove the source block from the source parent\n      const sourceContainer = findContainer(clonedFormData, {\n        containerId: source.parent\n      });\n      delete sourceContainer[blocksFieldName][source.id];\n      sourceContainer[blocksLayoutFieldname].items = removeFromArray(sourceContainer[blocksLayoutFieldname].items, source.position);\n      return clonedFormData;\n    }\n  }\n\n  // Default catch all, no source/destination parent specified\n  // Move within the main container\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source.position, destination.position)\n    }\n  });\n}\n\n/**\n * Finds the container with the specified containerId in the given formData.\n *\n * @param {object} formData - The form data object.\n * @param {object} options - The options object.\n * @param {string} options.containerId - The ID of the container to find.\n * @returns {object|undefined} - The container object if found, otherwise undefined.\n */\nexport const findContainer = (formData, {\n  containerId\n}) => {\n  if (formData.blocks[containerId] && Object.keys(formData.blocks[containerId]).includes('blocks') && Object.keys(formData.blocks[containerId]).includes('blocks_layout')) {\n    return formData.blocks[containerId];\n  }\n  let container;\n  Object.keys(formData.blocks).every(blockId => {\n    const block = formData.blocks[blockId];\n    if (formData.blocks[blockId] && Object.keys(formData.blocks[blockId]).includes('blocks') && Object.keys(formData.blocks[blockId]).includes('blocks_layout')) {\n      container = findContainer(block, {\n        containerId\n      });\n    }\n    if (container) {\n      return false;\n    } else {\n      return true;\n    }\n  });\n  return container;\n};\nconst _dummyIntl = {\n  formatMessage() {}\n};","map":{"version":3,"names":["omit","without","endsWith","find","isObject","keys","merge","move","v4","uuid","config","applySchemaEnhancer","insertInArray","removeFromArray","getBlocksFieldname","props","key","getBlocksLayoutFieldname","hasBlocksData","undefined","blockHasValue","data","_blocks$blocksConfig$","blocks","blockType","check","blocksConfig","getBlocks","properties","_properties$blocksLay","_properties$blocksLay2","blocksFieldName","blocksLayoutFieldname","items","map","n","moveBlock","formData","source","destination","_objectSpread","deleteBlock","blockId","intl","blocksFieldname","newFormData","length","addBlock","settings","defaultBlockType","type","index","id","idTrailingBlock","totalItems","insert","value","applyBlockDefaults","_dummyIntl","applyBlockInitialValue","slice","selected","_blocksConfig$type","initialValue","mutateBlock","indexOf","trailId","block","insertBlock","current","offset","newBlockId","changeBlock","nextBlockId","currentBlock","currentIndex","newIndex","previousBlockId","newindex","emptyBlocksForm","blocks_layout","blocksFormGenerator","number","idMap","Array","start","Object","fromEntries","item","visitBlocks","content","callback","queue","blockdata","shift","push","_logged","applySchemaDefaults","schema","console","warn","derivedData","reduce","accumulator","currentField","default","widget","_ref","navRoot","contentType","rest","_objectWithoutProperties","_excluded","block_type","blockSchema","styleToClassName","prefix","converters","styleClassNameConverters","name","convIds","split","acc","conv","buildStyleClassNamesFromData","obj","entries","filter","k","v","startsWith","buildStyleClassNamesExtenders","classNames","styleClassNameExtenders","extender","styleDataToStyleObject","replace","buildStyleObjectFromData","recursiveBuildStyleObjectFromData","styleObj","styles","stylesFromCSSproperties","stylesFromObjectStyleEnhancers","enhancers","getUtilities","forEach","method","findStyleByName","styleDefinitions","_styleDefinitions$fin","color","style","getPreviousNextBlock","previousBlock","nextBlock","isBlockContainer","hasOwnProperty","findBlocks","types","result","_block$data","child_blocks","includes","getBlocksHierarchy","_properties$blocksLay3","_properties$blocksLay4","_properties$blocksFie","title","children","moveBlockEnhanced","parent","clonedFormData","position","sourceContainer","findContainer","containerId","destinationContainer","container","every","formatMessage"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/Blocks/Blocks.js"],"sourcesContent":["/**\n * Blocks helper.\n * @module helpers/Blocks\n */\n\nimport omit from 'lodash/omit';\nimport without from 'lodash/without';\nimport endsWith from 'lodash/endsWith';\nimport find from 'lodash/find';\nimport isObject from 'lodash/isObject';\nimport keys from 'lodash/keys';\nimport merge from 'lodash/merge';\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers/Extensions';\nimport {\n  insertInArray,\n  removeFromArray,\n} from '@plone/volto/helpers/Utils/Utils';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) || null\n  );\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks_layout'),\n    ) || null\n  );\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) !== undefined\n  );\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  const { blocks } = config;\n  const blockType = data['@type'];\n  const check = blocks.blocksConfig[blockType]?.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = (properties) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return (\n    properties[blocksLayoutFieldname]?.items?.map((n) => [\n      n,\n      properties[blocksFieldName][n],\n    ]) || []\n  );\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination),\n    },\n  };\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @param {Object} intl intl object.\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId, intl) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  let newFormData = {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: without(formData[blocksLayoutFieldname].items, blockId),\n    },\n    [blocksFieldname]: omit(formData[blocksFieldname], [blockId]),\n  };\n\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(\n      newFormData,\n      config.settings.defaultBlockType,\n      0,\n      {},\n      intl,\n    );\n  }\n\n  return newFormData;\n}\n\n/**\n * Adds a block to the blocks form\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @param {Object} blocksConfig Blocks configuration.\n * @param {Object} intl intl object.\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index, blocksConfig, intl) {\n  const { settings } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n\n  let value = applyBlockDefaults({\n    data: {\n      '@type': type,\n    },\n    intl: _dummyIntl,\n  });\n\n  return [\n    id,\n    applyBlockInitialValue({\n      id,\n      value,\n      blocksConfig,\n      formData: {\n        ...formData,\n        [blocksLayoutFieldname]: {\n          items: [\n            ...formData[blocksLayoutFieldname].items.slice(0, insert),\n            id,\n            ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []),\n            ...formData[blocksLayoutFieldname].items.slice(insert),\n          ],\n        },\n        [blocksFieldname]: {\n          ...formData[blocksFieldname],\n          [id]: value,\n          ...(type !== settings.defaultBlockType && {\n            [idTrailingBlock]: {\n              '@type': settings.defaultBlockType,\n            },\n          }),\n        },\n        selected: id,\n      },\n      intl,\n    }),\n  ];\n}\n\n/**\n * Gets an initial value for a block, based on configuration\n *\n * This allows blocks that need complex initial data structures to avoid having\n * to call `onChangeBlock` at their creation time, as this is prone to racing\n * issue on block data storage.\n */\nexport const applyBlockInitialValue = ({\n  id,\n  value,\n  blocksConfig,\n  formData,\n  intl,\n}) => {\n  const type = value['@type'];\n  blocksConfig = blocksConfig || config.blocks.blocksConfig;\n\n  if (blocksConfig[type]?.initialValue) {\n    value = blocksConfig[type].initialValue({\n      id,\n      value,\n      formData,\n      intl,\n    });\n    const blocksFieldname = getBlocksFieldname(formData);\n    formData[blocksFieldname][id] = value;\n  }\n\n  return formData;\n};\n\n/**\n * Mutate block, changes the block @type\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @param {Object} blocksConfig Blocks configuration.\n * @param {Object} intl intl object.\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value, blocksConfig, intl) {\n  const { settings } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n\n  value = applyBlockDefaults({\n    data: value,\n    intl: _dummyIntl,\n  });\n  let newFormData;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    newFormData = applyBlockInitialValue({\n      id,\n      value,\n      blocksConfig,\n      formData: {\n        ...formData,\n        [blocksFieldname]: {\n          ...formData[blocksFieldname],\n          [id]: value || null,\n        },\n      },\n      intl,\n    });\n    if (!blockHasValue(block)) {\n      return newFormData;\n    }\n  }\n\n  const idTrailingBlock = uuid();\n  newFormData = applyBlockInitialValue({\n    id,\n    value,\n    blocksConfig,\n    formData: {\n      ...formData,\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [id]: value || null,\n        [idTrailingBlock]: {\n          '@type': settings.defaultBlockType,\n        },\n      },\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, index),\n          idTrailingBlock,\n          ...formData[blocksLayoutFieldname].items.slice(index),\n        ],\n      },\n    },\n    intl,\n  });\n  return newFormData;\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @param {Object} current Current block\n * @param {number} offset offset position\n * @param {Object} blocksConfig Blocks configuration.\n * @param {Object} intl intl object.\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(\n  formData,\n  id,\n  value,\n  current = {},\n  offset = 0,\n  blocksConfig,\n  intl,\n) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n\n  value = applyBlockDefaults({\n    data: value,\n    intl: _dummyIntl,\n  });\n\n  const newBlockId = uuid();\n  const newFormData = applyBlockInitialValue({\n    id: newBlockId,\n    value,\n    blocksConfig,\n    formData: {\n      ...formData,\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [newBlockId]: value || null,\n        [id]: {\n          ...formData[blocksFieldname][id],\n          ...current,\n        },\n      },\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, index + offset),\n          newBlockId,\n          ...formData[blocksLayoutFieldname].items.slice(index + offset),\n        ],\n      },\n    },\n    intl,\n  });\n\n  return [newBlockId, newFormData];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n    },\n  };\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex =\n    formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex =\n    formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const { settings } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    blocks_layout: { items: [id] },\n  };\n}\n\n/**\n * Generate empty blocks blocks/blocks_layout pair given the type\n * (could be empty, if not type given) and the number of blocks\n * @function blocksFormGenerator\n * @param {number} number How many blocks to generate of the type (could be \"empty\", if no type provided)\n * @param {string} type The type of the blocks\n * @return {Object} blocks/blocks_layout pair filled with the generated blocks\n */\nexport function blocksFormGenerator(number, type) {\n  const idMap = [...Array(number).keys()].map(() => uuid());\n  const start = {\n    blocks: {},\n    blocks_layout: { items: idMap },\n  };\n\n  return {\n    ...start,\n    blocks: Object.fromEntries(\n      start.blocks_layout.items.map((item) => [\n        item,\n        { '@type': type || 'empty' },\n      ]),\n    ),\n  };\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys(blockdata?.data || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\n\nlet _logged = false;\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({ data = {}, schema, intl }) {\n  if (!intl && !_logged) {\n    // Old code that doesn't pass intl doesn't get ObjectWidget defaults\n    // eslint-disable-next-line no-console\n    console.warn(\n      `You should pass intl to any applySchemaDefaults call. By failing to pass\n      the intl object, your ObjectWidget fields will not get default values\n      extracted from their schema.`,\n    );\n    _logged = true;\n  }\n\n  const derivedData = merge(\n    Object.keys(schema.properties).reduce((accumulator, currentField) => {\n      return typeof schema.properties[currentField].default !== 'undefined'\n        ? {\n            ...accumulator,\n            [currentField]: schema.properties[currentField].default,\n          }\n        : intl &&\n            schema.properties[currentField].schema &&\n            !(schema.properties[currentField].widget === 'object_list') // TODO: this should be renamed as itemSchema\n          ? {\n              ...accumulator,\n              [currentField]: {\n                ...applySchemaDefaults({\n                  data: { ...data[currentField], ...accumulator[currentField] },\n                  schema:\n                    typeof schema.properties[currentField].schema === 'function'\n                      ? schema.properties[currentField].schema({\n                          data: accumulator[currentField],\n                          formData: accumulator[currentField],\n                          intl,\n                        })\n                      : schema.properties[currentField].schema,\n                  intl,\n                }),\n              },\n            }\n          : accumulator;\n    }, {}),\n    data,\n  );\n\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults(\n  { data, intl, navRoot, contentType, ...rest },\n  blocksConfig,\n) {\n  // We pay attention to not break on a missing (invalid) block.\n  const block_type = data?.['@type'];\n  const { blockSchema } =\n    (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n\n  let schema =\n    typeof blockSchema === 'function'\n      ? blockSchema({ data, intl, ...rest })\n      : blockSchema;\n  schema = applySchemaEnhancer({\n    schema,\n    formData: data,\n    intl,\n    navRoot,\n    contentType,\n  });\n\n  return applySchemaDefaults({ data, schema, intl });\n}\n\n/**\n * Converts a name+value style pair (ex: color/red) to a classname,\n * such as \"has--color--red\"\n *\n * This can be expanded via the style names, by suffixing them with special\n * converters. See config.settings.styleClassNameConverters. Examples:\n *\n * styleToClassName('theme:noprefix', 'primary') returns \"primary\"\n * styleToClassName('inverted:bool', true) returns 'inverted'\n * styleToClassName('inverted:bool', false) returns ''\n */\nexport const styleToClassName = (key, value, prefix = '') => {\n  const converters = config.settings.styleClassNameConverters;\n  const [name, ...convIds] = key.split(':');\n\n  return (convIds.length ? convIds : ['default'])\n    .map((id) => converters[id])\n    .reduce((acc, conv) => conv(acc, value, prefix), name);\n};\n\nexport const buildStyleClassNamesFromData = (obj = {}, prefix = '') => {\n  // style wrapper object has the form:\n  // const styles = {\n  //   color: 'red',\n  //   backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n\n  return Object.entries(obj)\n    .filter(([k, v]) => !k.startsWith('--'))\n    .reduce(\n      (acc, [k, v]) => [\n        ...acc,\n        ...(isObject(v)\n          ? buildStyleClassNamesFromData(v, `${prefix}${k}--`)\n          : [styleToClassName(k, v, prefix)]),\n      ],\n      [],\n    )\n    .filter((v) => !!v);\n};\n\n/**\n * Generate classNames from extenders\n *\n * @function buildStyleClassNamesExtenders\n * @param {Object} params An object with data, content and block (current block id)\n * @return {Array} Extender classNames resultant array\n */\nexport const buildStyleClassNamesExtenders = ({\n  block,\n  content,\n  data,\n  classNames,\n}) => {\n  return config.settings.styleClassNameExtenders.reduce(\n    (acc, extender) => extender({ block, content, data, classNames: acc }),\n    classNames,\n  );\n};\n\n/**\n * Converts a name+value style pair (ex: color/red) to a pair of [k, v],\n * such as [\"color\", \"red\"] so it can be converted back to an object.\n * For now, only covering the 'CSSProperty' use case.\n */\nexport const styleDataToStyleObject = (key, value, prefix = '') => {\n  if (prefix) {\n    return [`--${prefix}${key.replace('--', '')}`, value];\n  } else {\n    return [key, value];\n  }\n};\n\n/**\n * Generate styles object from data\n *\n * @function buildStyleObjectFromData\n * @param {Object} data A block data object\n * @param {string} prefix The prefix (could be dragged from a recursive call, initially empty)\n * @return {Object} The style object ready to be passed as prop\n */\nexport const buildStyleObjectFromData = (data = {}, prefix = '') => {\n  // style wrapper object has the form:\n  // const styles = {\n  //   color: 'red',\n  //   '--background-color': '#AABBCC',\n  // }\n  // Returns: {'--background-color: '#AABBCC'}\n\n  function recursiveBuildStyleObjectFromData(obj, prefix) {\n    return Object.fromEntries(\n      Object.entries(obj)\n        .filter(([k, v]) => k.startsWith('--') || isObject(v))\n        .reduce(\n          (acc, [k, v]) => [\n            ...acc,\n            // Kept for easy debugging\n            // ...(() => {\n            //   if (isObject(v)) {\n            //     return Object.entries(\n            //       buildStyleObjectFromData(\n            //         v,\n            //         `${k.endsWith(':noprefix') ? '' : `${prefix}${k}--`}`,\n            //       ),\n            //     );\n            //   }\n            //   return [styleDataToStyleObject(k, v, prefix)];\n            // })(),\n            ...(isObject(v)\n              ? Object.entries(\n                  recursiveBuildStyleObjectFromData(\n                    v,\n                    `${k.endsWith(':noprefix') ? '' : `${prefix}${k}--`}`, // We don't add a prefix if the key ends with the marker suffix\n                  ),\n                )\n              : [styleDataToStyleObject(k, v, prefix)]),\n          ],\n          [],\n        )\n        .filter((v) => !!v),\n    );\n  }\n\n  // If the block has a `@type`, it's a full data block object\n  // Then apply the style enhancers\n  if (data['@type']) {\n    const styleObj = data.styles || {};\n    const stylesFromCSSproperties = recursiveBuildStyleObjectFromData(\n      styleObj,\n      prefix,\n    );\n\n    let stylesFromObjectStyleEnhancers = {};\n    const enhancers = config.getUtilities({\n      type: 'styleWrapperStyleObjectEnhancer',\n    });\n\n    enhancers.forEach(({ method }) => {\n      stylesFromObjectStyleEnhancers = {\n        ...stylesFromObjectStyleEnhancers,\n        ...method(data),\n      };\n    });\n\n    return { ...stylesFromCSSproperties, ...stylesFromObjectStyleEnhancers };\n  } else {\n    return recursiveBuildStyleObjectFromData(data, prefix);\n  }\n};\n\n/**\n * Find a matching style by name given a style definition\n *\n * @function findStyleByName\n * @param {Object} styleDefinitions An object with the style definitions\n * @param {string} name The name of the style to find\n * @return {Object} The style object of the matching name\n */\nexport function findStyleByName(styleDefinitions, name) {\n  return styleDefinitions.find((color) => color.name === name)?.style;\n}\n\n/**\n * Return previous/next blocks given the content object and the current block id\n *\n * @function getPreviousNextBlock\n * @param {Object} params An object with the content object and block (current block id)\n * @return {Array} An array with the signature [previousBlock, nextBlock]\n */\nexport const getPreviousNextBlock = ({ content, block }) => {\n  const previousBlock =\n    content['blocks'][\n      content['blocks_layout'].items[\n        content['blocks_layout'].items.indexOf(block) - 1\n      ]\n    ];\n  const nextBlock =\n    content['blocks'][\n      content['blocks_layout'].items[\n        content['blocks_layout'].items.indexOf(block) + 1\n      ]\n    ];\n\n  return [previousBlock, nextBlock];\n};\n\n/**\n * Check if a block is a container block\n * check blocks from data as well since some add-ons use that\n * such as @eeacms/volto-tabs-block\n */\nexport function isBlockContainer(block) {\n  return (\n    block &&\n    (hasBlocksData(block) ||\n      (block.hasOwnProperty('data') && hasBlocksData(block.data)))\n  );\n}\n\n/**\n * Given a `block` object and a list of block types, return a list of block ids matching the types\n *\n * @function findBlocks\n * @param {Object} types A list with the list of types to be matched\n * @return {Array} An array of block ids\n */\nexport function findBlocks(blocks = {}, types, result = []) {\n  Object.keys(blocks).forEach((blockId) => {\n    const block = blocks[blockId];\n    // check blocks from data as well since some add-ons use that\n    // such as @eeacms/volto-tabs-block\n    const child_blocks = block.blocks || block.data?.blocks;\n    if (types.includes(block['@type'])) {\n      result.push(blockId);\n    } else if (isBlockContainer(block)) {\n      findBlocks(child_blocks, types, result);\n    }\n  });\n\n  return result;\n}\n\n/**\n * Build a block's hierarchy that the order tab can understand and uses\n */\nexport const getBlocksHierarchy = (properties) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return properties[blocksLayoutFieldname]?.items?.map((n) => ({\n    id: n,\n    title: properties[blocksFieldName][n]?.['@type'],\n    data: properties[blocksFieldName][n],\n    children: isBlockContainer(properties[blocksFieldName][n])\n      ? getBlocksHierarchy(properties[blocksFieldName][n])\n      : [],\n  }));\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlockEnhanced(formData, { source, destination }) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const blocksFieldName = getBlocksFieldname(formData);\n\n  // If either one of source and destination are present\n  // (Moves intra-container or container <-> main container)\n  if (source.parent || destination.parent) {\n    // Move from a container to the main container\n    if (source.parent && !destination.parent) {\n      let clonedFormData = { ...formData };\n\n      clonedFormData[blocksFieldName][source.id] =\n        formData[blocksFieldName][source.parent][blocksFieldName][source.id];\n\n      clonedFormData[blocksLayoutFieldname].items = insertInArray(\n        formData[blocksLayoutFieldname].items,\n        source.id,\n        destination.position,\n      );\n\n      // Remove the source block from the source parent\n      const sourceContainer = findContainer(clonedFormData, {\n        containerId: source.parent,\n      });\n      delete sourceContainer[blocksFieldName][source.id];\n      sourceContainer[blocksLayoutFieldname].items = removeFromArray(\n        sourceContainer[blocksLayoutFieldname].items,\n        source.position,\n      );\n\n      return clonedFormData;\n    }\n\n    // Move from the main container to an inner container\n    if (!source.parent && destination.parent) {\n      let clonedFormData = { ...formData };\n\n      const destinationContainer = findContainer(clonedFormData, {\n        containerId: destination.parent,\n      });\n      destinationContainer[blocksFieldName][source.id] =\n        clonedFormData[blocksFieldName][source.id];\n      destinationContainer[blocksLayoutFieldname].items = insertInArray(\n        destinationContainer[blocksLayoutFieldname].items,\n        source.id,\n        destination.position,\n      );\n\n      // Remove the source block from the source parent\n      delete clonedFormData[blocksFieldName][source.id];\n      clonedFormData[blocksLayoutFieldname].items = removeFromArray(\n        clonedFormData[blocksLayoutFieldname].items,\n        source.position,\n      );\n\n      return clonedFormData;\n    }\n\n    // Move within the same container (except moves within the main container)\n    if (source.parent === destination.parent) {\n      let clonedFormData = { ...formData };\n\n      const destinationContainer = findContainer(clonedFormData, {\n        containerId: destination.parent,\n      });\n\n      destinationContainer[blocksLayoutFieldname].items = move(\n        destinationContainer[blocksLayoutFieldname].items,\n        source.position,\n        destination.position,\n      );\n      return clonedFormData;\n    }\n\n    // Move between containers\n    if (source.parent !== destination.parent) {\n      let clonedFormData = { ...formData };\n\n      const destinationContainer = findContainer(clonedFormData, {\n        containerId: destination.parent,\n      });\n      destinationContainer[blocksFieldName][source.id] =\n        formData[blocksFieldName][source.parent][blocksFieldName][source.id];\n\n      destinationContainer[blocksLayoutFieldname].items = insertInArray(\n        destinationContainer[blocksLayoutFieldname].items,\n        source.id,\n        destination.position,\n      );\n\n      // Remove the source block from the source parent\n      const sourceContainer = findContainer(clonedFormData, {\n        containerId: source.parent,\n      });\n      delete sourceContainer[blocksFieldName][source.id];\n      sourceContainer[blocksLayoutFieldname].items = removeFromArray(\n        sourceContainer[blocksLayoutFieldname].items,\n        source.position,\n      );\n\n      return clonedFormData;\n    }\n  }\n\n  // Default catch all, no source/destination parent specified\n  // Move within the main container\n  return {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: move(\n        formData[blocksLayoutFieldname].items,\n        source.position,\n        destination.position,\n      ),\n    },\n  };\n}\n\n/**\n * Finds the container with the specified containerId in the given formData.\n *\n * @param {object} formData - The form data object.\n * @param {object} options - The options object.\n * @param {string} options.containerId - The ID of the container to find.\n * @returns {object|undefined} - The container object if found, otherwise undefined.\n */\nexport const findContainer = (formData, { containerId }) => {\n  if (\n    formData.blocks[containerId] &&\n    Object.keys(formData.blocks[containerId]).includes('blocks') &&\n    Object.keys(formData.blocks[containerId]).includes('blocks_layout')\n  ) {\n    return formData.blocks[containerId];\n  }\n\n  let container;\n  Object.keys(formData.blocks).every((blockId) => {\n    const block = formData.blocks[blockId];\n    if (\n      formData.blocks[blockId] &&\n      Object.keys(formData.blocks[blockId]).includes('blocks') &&\n      Object.keys(formData.blocks[blockId]).includes('blocks_layout')\n    ) {\n      container = findContainer(block, { containerId });\n    }\n    if (container) {\n      return false;\n    } else {\n      return true;\n    }\n  });\n\n  return container;\n};\n\nconst _dummyIntl = {\n  formatMessage() {},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}