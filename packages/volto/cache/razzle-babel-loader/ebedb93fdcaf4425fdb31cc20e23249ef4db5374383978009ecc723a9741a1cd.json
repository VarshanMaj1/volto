{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { Node, Range } from 'slate';\n// import { ReactEditor } from 'slate-react';\n\nimport config from '@plone/volto/registry';\n\n/**\n * highlightByType.\n *\n * @param {} editor\n * @param {} node, path\n * @param {} ranges\n */\nexport const highlightByType = (editor, [node, path], ranges) => {\n  const {\n    slate\n  } = config.settings;\n  const {\n    nodeTypesToHighlight\n  } = slate;\n  if (nodeTypesToHighlight.includes(node.type)) {\n    const [found] = Node.texts(editor, {\n      from: path,\n      to: path\n    });\n    const visualSelectionRanges = highlightSelection(editor, found, ranges);\n    const text = Node.string(node) || '';\n    const range = {\n      anchor: {\n        path,\n        offset: 0\n      },\n      focus: {\n        path,\n        offset: text.length\n      },\n      // we need to differentiate between multiple highlight types, the active\n      // selection and the highlighted node\n      highlight: true,\n      highlightType: visualSelectionRanges.length === 0 ? node.type : null,\n      isSelection: visualSelectionRanges.length > 0\n    };\n    return [range];\n  }\n  return ranges;\n};\n\n/**\n * @function highlightSelection\n *\n * @summary A runtime decorator that decorates the saved selection, when the editor is\n * is no longer active.\n *\n * @param {Editor} editor The editor on which to apply the decorator.\n * @param {Node} node\n * @param {Path} path\n * @param {Array} ranges\n */\nexport function highlightSelection(editor, [node, path], ranges) {\n  let selected = editor.isSelected();\n  // const focused = ReactEditor.isFocused(editor);\n  // TODO: handle the case when the editor is not focused, then use the\n  // editor.getSavedSelection()\n\n  if (selected && editor.selection) {\n    const selection = editor.selection;\n    if (JSON.stringify(path) === JSON.stringify(selection.anchor.path)) {\n      const range = _objectSpread(_objectSpread({}, selection), {}, {\n        highlight: true,\n        highlightType: 'selection',\n        isSelection: true\n      });\n      if (Range.isExpanded(range)) {\n        ranges.push(range);\n      }\n    }\n  }\n  return ranges;\n}","map":{"version":3,"names":["Node","Range","config","highlightByType","editor","node","path","ranges","slate","settings","nodeTypesToHighlight","includes","type","found","texts","from","to","visualSelectionRanges","highlightSelection","text","string","range","anchor","offset","focus","length","highlight","highlightType","isSelection","selected","isSelected","selection","JSON","stringify","_objectSpread","isExpanded","push"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/decorate.js"],"sourcesContent":["import { Node, Range } from 'slate';\n// import { ReactEditor } from 'slate-react';\n\nimport config from '@plone/volto/registry';\n\n/**\n * highlightByType.\n *\n * @param {} editor\n * @param {} node, path\n * @param {} ranges\n */\nexport const highlightByType = (editor, [node, path], ranges) => {\n  const { slate } = config.settings;\n  const { nodeTypesToHighlight } = slate;\n\n  if (nodeTypesToHighlight.includes(node.type)) {\n    const [found] = Node.texts(editor, { from: path, to: path });\n    const visualSelectionRanges = highlightSelection(editor, found, ranges);\n    const text = Node.string(node) || '';\n    const range = {\n      anchor: { path, offset: 0 },\n      focus: { path, offset: text.length },\n      // we need to differentiate between multiple highlight types, the active\n      // selection and the highlighted node\n      highlight: true,\n      highlightType: visualSelectionRanges.length === 0 ? node.type : null,\n      isSelection: visualSelectionRanges.length > 0,\n    };\n    return [range];\n  }\n\n  return ranges;\n};\n\n/**\n * @function highlightSelection\n *\n * @summary A runtime decorator that decorates the saved selection, when the editor is\n * is no longer active.\n *\n * @param {Editor} editor The editor on which to apply the decorator.\n * @param {Node} node\n * @param {Path} path\n * @param {Array} ranges\n */\nexport function highlightSelection(editor, [node, path], ranges) {\n  let selected = editor.isSelected();\n  // const focused = ReactEditor.isFocused(editor);\n  // TODO: handle the case when the editor is not focused, then use the\n  // editor.getSavedSelection()\n\n  if (selected && editor.selection) {\n    const selection = editor.selection;\n    if (JSON.stringify(path) === JSON.stringify(selection.anchor.path)) {\n      const range = {\n        ...selection,\n        highlight: true,\n        highlightType: 'selection',\n        isSelection: true,\n      };\n      if (Range.isExpanded(range)) {\n        ranges.push(range);\n      }\n    }\n  }\n  return ranges;\n}\n"],"mappings":";;;;;AAAA,SAASA,IAAI,EAAEC,KAAK,QAAQ,OAAO;AACnC;;AAEA,OAAOC,MAAM,MAAM,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAGA,CAACC,MAAM,EAAE,CAACC,IAAI,EAAEC,IAAI,CAAC,EAAEC,MAAM,KAAK;EAC/D,MAAM;IAAEC;EAAM,CAAC,GAAGN,MAAM,CAACO,QAAQ;EACjC,MAAM;IAAEC;EAAqB,CAAC,GAAGF,KAAK;EAEtC,IAAIE,oBAAoB,CAACC,QAAQ,CAACN,IAAI,CAACO,IAAI,CAAC,EAAE;IAC5C,MAAM,CAACC,KAAK,CAAC,GAAGb,IAAI,CAACc,KAAK,CAACV,MAAM,EAAE;MAAEW,IAAI,EAAET,IAAI;MAAEU,EAAE,EAAEV;IAAK,CAAC,CAAC;IAC5D,MAAMW,qBAAqB,GAAGC,kBAAkB,CAACd,MAAM,EAAES,KAAK,EAAEN,MAAM,CAAC;IACvE,MAAMY,IAAI,GAAGnB,IAAI,CAACoB,MAAM,CAACf,IAAI,CAAC,IAAI,EAAE;IACpC,MAAMgB,KAAK,GAAG;MACZC,MAAM,EAAE;QAAEhB,IAAI;QAAEiB,MAAM,EAAE;MAAE,CAAC;MAC3BC,KAAK,EAAE;QAAElB,IAAI;QAAEiB,MAAM,EAAEJ,IAAI,CAACM;MAAO,CAAC;MACpC;MACA;MACAC,SAAS,EAAE,IAAI;MACfC,aAAa,EAAEV,qBAAqB,CAACQ,MAAM,KAAK,CAAC,GAAGpB,IAAI,CAACO,IAAI,GAAG,IAAI;MACpEgB,WAAW,EAAEX,qBAAqB,CAACQ,MAAM,GAAG;IAC9C,CAAC;IACD,OAAO,CAACJ,KAAK,CAAC;EAChB;EAEA,OAAOd,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,kBAAkBA,CAACd,MAAM,EAAE,CAACC,IAAI,EAAEC,IAAI,CAAC,EAAEC,MAAM,EAAE;EAC/D,IAAIsB,QAAQ,GAAGzB,MAAM,CAAC0B,UAAU,CAAC,CAAC;EAClC;EACA;EACA;;EAEA,IAAID,QAAQ,IAAIzB,MAAM,CAAC2B,SAAS,EAAE;IAChC,MAAMA,SAAS,GAAG3B,MAAM,CAAC2B,SAAS;IAClC,IAAIC,IAAI,CAACC,SAAS,CAAC3B,IAAI,CAAC,KAAK0B,IAAI,CAACC,SAAS,CAACF,SAAS,CAACT,MAAM,CAAChB,IAAI,CAAC,EAAE;MAClE,MAAMe,KAAK,GAAAa,aAAA,CAAAA,aAAA,KACNH,SAAS;QACZL,SAAS,EAAE,IAAI;QACfC,aAAa,EAAE,WAAW;QAC1BC,WAAW,EAAE;MAAI,EAClB;MACD,IAAI3B,KAAK,CAACkC,UAAU,CAACd,KAAK,CAAC,EAAE;QAC3Bd,MAAM,CAAC6B,IAAI,CAACf,KAAK,CAAC;MACpB;IACF;EACF;EACA,OAAOd,MAAM;AACf","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}