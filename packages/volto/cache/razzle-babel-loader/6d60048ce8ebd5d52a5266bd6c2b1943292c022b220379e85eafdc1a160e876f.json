{"ast":null,"code":"var _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/FormValidation/FormValidation.jsx\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport map from 'lodash/map';\nimport keys from 'lodash/keys';\nimport intersection from 'lodash/intersection';\nimport isEmpty from 'lodash/isEmpty';\nimport { messages } from '@plone/volto/helpers/MessageLabels/MessageLabels';\nimport config from '@plone/volto/registry';\nimport { toast } from 'react-toastify';\nimport Toast from '@plone/volto/components/manage/Toast/Toast';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} criterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nexport const validationMessage = (isValid, criterion, valueToCompare, intlFunc) => !isValid ? intlFunc(messages[criterion], {\n  len: valueToCompare\n}) : null;\n\n/**\n * The string that comes might not be a valid JSON\n * @param {string} requestItem\n */\nexport const tryParseJSON = requestItem => {\n  let resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      try {\n        // Treats strings like: `'String \"double quotes\"'`\n        resultObj = JSON.parse(requestItem.replace(/\"/g, '\\\\\"').replace(/'/g, '\"'));\n      } catch (e) {\n        resultObj = null;\n      }\n    }\n  }\n  return resultObj;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nconst validateRequiredFields = (schema, formData, formatMessage, touchedField) => {\n  const errors = {};\n  const fields = isEmpty(touchedField) ? schema.required : intersection(schema.required, keys(touchedField));\n  map(fields, requiredField => {\n    var _schema$properties$re, _schema$properties$re2;\n    const type = (_schema$properties$re = schema.properties[requiredField]) === null || _schema$properties$re === void 0 ? void 0 : _schema$properties$re.type;\n    const widget = (_schema$properties$re2 = schema.properties[requiredField]) === null || _schema$properties$re2 === void 0 ? void 0 : _schema$properties$re2.widget;\n    let isEmpty = !formData[requiredField] && formData[requiredField] !== 0;\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField] ? formData[requiredField].length === 0 : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        var _formData$requiredFie, _formData$requiredFie2;\n        isEmpty = !(((_formData$requiredFie = formData[requiredField]) === null || _formData$requiredFie === void 0 ? void 0 : (_formData$requiredFie2 = _formData$requiredFie.data) === null || _formData$requiredFie2 === void 0 ? void 0 : _formData$requiredFie2.replace(/(<([^>]+)>)/g, '').length) > 0);\n      }\n    }\n    if (schema.properties[requiredField] && schema.properties[requiredField].type !== 'boolean' && !schema.properties[requiredField].readonly && isEmpty) {\n      errors[requiredField] = [];\n      errors[requiredField].push(formatMessage(messages.required));\n    }\n  });\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nconst validateFieldsPerFieldset = (schema, formData, formatMessage, touchedField) => {\n  const errors = validateRequiredFields(schema, formData, formatMessage, touchedField);\n  function checkFieldErrors(fieldValidationCriteria, field, fieldData) {\n    return fieldValidationCriteria.map(widgetCriterion => {\n      const errorMessage = fieldData === undefined || fieldData === null ? null : widgetCriterion.method({\n        value: fieldData,\n        field,\n        formData,\n        formatMessage\n      });\n      return errorMessage;\n    }).filter(item => !!item);\n  }\n  Object.entries(schema.properties).forEach(([fieldId, field]) => {\n    var _field$widgetOptions, _field$widgetOptions$, _field$widgetOptions2, _field$widgetOptions3;\n    let fieldData = formData[fieldId];\n\n    // Validation per specific validator set (format property)\n    const hasSpecificValidator = ((_field$widgetOptions = field.widgetOptions) === null || _field$widgetOptions === void 0 ? void 0 : (_field$widgetOptions$ = _field$widgetOptions.frontendOptions) === null || _field$widgetOptions$ === void 0 ? void 0 : _field$widgetOptions$.format) || field.format;\n    let specificFieldErrors = [];\n    if (hasSpecificValidator) {\n      const specificValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: {\n          format: hasSpecificValidator\n        }\n      });\n      specificFieldErrors = checkFieldErrors(specificValidationCriteria, field, fieldData);\n    }\n\n    // Validation per field type\n    const fieldType = field.type || 'string'; // defaults to string\n    const fieldTypeValidationCriteria = config.getUtilities({\n      type: 'validator',\n      dependencies: {\n        fieldType\n      }\n    });\n    const fieldErrors = checkFieldErrors(fieldTypeValidationCriteria, field, fieldData);\n\n    // Validation per field widget\n    const widgetName = ((_field$widgetOptions2 = field.widgetOptions) === null || _field$widgetOptions2 === void 0 ? void 0 : (_field$widgetOptions3 = _field$widgetOptions2.frontendOptions) === null || _field$widgetOptions3 === void 0 ? void 0 : _field$widgetOptions3.widget) || field.widget || '';\n    let widgetErrors = [];\n    if (widgetName) {\n      const widgetNameValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: {\n          widget: widgetName\n        }\n      });\n      widgetErrors = checkFieldErrors(widgetNameValidationCriteria, field, fieldData);\n    }\n\n    // Validation per specific behavior and field name (for content types)\n    const behaviorName = field.behavior;\n    let perBehaviorFieldErrors = [];\n    if (behaviorName) {\n      const specificPerBehaviorFieldValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: {\n          behaviorName,\n          fieldName: fieldId\n        }\n      });\n      perBehaviorFieldErrors = checkFieldErrors(specificPerBehaviorFieldValidationCriteria, field, fieldData);\n    }\n\n    // Validation per block type validator (for blocks)\n    const blockType = formData['@type'];\n    let blockTypeFieldErrors = [];\n    if (blockType) {\n      const blockTypeFieldValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: {\n          blockType,\n          fieldName: fieldId\n        }\n      });\n      blockTypeFieldErrors = checkFieldErrors(blockTypeFieldValidationCriteria, field, fieldData);\n    }\n    const mergedErrors = [...specificFieldErrors, ...fieldErrors, ...widgetErrors, ...perBehaviorFieldErrors, ...blockTypeFieldErrors];\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [...(errors[fieldId] || []), ...specificFieldErrors, ...fieldErrors, ...widgetErrors, ...perBehaviorFieldErrors, ...blockTypeFieldErrors];\n    }\n  });\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nconst giveServerErrorsToCorrespondingFields = requestError => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach(errorItem => {\n      errors[errorItem.field] = errors[errorItem.field] ? errors[errorItem.field].push(errorItem.message) : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some(fieldId => errors[fieldId]);\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n  return activeIndex;\n};\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors({\n    errors = {},\n    schema = {\n      properties: {},\n      fieldsets: [],\n      required: []\n    }\n  } = {}) {\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n  static giveServerErrorsToCorrespondingFields(requestError = '') {\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n  static validateFieldsPerFieldset({\n    schema = {\n      properties: {},\n      fieldsets: [],\n      required: []\n    },\n    formData = {},\n    formatMessage = () => {},\n    touchedField = {}\n  } = {}) {\n    return validateFieldsPerFieldset(schema, formData, formatMessage, touchedField);\n  }\n}\nexport default FormValidation;\n\n/**\n * Check if a file upload is within the maximum size limit.\n * @param {File} file\n * @param {Function} intlFunc\n * @returns {Boolean}\n */\nexport const validateFileUploadSize = (file, intlFunc) => {\n  const isValid = !config.settings.maxFileUploadSize || file.size <= config.settings.maxFileUploadSize;\n  if (!isValid) {\n    toast.error(__jsx(Toast, {\n      error: true,\n      title: intlFunc(messages.error),\n      content: intlFunc(messages.fileTooLarge, {\n        limit: `${Math.floor(config.settings.maxFileUploadSize / 1024 / 1024)}MB`\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 7\n      }\n    }));\n  }\n  return isValid;\n};\n\n/**\n * Extract invariant errors given an array of errors.\n * @param {Array} erros\n */\nexport const extractInvariantErrors = erros => {\n  return erros.filter(errorItem => !('field' in errorItem)).map(errorItem => errorItem['message']);\n};","map":{"version":3,"names":["map","keys","intersection","isEmpty","messages","config","toast","Toast","validationMessage","isValid","criterion","valueToCompare","intlFunc","len","tryParseJSON","requestItem","resultObj","JSON","parse","e","replace","validateRequiredFields","schema","formData","formatMessage","touchedField","errors","fields","required","requiredField","_schema$properties$re","_schema$properties$re2","type","properties","widget","length","_formData$requiredFie","_formData$requiredFie2","data","readonly","push","validateFieldsPerFieldset","checkFieldErrors","fieldValidationCriteria","field","fieldData","widgetCriterion","errorMessage","undefined","method","value","filter","item","Object","entries","forEach","fieldId","_field$widgetOptions","_field$widgetOptions$","_field$widgetOptions2","_field$widgetOptions3","hasSpecificValidator","widgetOptions","frontendOptions","format","specificFieldErrors","specificValidationCriteria","getUtilities","dependencies","fieldType","fieldTypeValidationCriteria","fieldErrors","widgetName","widgetErrors","widgetNameValidationCriteria","behaviorName","behavior","perBehaviorFieldErrors","specificPerBehaviorFieldValidationCriteria","fieldName","blockType","blockTypeFieldErrors","blockTypeFieldValidationCriteria","mergedErrors","giveServerErrorsToCorrespondingFields","requestError","errorsList","Array","isArray","errorItem","message","getIndexOfFirstTabWithErrors","activeIndex","fieldsets","some","fieldSet","index","foundfield","FormValidation","showFirstTabWithErrors","validateFileUploadSize","file","settings","maxFileUploadSize","size","error","__jsx","title","content","fileTooLarge","limit","Math","floor","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","extractInvariantErrors","erros"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/FormValidation/FormValidation.jsx"],"sourcesContent":["import map from 'lodash/map';\nimport keys from 'lodash/keys';\nimport intersection from 'lodash/intersection';\nimport isEmpty from 'lodash/isEmpty';\nimport { messages } from '@plone/volto/helpers/MessageLabels/MessageLabels';\nimport config from '@plone/volto/registry';\nimport { toast } from 'react-toastify';\nimport Toast from '@plone/volto/components/manage/Toast/Toast';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} criterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nexport const validationMessage = (\n  isValid,\n  criterion,\n  valueToCompare,\n  intlFunc,\n) =>\n  !isValid\n    ? intlFunc(messages[criterion], {\n        len: valueToCompare,\n      })\n    : null;\n\n/**\n * The string that comes might not be a valid JSON\n * @param {string} requestItem\n */\nexport const tryParseJSON = (requestItem) => {\n  let resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      try {\n        // Treats strings like: `'String \"double quotes\"'`\n        resultObj = JSON.parse(\n          requestItem.replace(/\"/g, '\\\\\"').replace(/'/g, '\"'),\n        );\n      } catch (e) {\n        resultObj = null;\n      }\n    }\n  }\n  return resultObj;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nconst validateRequiredFields = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = {};\n  const fields = isEmpty(touchedField)\n    ? schema.required\n    : intersection(schema.required, keys(touchedField));\n  map(fields, (requiredField) => {\n    const type = schema.properties[requiredField]?.type;\n    const widget = schema.properties[requiredField]?.widget;\n\n    let isEmpty = !formData[requiredField] && formData[requiredField] !== 0;\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField]\n          ? formData[requiredField].length === 0\n          : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        isEmpty = !(\n          formData[requiredField]?.data?.replace(/(<([^>]+)>)/g, '').length > 0\n        );\n      }\n    }\n    if (\n      schema.properties[requiredField] &&\n      schema.properties[requiredField].type !== 'boolean' &&\n      !schema.properties[requiredField].readonly &&\n      isEmpty\n    ) {\n      errors[requiredField] = [];\n      errors[requiredField].push(formatMessage(messages.required));\n    }\n  });\n\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nconst validateFieldsPerFieldset = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = validateRequiredFields(\n    schema,\n    formData,\n    formatMessage,\n    touchedField,\n  );\n\n  function checkFieldErrors(fieldValidationCriteria, field, fieldData) {\n    return fieldValidationCriteria\n      .map((widgetCriterion) => {\n        const errorMessage =\n          fieldData === undefined || fieldData === null\n            ? null\n            : widgetCriterion.method({\n                value: fieldData,\n                field,\n                formData,\n                formatMessage,\n              });\n        return errorMessage;\n      })\n      .filter((item) => !!item);\n  }\n\n  Object.entries(schema.properties).forEach(([fieldId, field]) => {\n    let fieldData = formData[fieldId];\n\n    // Validation per specific validator set (format property)\n    const hasSpecificValidator =\n      field.widgetOptions?.frontendOptions?.format || field.format;\n    let specificFieldErrors = [];\n    if (hasSpecificValidator) {\n      const specificValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: { format: hasSpecificValidator },\n      });\n\n      specificFieldErrors = checkFieldErrors(\n        specificValidationCriteria,\n        field,\n        fieldData,\n      );\n    }\n\n    // Validation per field type\n    const fieldType = field.type || 'string'; // defaults to string\n    const fieldTypeValidationCriteria = config.getUtilities({\n      type: 'validator',\n      dependencies: { fieldType },\n    });\n\n    const fieldErrors = checkFieldErrors(\n      fieldTypeValidationCriteria,\n      field,\n      fieldData,\n    );\n\n    // Validation per field widget\n    const widgetName =\n      field.widgetOptions?.frontendOptions?.widget || field.widget || '';\n\n    let widgetErrors = [];\n    if (widgetName) {\n      const widgetNameValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: { widget: widgetName },\n      });\n\n      widgetErrors = checkFieldErrors(\n        widgetNameValidationCriteria,\n        field,\n        fieldData,\n      );\n    }\n\n    // Validation per specific behavior and field name (for content types)\n    const behaviorName = field.behavior;\n    let perBehaviorFieldErrors = [];\n    if (behaviorName) {\n      const specificPerBehaviorFieldValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: { behaviorName, fieldName: fieldId },\n      });\n\n      perBehaviorFieldErrors = checkFieldErrors(\n        specificPerBehaviorFieldValidationCriteria,\n        field,\n        fieldData,\n      );\n    }\n\n    // Validation per block type validator (for blocks)\n    const blockType = formData['@type'];\n    let blockTypeFieldErrors = [];\n    if (blockType) {\n      const blockTypeFieldValidationCriteria = config.getUtilities({\n        type: 'validator',\n        dependencies: { blockType, fieldName: fieldId },\n      });\n\n      blockTypeFieldErrors = checkFieldErrors(\n        blockTypeFieldValidationCriteria,\n        field,\n        fieldData,\n      );\n    }\n\n    const mergedErrors = [\n      ...specificFieldErrors,\n      ...fieldErrors,\n      ...widgetErrors,\n      ...perBehaviorFieldErrors,\n      ...blockTypeFieldErrors,\n    ];\n\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [\n        ...(errors[fieldId] || []),\n        ...specificFieldErrors,\n        ...fieldErrors,\n        ...widgetErrors,\n        ...perBehaviorFieldErrors,\n        ...blockTypeFieldErrors,\n      ];\n    }\n  });\n\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nconst giveServerErrorsToCorrespondingFields = (requestError) => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach((errorItem) => {\n      errors[errorItem.field] = errors[errorItem.field]\n        ? errors[errorItem.field].push(errorItem.message)\n        : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some((fieldId) => errors[fieldId]);\n\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n\n  return activeIndex;\n};\n\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors({\n    errors = {},\n    schema = { properties: {}, fieldsets: [], required: [] },\n  } = {}) {\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n  static giveServerErrorsToCorrespondingFields(requestError = '') {\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n  static validateFieldsPerFieldset({\n    schema = { properties: {}, fieldsets: [], required: [] },\n    formData = {},\n    formatMessage = () => {},\n    touchedField = {},\n  } = {}) {\n    return validateFieldsPerFieldset(\n      schema,\n      formData,\n      formatMessage,\n      touchedField,\n    );\n  }\n}\n\nexport default FormValidation;\n\n/**\n * Check if a file upload is within the maximum size limit.\n * @param {File} file\n * @param {Function} intlFunc\n * @returns {Boolean}\n */\nexport const validateFileUploadSize = (file, intlFunc) => {\n  const isValid =\n    !config.settings.maxFileUploadSize ||\n    file.size <= config.settings.maxFileUploadSize;\n  if (!isValid) {\n    toast.error(\n      <Toast\n        error\n        title={intlFunc(messages.error)}\n        content={intlFunc(messages.fileTooLarge, {\n          limit: `${Math.floor(\n            config.settings.maxFileUploadSize / 1024 / 1024,\n          )}MB`,\n        })}\n      />,\n    );\n  }\n  return isValid;\n};\n\n/**\n * Extract invariant errors given an array of errors.\n * @param {Array} erros\n */\nexport const extractInvariantErrors = (erros) => {\n  return erros\n    .filter((errorItem) => !('field' in errorItem))\n    .map((errorItem) => errorItem['message']);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}