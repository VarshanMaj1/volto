{"ast":null,"code":"const _excluded = [\"location\", \"routes\", \"filter\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport { matchRoutes } from 'react-router-config';\nimport { mapSeries, isPromise } from './utils';\nimport { endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\nexport function filterComponents(branch) {\n  return branch.reduce((result, {\n    route,\n    match\n  }) => {\n    if (route.component && route.component.reduxAsyncConnect) {\n      result.push([route.component, {\n        route,\n        match\n      }]);\n    }\n    return result;\n  }, []);\n}\nexport function loadAsyncConnect(_ref) {\n  let {\n      location,\n      routes = [],\n      filter = () => true\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  const layered = filterComponents(matchRoutes(routes, location.pathname));\n  if (layered.length === 0) {\n    return Promise.resolve();\n  }\n\n  // this allows us to have nested promises, that rely on each other's completion\n  // cycle\n  return mapSeries(layered, ([component, routeParams]) => {\n    if (component == null) {\n      return Promise.resolve();\n    }\n\n    // Collect the results of each component\n    const results = [];\n    const asyncItems = component.reduxAsyncConnect;\n    const asyncItemsArr = [...component.reduxAsyncConnect];\n\n    // get array of results\n    asyncItems.forEach(item => {\n      if (filter(item, component)) {\n        // handle Volto's voltoLoadAsyncProps\n        if (item.key === 'voltoLoadAsyncProps') {\n          results.push(item);\n          const asyncPropsItems = item.promise(_objectSpread(_objectSpread(_objectSpread({}, rest), routeParams), {}, {\n            location,\n            routes\n          }));\n          asyncItemsArr.push(...asyncPropsItems);\n          asyncPropsItems.forEach(asyncPropItem => {\n            let innerPromiseOrResult = asyncPropItem && asyncPropItem.promise || asyncPropItem;\n            if (isPromise(innerPromiseOrResult)) {\n              innerPromiseOrResult = innerPromiseOrResult.catch(error => ({\n                error\n              }));\n            }\n            results.push(innerPromiseOrResult);\n          });\n          return;\n        }\n\n        // handles default case of classic asyncConnect\n        let promiseOrResult = item.promise(_objectSpread(_objectSpread(_objectSpread({}, rest), routeParams), {}, {\n          location,\n          routes\n        }));\n        if (isPromise(promiseOrResult)) {\n          promiseOrResult = promiseOrResult.catch(error => ({\n            error\n          }));\n        }\n        results.push(promiseOrResult);\n      }\n    });\n\n    // map results to keys for prop injection\n    const resolver = finalResults => {\n      return Object.assign({}, finalResults.map((result, idx) => {\n        const {\n          key\n        } = asyncItemsArr[idx];\n        return key ? {\n          [key]: result\n        } : null;\n      }));\n    };\n    return Promise.all(results).then(resolver);\n  });\n}\nexport function loadOnServer(args) {\n  return loadAsyncConnect(args).then(() => {\n    args.store.dispatch(endGlobalLoad());\n  });\n}","map":{"version":3,"names":["matchRoutes","mapSeries","isPromise","endGlobalLoad","filterComponents","branch","reduce","result","route","match","component","reduxAsyncConnect","push","loadAsyncConnect","_ref","location","routes","filter","rest","_objectWithoutProperties","_excluded","layered","pathname","length","Promise","resolve","routeParams","results","asyncItems","asyncItemsArr","forEach","item","key","asyncPropsItems","promise","_objectSpread","asyncPropItem","innerPromiseOrResult","catch","error","promiseOrResult","resolver","finalResults","Object","assign","map","idx","all","then","loadOnServer","args","store","dispatch"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/AsyncConnect/ssr.js"],"sourcesContent":["import { matchRoutes } from 'react-router-config';\nimport { mapSeries, isPromise } from './utils';\nimport { endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\n\nexport function filterComponents(branch) {\n  return branch.reduce((result, { route, match }) => {\n    if (route.component && route.component.reduxAsyncConnect) {\n      result.push([route.component, { route, match }]);\n    }\n\n    return result;\n  }, []);\n}\n\nexport function loadAsyncConnect({\n  location,\n  routes = [],\n  filter = () => true,\n  ...rest\n}) {\n  const layered = filterComponents(matchRoutes(routes, location.pathname));\n\n  if (layered.length === 0) {\n    return Promise.resolve();\n  }\n\n  // this allows us to have nested promises, that rely on each other's completion\n  // cycle\n  return mapSeries(layered, ([component, routeParams]) => {\n    if (component == null) {\n      return Promise.resolve();\n    }\n\n    // Collect the results of each component\n    const results = [];\n    const asyncItems = component.reduxAsyncConnect;\n    const asyncItemsArr = [...component.reduxAsyncConnect];\n\n    // get array of results\n    asyncItems.forEach((item) => {\n      if (filter(item, component)) {\n        // handle Volto's voltoLoadAsyncProps\n        if (item.key === 'voltoLoadAsyncProps') {\n          results.push(item);\n          const asyncPropsItems = item.promise({\n            ...rest,\n            ...routeParams,\n            location,\n            routes,\n          });\n          asyncItemsArr.push(...asyncPropsItems);\n\n          asyncPropsItems.forEach((asyncPropItem) => {\n            let innerPromiseOrResult =\n              (asyncPropItem && asyncPropItem.promise) || asyncPropItem;\n\n            if (isPromise(innerPromiseOrResult)) {\n              innerPromiseOrResult = innerPromiseOrResult.catch((error) => ({\n                error,\n              }));\n            }\n            results.push(innerPromiseOrResult);\n          });\n          return;\n        }\n\n        // handles default case of classic asyncConnect\n        let promiseOrResult = item.promise({\n          ...rest,\n          ...routeParams,\n          location,\n          routes,\n        });\n\n        if (isPromise(promiseOrResult)) {\n          promiseOrResult = promiseOrResult.catch((error) => ({ error }));\n        }\n\n        results.push(promiseOrResult);\n      }\n    });\n\n    // map results to keys for prop injection\n    const resolver = (finalResults) => {\n      return Object.assign(\n        {},\n        finalResults.map((result, idx) => {\n          const { key } = asyncItemsArr[idx];\n          return key ? { [key]: result } : null;\n        }),\n      );\n    };\n\n    return Promise.all(results).then(resolver);\n  });\n}\n\nexport function loadOnServer(args) {\n  return loadAsyncConnect(args).then(() => {\n    args.store.dispatch(endGlobalLoad());\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}