{"ast":null,"code":"import _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport { addBlock, changeBlock, insertBlock, blockHasValue, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers/Blocks/Blocks';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport omit from 'lodash/omit';\nimport config from '@plone/volto/registry';\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach(p => {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  const prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, {\n    edge: 'start'\n  });\n  let rangeRef;\n  let end;\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, [])\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1])\n    });\n    const source = rangeRef.current;\n    end = Editor.end(editor, [0]);\n    let endPoint;\n    Transforms.insertNodes(editor, {\n      text: ''\n    }, {\n      at: end\n    });\n    end = Editor.end(editor, [0]);\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: n => n.type === 'li' || Text.isText(n)\n    });\n    endPoint = Editor.end(editor, [0]);\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2\n    });\n  });\n  const [n] = Editor.node(editor, [1]);\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, {\n      at: [1]\n    });\n  }\n  rangeRef.unref();\n  const [, lastPath] = Editor.last(editor, [0]);\n  end = Editor.start(editor, Path.parent(lastPath));\n  return end;\n}\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  const next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, [])\n  });\n  Editor.deleteForward(editor, {\n    unit: 'character'\n  });\n}\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value)\n  };\n  return [id, block];\n}\nexport function createImageBlock(url, index, props, intl) {\n  const {\n    properties,\n    onChangeField,\n    onSelectBlock\n  } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const currBlockId = properties.blocks_layout.items[index];\n  const currBlockHasValue = blockHasValue(properties.blocks[currBlockId]);\n  let id, newFormData;\n  if (currBlockHasValue) {\n    [id, newFormData] = addBlock(properties, 'image', index + 1, {}, intl);\n    newFormData = changeBlock(newFormData, id, {\n      '@type': 'image',\n      url\n    });\n  } else {\n    [id, newFormData] = insertBlock(properties, currBlockId, {\n      '@type': 'image',\n      url\n    });\n  }\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\nexport const createAndSelectNewBlockAfter = (editor, blockValue, intl) => {\n  const blockProps = editor.getBlockProps();\n  const {\n    onSelectBlock,\n    properties,\n    index,\n    onChangeField\n  } = blockProps;\n  const [blockId, formData] = addBlock(properties, 'slate', index + 1, {}, intl);\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue)\n  };\n  const newFormData = changeBlock(formData, blockId, options);\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const blocks_layout = properties[blocksLayoutFieldname];\n  if (index === blocks_layout.items.length) return;\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n  return [nextBlock, nextBlockId];\n}\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    slate\n  } = config.settings;\n  const {\n    voltoBlockEmiters\n  } = slate;\n  return new Promise((resolve, reject) => {\n    if (!(editor !== null && editor !== void 0 && editor.children)) return;\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    const {\n      properties,\n      onChangeField,\n      onSelectBlock\n    } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n    const {\n      index\n    } = blockProps;\n    let blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    const pathRefs = Array.from(Node.children(editor, [])).map(([, path]) => Editor.pathRef(editor, path));\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters.map(emit => emit(editor, pathRef)).flat(1);\n\n      // The node might have been replaced with a Volto block\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode)) blocks.push(syncCreateSlateBlock([childNode]));\n      }\n      blocks = [...blocks, ...extras];\n    }\n    const blockids = blocks.map(b => b[0]);\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = omit(_objectSpread(_objectSpread({}, properties[blocksFieldname]), fromEntries(blocks)), blockProps.block);\n    const layoutData = _objectSpread(_objectSpread({}, properties[blocksLayoutFieldname]), {}, {\n      items: [...properties[blocksLayoutFieldname].items.slice(0, index), ...blockids, ...properties[blocksLayoutFieldname].items.slice(index)].filter(id => id !== blockProps.block)\n    });\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}","map":{"version":3,"names":["ReactDOM","v4","uuid","addBlock","changeBlock","insertBlock","blockHasValue","getBlocksFieldname","getBlocksLayoutFieldname","Transforms","Editor","Node","Text","Path","serializeNodesToText","omit","config","fromEntries","pairs","res","forEach","p","mergeSlateWithBlockBackward","editor","prevBlock","event","prev","value","collapse","edge","rangeRef","end","withoutNormalizing","insertNodes","at","start","anchor","focus","source","current","endPoint","text","splitNodes","always","height","mode","match","n","type","isText","moveNodes","to","path","length","node","isEmpty","removeNodes","unref","lastPath","last","parent","mergeSlateWithBlockForward","nextBlock","next","deleteForward","unit","syncCreateSlateBlock","id","block","JSON","parse","stringify","plaintext","createImageBlock","url","index","props","intl","properties","onChangeField","onSelectBlock","blocksFieldname","blocksLayoutFieldname","currBlockId","blocks_layout","items","currBlockHasValue","blocks","newFormData","unstable_batchedUpdates","createAndSelectNewBlockAfter","blockValue","blockProps","getBlockProps","blockId","formData","options","saveSlateBlockSelection","getNextVoltoBlock","nextBlockId","getPreviousVoltoBlock","prevBlockId","deconstructToVoltoBlocks","slate","settings","voltoBlockEmiters","Promise","resolve","reject","children","pathRefs","Array","from","map","pathRef","extras","emit","flat","childNode","push","blockids","b","blocksData","_objectSpread","layoutData","slice","filter","then"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/utils/volto-blocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport {\n  addBlock,\n  changeBlock,\n  insertBlock,\n  blockHasValue,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers/Blocks/Blocks';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport omit from 'lodash/omit';\nimport config from '@plone/volto/registry';\n\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach((p) => {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  const prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'start' });\n\n  let rangeRef;\n  let end;\n\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, []),\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1]),\n    });\n\n    const source = rangeRef.current;\n\n    end = Editor.end(editor, [0]);\n\n    let endPoint;\n\n    Transforms.insertNodes(editor, { text: '' }, { at: end });\n\n    end = Editor.end(editor, [0]);\n\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: (n) => n.type === 'li' || Text.isText(n),\n    });\n\n    endPoint = Editor.end(editor, [0]);\n\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2,\n    });\n  });\n\n  const [n] = Editor.node(editor, [1]);\n\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, { at: [1] });\n  }\n\n  rangeRef.unref();\n\n  const [, lastPath] = Editor.last(editor, [0]);\n\n  end = Editor.start(editor, Path.parent(lastPath));\n\n  return end;\n}\n\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  const next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'end' });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, []),\n  });\n\n  Editor.deleteForward(editor, { unit: 'character' });\n}\n\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value),\n  };\n  return [id, block];\n}\n\nexport function createImageBlock(url, index, props, intl) {\n  const { properties, onChangeField, onSelectBlock } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const currBlockId = properties.blocks_layout.items[index];\n  const currBlockHasValue = blockHasValue(properties.blocks[currBlockId]);\n  let id, newFormData;\n\n  if (currBlockHasValue) {\n    [id, newFormData] = addBlock(properties, 'image', index + 1, {}, intl);\n    newFormData = changeBlock(newFormData, id, { '@type': 'image', url });\n  } else {\n    [id, newFormData] = insertBlock(properties, currBlockId, {\n      '@type': 'image',\n      url,\n    });\n  }\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\n\nexport const createAndSelectNewBlockAfter = (editor, blockValue, intl) => {\n  const blockProps = editor.getBlockProps();\n\n  const { onSelectBlock, properties, index, onChangeField } = blockProps;\n\n  const [blockId, formData] = addBlock(\n    properties,\n    'slate',\n    index + 1,\n    {},\n    intl,\n  );\n\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue),\n  };\n\n  const newFormData = changeBlock(formData, blockId, options);\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\n\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n\n  if (index === blocks_layout.items.length) return;\n\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n\n  return [nextBlock, nextBlockId];\n}\n\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n\n  const blockProps = editor.getBlockProps();\n  const { slate } = config.settings;\n  const { voltoBlockEmiters } = slate;\n\n  return new Promise((resolve, reject) => {\n    if (!editor?.children) return;\n\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    const { properties, onChangeField, onSelectBlock } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n    const { index } = blockProps;\n    let blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    const pathRefs = Array.from(Node.children(editor, [])).map(([, path]) =>\n      Editor.pathRef(editor, path),\n    );\n\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters\n        .map((emit) => emit(editor, pathRef))\n        .flat(1);\n\n      // The node might have been replaced with a Volto block\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode))\n          blocks.push(syncCreateSlateBlock([childNode]));\n      }\n      blocks = [...blocks, ...extras];\n    }\n\n    const blockids = blocks.map((b) => b[0]);\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = omit(\n      {\n        ...properties[blocksFieldname],\n        ...fromEntries(blocks),\n      },\n      blockProps.block,\n    );\n    const layoutData = {\n      ...properties[blocksLayoutFieldname],\n      items: [\n        ...properties[blocksLayoutFieldname].items.slice(0, index),\n        ...blockids,\n        ...properties[blocksLayoutFieldname].items.slice(index),\n      ].filter((id) => id !== blockProps.block),\n    };\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}