{"ast":null,"code":"var _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/SlateEditor.jsx\",\n  _window;\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport isEqual from 'lodash/isEqual';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { Element, Leaf } from './render';\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport { makeEditor } from '@plone/volto-slate/utils/editor';\nimport { toggleInlineFormat } from '@plone/volto-slate/utils/blocks';\nimport { toggleMark } from '@plone/volto-slate/utils/marks';\nimport { parseDefaultSelection } from '@plone/volto-slate/utils/selection';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\nimport isHotkey from 'is-hotkey';\nimport './less/editor.less';\nimport Toolbar from './ui/Toolbar';\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, {\n      format,\n      type\n    }] = hk;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n      wasHotkey = true;\n    }\n  }\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n    this.savedSelection = null;\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: config.settings.slate.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid\n    };\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({\n      extensions: this.props.extensions\n    });\n\n    // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n    return editor;\n  }\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({\n        internalValue: value\n      });\n      if (this.props.onChange && !isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n  multiDecorator([node, path]) {\n    // Decorations (such as higlighting node types, selection, etc).\n    const {\n      runtimeDecorators = []\n    } = this.slateSettings;\n    return runtimeDecorators.reduce((acc, deco) => deco(this.state.editor, [node, path], acc), []);\n  }\n  componentDidMount() {\n    // watch the dom change\n\n    if (this.props.selected) {\n      let focused = true;\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n      this.state.editor.normalize({\n        force: true\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({\n        editor: this.createEditor()\n      });\n      return;\n    }\n    if (this.props.value && !isEqual(this.props.value, this.state.internalValue)) {\n      const {\n        editor\n      } = this.state;\n      editor.children = this.props.value;\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(editor, this.props.defaultSelection);\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      } else {\n        try {\n          Transforms.select(editor, Editor.end(editor, []));\n        } catch (error) {\n          // Weird error only happening in Cypress\n          // Adding a try/catch\n          // eslint-disable-next-line no-console\n          console.log(error);\n        }\n      }\n      this.setState({\n        internalValue: this.props.value\n      });\n      return;\n    }\n    const {\n      editor\n    } = this.state;\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(this.state.editor, Editor.range(this.state.editor, Editor.start(this.state.editor, [])));\n      }\n      ReactEditor.focus(this.state.editor);\n    }\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    const {\n      selected = true,\n      value,\n      readOnly\n    } = nextProps;\n    const res = selected || this.props.selected !== selected || this.props.readOnly !== readOnly || !isEqual(value, this.props.value);\n    return res;\n  }\n  render() {\n    var _this$props$value;\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = [],\n      editableProps = {}\n    } = this.props;\n    const slateSettings = this.slateSettings;\n\n    // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n    const editor = renderExtensions.reduce((acc, apply) => apply(acc), this.state.editor);\n\n    // Reset selection if field is reset\n    if (editor.selection && ((_this$props$value = this.props.value) === null || _this$props$value === void 0 ? void 0 : _this$props$value.length) === 1 && this.props.value[0].children.length === 1 && this.props.value[0].children[0].text === '') {\n      Transforms.select(editor, {\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        }\n      });\n    }\n    this.editor = editor;\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    }\n\n    // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n    return __jsx(\"div\", _extends({}, this.props['debug-values'], {\n      className: cx('slate-editor', {\n        'show-toolbar': this.state.showExpandedToolbar,\n        selected\n      }),\n      tabIndex: -1,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 256,\n        columnNumber: 7\n      }\n    }), __jsx(EditorContext.Provider, {\n      value: editor,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264,\n        columnNumber: 9\n      }\n    }, __jsx(Slate, {\n      editor: editor,\n      initialValue: this.props.value || slateSettings.defaultValue(),\n      onChange: this.handleChange,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265,\n        columnNumber: 11\n      }\n    }, selected ? __jsx(React.Fragment, null, __jsx(InlineToolbar, {\n      editor: editor,\n      className: className,\n      slateSettings: this.props.slateSettings,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 17\n      }\n    }), Object.keys(slateSettings.elementToolbarButtons).map((t, i) => {\n      return __jsx(Toolbar, {\n        elementType: t,\n        key: i,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 280,\n          columnNumber: 23\n        }\n      }, slateSettings.elementToolbarButtons[t].map((Btn, b) => {\n        return __jsx(Btn, {\n          editor: editor,\n          key: b,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 283,\n            columnNumber: 36\n          }\n        });\n      }));\n    })) : '', __jsx(Editable, _extends({\n      tabIndex: this.props.tabIndex || 0,\n      readOnly: readOnly,\n      placeholder: placeholder,\n      renderElement: props => __jsx(Element, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 298,\n          columnNumber: 41\n        }\n      })),\n      renderLeaf: props => __jsx(Leaf, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 299,\n          columnNumber: 38\n        }\n      })),\n      decorate: this.multiDecorator,\n      spellCheck: false,\n      scrollSelectionIntoView: slateSettings.scrollIntoView ? undefined : () => null,\n      onBlur: () => {\n        this.props.onBlur && this.props.onBlur();\n        return null;\n      },\n      onClick: this.props.onClick,\n      onSelect: e => {\n        if (!selected && this.props.onFocus) {\n          // we can't overwrite the onFocus of Editable, as the onFocus\n          // in Slate has too much builtin behaviour that's not\n          // accessible otherwise. Instead we try to detect such an\n          // event based on observing selected state\n          if (!editor.selection) {\n            setTimeout(() => {\n              this.props.onFocus();\n            }, 100); // TODO: why 100 is chosen here?\n          }\n        }\n        if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n        this.selectionTimeout = setTimeout(() => {\n          if (editor.selection && !isEqual(editor.selection, this.savedSelection) && !this.isUnmounted) {\n            this.setState(state => ({\n              update: !this.state.update\n            }));\n            this.setSavedSelection(JSON.parse(JSON.stringify(editor.selection)));\n          }\n        }, 200);\n      },\n      onKeyDown: event => {\n        const handled = handleHotKeys(editor, event, slateSettings);\n        if (handled) return;\n        onKeyDown && onKeyDown({\n          editor,\n          event\n        });\n      }\n    }, editableProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 294,\n        columnNumber: 13\n      }\n    })), selected && slateSettings.persistentHelpers.map((Helper, i) => {\n      return __jsx(Helper, {\n        key: i,\n        editor: editor,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 346,\n          columnNumber: 24\n        }\n      });\n    }), this.props.debug ? __jsx(\"ul\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 349,\n        columnNumber: 15\n      }\n    }, __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 350,\n        columnNumber: 17\n      }\n    }, selected ? 'selected' : 'no-selected'), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 17\n      }\n    }, \"savedSelection: \", JSON.stringify(editor.getSavedSelection())), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 354,\n        columnNumber: 17\n      }\n    }, \"live selection: \", JSON.stringify(editor.selection)), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 355,\n        columnNumber: 17\n      }\n    }, \"children: \", JSON.stringify(editor.children)), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 356,\n        columnNumber: 17\n      }\n    }, \" \", selected ? 'selected' : 'notselected'), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 357,\n        columnNumber: 17\n      }\n    }, ReactEditor.isFocused(editor) ? 'focused' : 'unfocused')) : '', this.props.children)));\n  }\n}\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: ''\n};\n\n// May be needed to wrap in React.memo(), it used to be wrapped in connect()\nexport default __CLIENT__ && (_window = window) !== null && _window !== void 0 && _window.Cypress ? withTestingFeatures(SlateEditor) : SlateEditor;","map":{"version":3,"names":["ReactDOM","cx","isEqual","Transforms","Editor","Slate","Editable","ReactEditor","React","Component","v4","uuid","config","Element","Leaf","withTestingFeatures","makeEditor","toggleInlineFormat","toggleMark","parseDefaultSelection","InlineToolbar","EditorContext","isHotkey","Toolbar","handleHotKeys","editor","event","wasHotkey","hk","Object","entries","hotkeys","shortcut","format","type","preventDefault","SlateEditor","constructor","props","createEditor","bind","multiDecorator","handleChange","getSavedSelection","setSavedSelection","savedSelection","uid","slateSettings","settings","slate","state","showExpandedToolbar","internalValue","value","defaultValue","selectionTimeout","selection","extensions","unstable_batchedUpdates","setState","onChange","node","path","runtimeDecorators","reduce","acc","deco","componentDidMount","selected","focused","isFocused","setTimeout","focus","normalize","force","componentWillUnmount","isUnmounted","componentDidUpdate","prevProps","children","defaultSelection","select","end","error","console","log","window","getSelection","range","start","onUpdate","shouldComponentUpdate","nextProps","nextState","readOnly","res","render","_this$props$value","placeholder","onKeyDown","testingEditorRef","className","renderExtensions","editableProps","apply","length","text","anchor","offset","current","__jsx","_extends","tabIndex","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","Provider","initialValue","Fragment","keys","elementToolbarButtons","map","t","i","elementType","key","Btn","b","renderElement","renderLeaf","decorate","spellCheck","scrollSelectionIntoView","scrollIntoView","undefined","onBlur","onClick","onSelect","e","onFocus","clearTimeout","update","JSON","parse","stringify","handled","persistentHelpers","Helper","debug","defaultProps","__CLIENT__","_window","Cypress"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/SlateEditor.jsx"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport isEqual from 'lodash/isEqual';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { v4 as uuid } from 'uuid';\n\nimport config from '@plone/volto/registry';\n\nimport { Element, Leaf } from './render';\n\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport { makeEditor } from '@plone/volto-slate/utils/editor';\nimport { toggleInlineFormat } from '@plone/volto-slate/utils/blocks';\nimport { toggleMark } from '@plone/volto-slate/utils/marks';\nimport { parseDefaultSelection } from '@plone/volto-slate/utils/selection';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\n\nimport isHotkey from 'is-hotkey';\n\nimport './less/editor.less';\n\nimport Toolbar from './ui/Toolbar';\n\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, { format, type }] = hk;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n\n      wasHotkey = true;\n    }\n  }\n\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n\n    this.savedSelection = null;\n\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: config.settings.slate.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid,\n    };\n\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({ extensions: this.props.extensions });\n\n    // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n\n    return editor;\n  }\n\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({ internalValue: value });\n      if (this.props.onChange && !isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n\n  multiDecorator([node, path]) {\n    // Decorations (such as higlighting node types, selection, etc).\n    const { runtimeDecorators = [] } = this.slateSettings;\n    return runtimeDecorators.reduce(\n      (acc, deco) => deco(this.state.editor, [node, path], acc),\n      [],\n    );\n  }\n\n  componentDidMount() {\n    // watch the dom change\n\n    if (this.props.selected) {\n      let focused = true;\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n\n      this.state.editor.normalize({ force: true });\n    }\n  }\n\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({ editor: this.createEditor() });\n      return;\n    }\n\n    if (\n      this.props.value &&\n      !isEqual(this.props.value, this.state.internalValue)\n    ) {\n      const { editor } = this.state;\n      editor.children = this.props.value;\n\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(\n          editor,\n          this.props.defaultSelection,\n        );\n\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      } else {\n        try {\n          Transforms.select(editor, Editor.end(editor, []));\n        } catch (error) {\n          // Weird error only happening in Cypress\n          // Adding a try/catch\n          // eslint-disable-next-line no-console\n          console.log(error);\n        }\n      }\n\n      this.setState({\n        internalValue: this.props.value,\n      });\n      return;\n    }\n\n    const { editor } = this.state;\n\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(\n          this.state.editor,\n          Editor.range(this.state.editor, Editor.start(this.state.editor, [])),\n        );\n      }\n\n      ReactEditor.focus(this.state.editor);\n    }\n\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { selected = true, value, readOnly } = nextProps;\n    const res =\n      selected ||\n      this.props.selected !== selected ||\n      this.props.readOnly !== readOnly ||\n      !isEqual(value, this.props.value);\n    return res;\n  }\n\n  render() {\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = [],\n      editableProps = {},\n    } = this.props;\n    const slateSettings = this.slateSettings;\n\n    // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n    const editor = renderExtensions.reduce(\n      (acc, apply) => apply(acc),\n      this.state.editor,\n    );\n\n    // Reset selection if field is reset\n    if (\n      editor.selection &&\n      this.props.value?.length === 1 &&\n      this.props.value[0].children.length === 1 &&\n      this.props.value[0].children[0].text === ''\n    ) {\n      Transforms.select(editor, {\n        anchor: { path: [0, 0], offset: 0 },\n        focus: { path: [0, 0], offset: 0 },\n      });\n    }\n    this.editor = editor;\n\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    }\n\n    // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n    return (\n      <div\n        {...this.props['debug-values']}\n        className={cx('slate-editor', {\n          'show-toolbar': this.state.showExpandedToolbar,\n          selected,\n        })}\n        tabIndex={-1}\n      >\n        <EditorContext.Provider value={editor}>\n          <Slate\n            editor={editor}\n            initialValue={this.props.value || slateSettings.defaultValue()}\n            onChange={this.handleChange}\n          >\n            {selected ? (\n              <>\n                <InlineToolbar\n                  editor={editor}\n                  className={className}\n                  slateSettings={this.props.slateSettings}\n                />\n                {Object.keys(slateSettings.elementToolbarButtons).map(\n                  (t, i) => {\n                    return (\n                      <Toolbar elementType={t} key={i}>\n                        {slateSettings.elementToolbarButtons[t].map(\n                          (Btn, b) => {\n                            return <Btn editor={editor} key={b} />;\n                          },\n                        )}\n                      </Toolbar>\n                    );\n                  },\n                )}\n              </>\n            ) : (\n              ''\n            )}\n            <Editable\n              tabIndex={this.props.tabIndex || 0}\n              readOnly={readOnly}\n              placeholder={placeholder}\n              renderElement={(props) => <Element {...props} />}\n              renderLeaf={(props) => <Leaf {...props} />}\n              decorate={this.multiDecorator}\n              spellCheck={false}\n              scrollSelectionIntoView={\n                slateSettings.scrollIntoView ? undefined : () => null\n              }\n              onBlur={() => {\n                this.props.onBlur && this.props.onBlur();\n                return null;\n              }}\n              onClick={this.props.onClick}\n              onSelect={(e) => {\n                if (!selected && this.props.onFocus) {\n                  // we can't overwrite the onFocus of Editable, as the onFocus\n                  // in Slate has too much builtin behaviour that's not\n                  // accessible otherwise. Instead we try to detect such an\n                  // event based on observing selected state\n                  if (!editor.selection) {\n                    setTimeout(() => {\n                      this.props.onFocus();\n                    }, 100); // TODO: why 100 is chosen here?\n                  }\n                }\n\n                if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n                this.selectionTimeout = setTimeout(() => {\n                  if (\n                    editor.selection &&\n                    !isEqual(editor.selection, this.savedSelection) &&\n                    !this.isUnmounted\n                  ) {\n                    this.setState((state) => ({ update: !this.state.update }));\n                    this.setSavedSelection(\n                      JSON.parse(JSON.stringify(editor.selection)),\n                    );\n                  }\n                }, 200);\n              }}\n              onKeyDown={(event) => {\n                const handled = handleHotKeys(editor, event, slateSettings);\n                if (handled) return;\n                onKeyDown && onKeyDown({ editor, event });\n              }}\n              {...editableProps}\n            />\n            {selected &&\n              slateSettings.persistentHelpers.map((Helper, i) => {\n                return <Helper key={i} editor={editor} />;\n              })}\n            {this.props.debug ? (\n              <ul>\n                <li>{selected ? 'selected' : 'no-selected'}</li>\n                <li>\n                  savedSelection: {JSON.stringify(editor.getSavedSelection())}\n                </li>\n                <li>live selection: {JSON.stringify(editor.selection)}</li>\n                <li>children: {JSON.stringify(editor.children)}</li>\n                <li> {selected ? 'selected' : 'notselected'}</li>\n                <li>\n                  {ReactEditor.isFocused(editor) ? 'focused' : 'unfocused'}\n                </li>\n              </ul>\n            ) : (\n              ''\n            )}\n            {this.props.children}\n          </Slate>\n        </EditorContext.Provider>\n      </div>\n    );\n  }\n}\n\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: '',\n};\n\n// May be needed to wrap in React.memo(), it used to be wrapped in connect()\nexport default __CLIENT__ && window?.Cypress\n  ? withTestingFeatures(SlateEditor)\n  : SlateEditor;\n"],"mappings":";;;;AAAA,OAAOA,QAAQ,MAAM,WAAW;AAChC,OAAOC,EAAE,MAAM,YAAY;AAC3B,OAAOC,OAAO,MAAM,gBAAgB;AACpC,SAASC,UAAU,EAAEC,MAAM,QAAQ,OAAO,CAAC,CAAC;AAC5C,SAASC,KAAK,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,aAAa;AAC1D,OAAOC,KAAK,IAAIC,SAAS,QAAQ,OAAO,CAAC,CAAC;AAC1C,SAASC,EAAE,IAAIC,IAAI,QAAQ,MAAM;AAEjC,OAAOC,MAAM,MAAM,uBAAuB;AAE1C,SAASC,OAAO,EAAEC,IAAI,QAAQ,UAAU;AAExC,OAAOC,mBAAmB,MAAM,kCAAkC;AAClE,SAASC,UAAU,QAAQ,iCAAiC;AAC5D,SAASC,kBAAkB,QAAQ,iCAAiC;AACpE,SAASC,UAAU,QAAQ,gCAAgC;AAC3D,SAASC,qBAAqB,QAAQ,oCAAoC;AAC1E,SAASC,aAAa,QAAQ,MAAM;AACpC,OAAOC,aAAa,MAAM,iBAAiB;AAE3C,OAAOC,QAAQ,MAAM,WAAW;AAEhC,OAAO,oBAAoB;AAE3B,OAAOC,OAAO,MAAM,cAAc;AAElC,MAAMC,aAAa,GAAGA,CAACC,MAAM,EAAEC,KAAK,EAAEd,MAAM,KAAK;EAC/C,IAAIe,SAAS,GAAG,KAAK;EAErB,KAAK,MAAMC,EAAE,IAAIC,MAAM,CAACC,OAAO,CAAClB,MAAM,CAACmB,OAAO,CAAC,EAAE;IAC/C,MAAM,CAACC,QAAQ,EAAE;MAAEC,MAAM;MAAEC;IAAK,CAAC,CAAC,GAAGN,EAAE;IACvC,IAAIN,QAAQ,CAACU,QAAQ,EAAEN,KAAK,CAAC,EAAE;MAC7BA,KAAK,CAACS,cAAc,CAAC,CAAC;MAEtB,IAAID,IAAI,KAAK,QAAQ,EAAE;QACrBjB,kBAAkB,CAACQ,MAAM,EAAEQ,MAAM,CAAC;MACpC,CAAC,MAAM;QACL;QACAf,UAAU,CAACO,MAAM,EAAEQ,MAAM,CAAC;MAC5B;MAEAN,SAAS,GAAG,IAAI;IAClB;EACF;EAEA,OAAOA,SAAS;AAClB,CAAC;;AAED;AACA,MAAMS,WAAW,SAAS3B,SAAS,CAAC;EAClC4B,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;IAEZ,IAAI,CAACC,YAAY,GAAG,IAAI,CAACA,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC;IAChD,IAAI,CAACC,cAAc,GAAG,IAAI,CAACA,cAAc,CAACD,IAAI,CAAC,IAAI,CAAC;IACpD,IAAI,CAACE,YAAY,GAAG,IAAI,CAACA,YAAY,CAACF,IAAI,CAAC,IAAI,CAAC;IAChD,IAAI,CAACG,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACH,IAAI,CAAC,IAAI,CAAC;IAC1D,IAAI,CAACI,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACJ,IAAI,CAAC,IAAI,CAAC;IAE1D,IAAI,CAACK,cAAc,GAAG,IAAI;IAE1B,MAAMC,GAAG,GAAGnC,IAAI,CAAC,CAAC,CAAC,CAAC;;IAEpB,IAAI,CAACoC,aAAa,GAAGT,KAAK,CAACS,aAAa,IAAInC,MAAM,CAACoC,QAAQ,CAACC,KAAK;IAEjE,IAAI,CAACC,KAAK,GAAG;MACXzB,MAAM,EAAE,IAAI,CAACc,YAAY,CAACO,GAAG,CAAC;MAC9BK,mBAAmB,EAAEvC,MAAM,CAACoC,QAAQ,CAACC,KAAK,CAACE,mBAAmB;MAC9DC,aAAa,EAAE,IAAI,CAACd,KAAK,CAACe,KAAK,IAAI,IAAI,CAACN,aAAa,CAACO,YAAY,CAAC,CAAC;MACpER;IACF,CAAC;IAED,IAAI,CAACrB,MAAM,GAAG,IAAI;IAClB,IAAI,CAAC8B,gBAAgB,GAAG,IAAI;EAC9B;EAEAZ,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACE,cAAc;EAC5B;EACAD,iBAAiBA,CAACY,SAAS,EAAE;IAC3B,IAAI,CAACX,cAAc,GAAGW,SAAS;EACjC;EAEAjB,YAAYA,CAACO,GAAG,EAAE;IAChB;IACA;IACA;IACA;IACA,MAAMrB,MAAM,GAAGT,UAAU,CAAC;MAAEyC,UAAU,EAAE,IAAI,CAACnB,KAAK,CAACmB;IAAW,CAAC,CAAC;;IAEhE;IACA;IACA;IACA;;IAEAhC,MAAM,CAACkB,iBAAiB,GAAG,IAAI,CAACA,iBAAiB;IACjDlB,MAAM,CAACmB,iBAAiB,GAAG,IAAI,CAACA,iBAAiB;IACjDnB,MAAM,CAACqB,GAAG,GAAGA,GAAG,IAAI,IAAI,CAACI,KAAK,CAACJ,GAAG;IAElC,OAAOrB,MAAM;EACf;EAEAiB,YAAYA,CAACW,KAAK,EAAE;IAClBrD,QAAQ,CAAC0D,uBAAuB,CAAC,MAAM;MACrC,IAAI,CAACC,QAAQ,CAAC;QAAEP,aAAa,EAAEC;MAAM,CAAC,CAAC;MACvC,IAAI,IAAI,CAACf,KAAK,CAACsB,QAAQ,IAAI,CAAC1D,OAAO,CAACmD,KAAK,EAAE,IAAI,CAACf,KAAK,CAACe,KAAK,CAAC,EAAE;QAC5D,IAAI,CAACf,KAAK,CAACsB,QAAQ,CAACP,KAAK,EAAE,IAAI,CAAC5B,MAAM,CAAC;MACzC;IACF,CAAC,CAAC;EACJ;EAEAgB,cAAcA,CAAC,CAACoB,IAAI,EAAEC,IAAI,CAAC,EAAE;IAC3B;IACA,MAAM;MAAEC,iBAAiB,GAAG;IAAG,CAAC,GAAG,IAAI,CAAChB,aAAa;IACrD,OAAOgB,iBAAiB,CAACC,MAAM,CAC7B,CAACC,GAAG,EAAEC,IAAI,KAAKA,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACzB,MAAM,EAAE,CAACoC,IAAI,EAAEC,IAAI,CAAC,EAAEG,GAAG,CAAC,EACzD,EACF,CAAC;EACH;EAEAE,iBAAiBA,CAAA,EAAG;IAClB;;IAEA,IAAI,IAAI,CAAC7B,KAAK,CAAC8B,QAAQ,EAAE;MACvB,IAAIC,OAAO,GAAG,IAAI;MAClB,IAAI;QACFA,OAAO,GAAG9D,WAAW,CAAC+D,SAAS,CAAC,IAAI,CAACpB,KAAK,CAACzB,MAAM,CAAC;MACpD,CAAC,CAAC,MAAM,CAAC;MACT,IAAI,CAAC4C,OAAO,EAAE;QACZE,UAAU,CAAC,MAAM;UACf,IAAI;YACFhE,WAAW,CAACiE,KAAK,CAAC,IAAI,CAACtB,KAAK,CAACzB,MAAM,CAAC;UACtC,CAAC,CAAC,MAAM,CAAC;QACX,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MACX;MAEA,IAAI,CAACyB,KAAK,CAACzB,MAAM,CAACgD,SAAS,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;IAC9C;EACF;EAEAC,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAACC,WAAW,GAAG,IAAI;EACzB;EAEAC,kBAAkBA,CAACC,SAAS,EAAE;IAC5B,IAAI,CAAC5E,OAAO,CAAC4E,SAAS,CAACrB,UAAU,EAAE,IAAI,CAACnB,KAAK,CAACmB,UAAU,CAAC,EAAE;MACzD,IAAI,CAACE,QAAQ,CAAC;QAAElC,MAAM,EAAE,IAAI,CAACc,YAAY,CAAC;MAAE,CAAC,CAAC;MAC9C;IACF;IAEA,IACE,IAAI,CAACD,KAAK,CAACe,KAAK,IAChB,CAACnD,OAAO,CAAC,IAAI,CAACoC,KAAK,CAACe,KAAK,EAAE,IAAI,CAACH,KAAK,CAACE,aAAa,CAAC,EACpD;MACA,MAAM;QAAE3B;MAAO,CAAC,GAAG,IAAI,CAACyB,KAAK;MAC7BzB,MAAM,CAACsD,QAAQ,GAAG,IAAI,CAACzC,KAAK,CAACe,KAAK;MAElC,IAAI,IAAI,CAACf,KAAK,CAAC0C,gBAAgB,EAAE;QAC/B,MAAMxB,SAAS,GAAGrC,qBAAqB,CACrCM,MAAM,EACN,IAAI,CAACa,KAAK,CAAC0C,gBACb,CAAC;QAEDzE,WAAW,CAACiE,KAAK,CAAC/C,MAAM,CAAC;QACzBtB,UAAU,CAAC8E,MAAM,CAACxD,MAAM,EAAE+B,SAAS,CAAC;MACtC,CAAC,MAAM;QACL,IAAI;UACFrD,UAAU,CAAC8E,MAAM,CAACxD,MAAM,EAAErB,MAAM,CAAC8E,GAAG,CAACzD,MAAM,EAAE,EAAE,CAAC,CAAC;QACnD,CAAC,CAAC,OAAO0D,KAAK,EAAE;UACd;UACA;UACA;UACAC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;QACpB;MACF;MAEA,IAAI,CAACxB,QAAQ,CAAC;QACZP,aAAa,EAAE,IAAI,CAACd,KAAK,CAACe;MAC5B,CAAC,CAAC;MACF;IACF;IAEA,MAAM;MAAE5B;IAAO,CAAC,GAAG,IAAI,CAACyB,KAAK;IAE7B,IAAI,CAAC4B,SAAS,CAACV,QAAQ,IAAI,IAAI,CAAC9B,KAAK,CAAC8B,QAAQ,EAAE;MAC9C;;MAEA,IAAIkB,MAAM,CAACC,YAAY,CAAC,CAAC,CAACrD,IAAI,KAAK,MAAM,EAAE;QACzC;QACA/B,UAAU,CAAC8E,MAAM,CACf,IAAI,CAAC/B,KAAK,CAACzB,MAAM,EACjBrB,MAAM,CAACoF,KAAK,CAAC,IAAI,CAACtC,KAAK,CAACzB,MAAM,EAAErB,MAAM,CAACqF,KAAK,CAAC,IAAI,CAACvC,KAAK,CAACzB,MAAM,EAAE,EAAE,CAAC,CACrE,CAAC;MACH;MAEAlB,WAAW,CAACiE,KAAK,CAAC,IAAI,CAACtB,KAAK,CAACzB,MAAM,CAAC;IACtC;IAEA,IAAI,IAAI,CAACa,KAAK,CAAC8B,QAAQ,IAAI,IAAI,CAAC9B,KAAK,CAACoD,QAAQ,EAAE;MAC9C,IAAI,CAACpD,KAAK,CAACoD,QAAQ,CAACjE,MAAM,CAAC;IAC7B;EACF;EAEAkE,qBAAqBA,CAACC,SAAS,EAAEC,SAAS,EAAE;IAC1C,MAAM;MAAEzB,QAAQ,GAAG,IAAI;MAAEf,KAAK;MAAEyC;IAAS,CAAC,GAAGF,SAAS;IACtD,MAAMG,GAAG,GACP3B,QAAQ,IACR,IAAI,CAAC9B,KAAK,CAAC8B,QAAQ,KAAKA,QAAQ,IAChC,IAAI,CAAC9B,KAAK,CAACwD,QAAQ,KAAKA,QAAQ,IAChC,CAAC5F,OAAO,CAACmD,KAAK,EAAE,IAAI,CAACf,KAAK,CAACe,KAAK,CAAC;IACnC,OAAO0C,GAAG;EACZ;EAEAC,MAAMA,CAAA,EAAG;IAAA,IAAAC,iBAAA;IACP,MAAM;MACJ7B,QAAQ;MACR8B,WAAW;MACXC,SAAS;MACTC,gBAAgB;MAChBN,QAAQ;MACRO,SAAS;MACTC,gBAAgB,GAAG,EAAE;MACrBC,aAAa,GAAG,CAAC;IACnB,CAAC,GAAG,IAAI,CAACjE,KAAK;IACd,MAAMS,aAAa,GAAG,IAAI,CAACA,aAAa;;IAExC;IACA;IACA;IACA,MAAMtB,MAAM,GAAG6E,gBAAgB,CAACtC,MAAM,CACpC,CAACC,GAAG,EAAEuC,KAAK,KAAKA,KAAK,CAACvC,GAAG,CAAC,EAC1B,IAAI,CAACf,KAAK,CAACzB,MACb,CAAC;;IAED;IACA,IACEA,MAAM,CAAC+B,SAAS,IAChB,EAAAyC,iBAAA,OAAI,CAAC3D,KAAK,CAACe,KAAK,cAAA4C,iBAAA,uBAAhBA,iBAAA,CAAkBQ,MAAM,MAAK,CAAC,IAC9B,IAAI,CAACnE,KAAK,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC0B,QAAQ,CAAC0B,MAAM,KAAK,CAAC,IACzC,IAAI,CAACnE,KAAK,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC0B,QAAQ,CAAC,CAAC,CAAC,CAAC2B,IAAI,KAAK,EAAE,EAC3C;MACAvG,UAAU,CAAC8E,MAAM,CAACxD,MAAM,EAAE;QACxBkF,MAAM,EAAE;UAAE7C,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;UAAE8C,MAAM,EAAE;QAAE,CAAC;QACnCpC,KAAK,EAAE;UAAEV,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;UAAE8C,MAAM,EAAE;QAAE;MACnC,CAAC,CAAC;IACJ;IACA,IAAI,CAACnF,MAAM,GAAGA,MAAM;IAEpB,IAAI2E,gBAAgB,EAAE;MACpBA,gBAAgB,CAACS,OAAO,GAAGpF,MAAM;IACnC;;IAEA;;IAEA,OACEqF,KAAA,QAAAC,QAAA,KACM,IAAI,CAACzE,KAAK,CAAC,cAAc,CAAC;MAC9B+D,SAAS,EAAEpG,EAAE,CAAC,cAAc,EAAE;QAC5B,cAAc,EAAE,IAAI,CAACiD,KAAK,CAACC,mBAAmB;QAC9CiB;MACF,CAAC,CAAE;MACH4C,QAAQ,EAAE,CAAC,CAAE;MAAAC,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,IAEbR,KAAA,CAACzF,aAAa,CAACkG,QAAQ;MAAClE,KAAK,EAAE5B,MAAO;MAAAwF,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GACpCR,KAAA,CAACzG,KAAK;MACJoB,MAAM,EAAEA,MAAO;MACf+F,YAAY,EAAE,IAAI,CAAClF,KAAK,CAACe,KAAK,IAAIN,aAAa,CAACO,YAAY,CAAC,CAAE;MAC/DM,QAAQ,EAAE,IAAI,CAAClB,YAAa;MAAAuE,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAE3BlD,QAAQ,GACP0C,KAAA,CAAAtG,KAAA,CAAAiH,QAAA,QACEX,KAAA,CAAC1F,aAAa;MACZK,MAAM,EAAEA,MAAO;MACf4E,SAAS,EAAEA,SAAU;MACrBtD,aAAa,EAAE,IAAI,CAACT,KAAK,CAACS,aAAc;MAAAkE,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACzC,CAAC,EACDzF,MAAM,CAAC6F,IAAI,CAAC3E,aAAa,CAAC4E,qBAAqB,CAAC,CAACC,GAAG,CACnD,CAACC,CAAC,EAAEC,CAAC,KAAK;MACR,OACEhB,KAAA,CAACvF,OAAO;QAACwG,WAAW,EAAEF,CAAE;QAACG,GAAG,EAAEF,CAAE;QAAAb,MAAA;QAAAC,QAAA;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA;MAAA,GAC7BvE,aAAa,CAAC4E,qBAAqB,CAACE,CAAC,CAAC,CAACD,GAAG,CACzC,CAACK,GAAG,EAAEC,CAAC,KAAK;QACV,OAAOpB,KAAA,CAACmB,GAAG;UAACxG,MAAM,EAAEA,MAAO;UAACuG,GAAG,EAAEE,CAAE;UAAAjB,MAAA;UAAAC,QAAA;YAAAC,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA;QAAA,CAAE,CAAC;MACxC,CACF,CACO,CAAC;IAEd,CACF,CACA,CAAC,GAEH,EACD,EACDR,KAAA,CAACxG,QAAQ,EAAAyG,QAAA;MACPC,QAAQ,EAAE,IAAI,CAAC1E,KAAK,CAAC0E,QAAQ,IAAI,CAAE;MACnClB,QAAQ,EAAEA,QAAS;MACnBI,WAAW,EAAEA,WAAY;MACzBiC,aAAa,EAAG7F,KAAK,IAAKwE,KAAA,CAACjG,OAAO,EAAAkG,QAAA,KAAKzE,KAAK;QAAA2E,MAAA;QAAAC,QAAA;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA;MAAA,EAAG,CAAE;MACjDc,UAAU,EAAG9F,KAAK,IAAKwE,KAAA,CAAChG,IAAI,EAAAiG,QAAA,KAAKzE,KAAK;QAAA2E,MAAA;QAAAC,QAAA;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA;MAAA,EAAG,CAAE;MAC3Ce,QAAQ,EAAE,IAAI,CAAC5F,cAAe;MAC9B6F,UAAU,EAAE,KAAM;MAClBC,uBAAuB,EACrBxF,aAAa,CAACyF,cAAc,GAAGC,SAAS,GAAG,MAAM,IAClD;MACDC,MAAM,EAAEA,CAAA,KAAM;QACZ,IAAI,CAACpG,KAAK,CAACoG,MAAM,IAAI,IAAI,CAACpG,KAAK,CAACoG,MAAM,CAAC,CAAC;QACxC,OAAO,IAAI;MACb,CAAE;MACFC,OAAO,EAAE,IAAI,CAACrG,KAAK,CAACqG,OAAQ;MAC5BC,QAAQ,EAAGC,CAAC,IAAK;QACf,IAAI,CAACzE,QAAQ,IAAI,IAAI,CAAC9B,KAAK,CAACwG,OAAO,EAAE;UACnC;UACA;UACA;UACA;UACA,IAAI,CAACrH,MAAM,CAAC+B,SAAS,EAAE;YACrBe,UAAU,CAAC,MAAM;cACf,IAAI,CAACjC,KAAK,CAACwG,OAAO,CAAC,CAAC;YACtB,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;UACX;QACF;QAEA,IAAI,IAAI,CAACvF,gBAAgB,EAAEwF,YAAY,CAAC,IAAI,CAACxF,gBAAgB,CAAC;QAC9D,IAAI,CAACA,gBAAgB,GAAGgB,UAAU,CAAC,MAAM;UACvC,IACE9C,MAAM,CAAC+B,SAAS,IAChB,CAACtD,OAAO,CAACuB,MAAM,CAAC+B,SAAS,EAAE,IAAI,CAACX,cAAc,CAAC,IAC/C,CAAC,IAAI,CAAC+B,WAAW,EACjB;YACA,IAAI,CAACjB,QAAQ,CAAET,KAAK,KAAM;cAAE8F,MAAM,EAAE,CAAC,IAAI,CAAC9F,KAAK,CAAC8F;YAAO,CAAC,CAAC,CAAC;YAC1D,IAAI,CAACpG,iBAAiB,CACpBqG,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAC1H,MAAM,CAAC+B,SAAS,CAAC,CAC7C,CAAC;UACH;QACF,CAAC,EAAE,GAAG,CAAC;MACT,CAAE;MACF2C,SAAS,EAAGzE,KAAK,IAAK;QACpB,MAAM0H,OAAO,GAAG5H,aAAa,CAACC,MAAM,EAAEC,KAAK,EAAEqB,aAAa,CAAC;QAC3D,IAAIqG,OAAO,EAAE;QACbjD,SAAS,IAAIA,SAAS,CAAC;UAAE1E,MAAM;UAAEC;QAAM,CAAC,CAAC;MAC3C;IAAE,GACE6E,aAAa;MAAAU,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,EAClB,CAAC,EACDlD,QAAQ,IACPrB,aAAa,CAACsG,iBAAiB,CAACzB,GAAG,CAAC,CAAC0B,MAAM,EAAExB,CAAC,KAAK;MACjD,OAAOhB,KAAA,CAACwC,MAAM;QAACtB,GAAG,EAAEF,CAAE;QAACrG,MAAM,EAAEA,MAAO;QAAAwF,MAAA;QAAAC,QAAA;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA;MAAA,CAAE,CAAC;IAC3C,CAAC,CAAC,EACH,IAAI,CAAChF,KAAK,CAACiH,KAAK,GACfzC,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GACER,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAAKlD,QAAQ,GAAG,UAAU,GAAG,aAAkB,CAAC,EAChD0C,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAAI,kBACc,EAAC2B,IAAI,CAACE,SAAS,CAAC1H,MAAM,CAACkB,iBAAiB,CAAC,CAAC,CACxD,CAAC,EACLmE,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAAI,kBAAgB,EAAC2B,IAAI,CAACE,SAAS,CAAC1H,MAAM,CAAC+B,SAAS,CAAM,CAAC,EAC3DsD,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAAI,YAAU,EAAC2B,IAAI,CAACE,SAAS,CAAC1H,MAAM,CAACsD,QAAQ,CAAM,CAAC,EACpD+B,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAAI,GAAC,EAAClD,QAAQ,GAAG,UAAU,GAAG,aAAkB,CAAC,EACjD0C,KAAA;MAAAG,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GACG/G,WAAW,CAAC+D,SAAS,CAAC7C,MAAM,CAAC,GAAG,SAAS,GAAG,WAC3C,CACF,CAAC,GAEL,EACD,EACA,IAAI,CAACa,KAAK,CAACyC,QACP,CACe,CACrB,CAAC;EAEV;AACF;AAEA3C,WAAW,CAACoH,YAAY,GAAG;EACzB/F,UAAU,EAAE,EAAE;EACd4C,SAAS,EAAE;AACb,CAAC;;AAED;AACA,eAAeoD,UAAU,KAAAC,OAAA,GAAIpE,MAAM,cAAAoE,OAAA,eAANA,OAAA,CAAQC,OAAO,GACxC5I,mBAAmB,CAACqB,WAAW,CAAC,GAChCA,WAAW","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}