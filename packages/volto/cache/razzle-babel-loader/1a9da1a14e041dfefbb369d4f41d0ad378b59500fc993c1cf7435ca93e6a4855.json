{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Vocabularies actions.\n * @module actions/vocabularies/vocabularies\n */\n\nimport { GET_VOCABULARY, GET_VOCABULARY_TOKEN_TITLE } from '@plone/volto/constants/ActionTypes';\nimport { getVocabName } from '@plone/volto/helpers/Vocabularies/Vocabularies';\nimport qs from 'query-string';\n\n/**\n * Get vocabulary given a URL (coming from a Schema) or from a vocabulary name.\n * @function getVocabulary\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} query Only include results containing this string.\n * @param {number} start Start of result batch.\n * @param {number} b_size The size of the batch.\n * @param {string} subrequest Name of the subrequest.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabulary({\n  vocabNameOrURL,\n  query = null,\n  start = 0,\n  size,\n  subrequest\n}) {\n  const vocabulary = getVocabName(vocabNameOrURL);\n  let queryString = `b_start=${start}${size ? '&b_size=' + size : ''}`;\n  if (query) {\n    queryString = `${queryString}&title=${query}`;\n  }\n  return {\n    type: GET_VOCABULARY,\n    vocabulary: vocabNameOrURL,\n    start,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?${queryString}`\n    },\n    subrequest\n  };\n}\n\n/**\n * Get the title value given a token from vocabulary given a vocabulary URL\n * (coming from a Schema) or from a vocabulary name.\n * @function getVocabularyTokenTitle\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} token Only include results containing this string.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabularyTokenTitle({\n  vocabNameOrURL,\n  token = null,\n  tokens = null,\n  subrequest\n}) {\n  // In case we have a URL, we have to get the vocabulary name\n  const vocabulary = getVocabName(vocabNameOrURL);\n  const queryString = _objectSpread(_objectSpread({}, token && {\n    token\n  }), tokens && {\n    tokens\n  });\n  return {\n    type: GET_VOCABULARY_TOKEN_TITLE,\n    vocabulary: vocabNameOrURL,\n    token,\n    tokens,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?b_size=-1&${qs.stringify(queryString, {\n        encode: false\n      })}`\n    }\n  };\n}","map":{"version":3,"names":["GET_VOCABULARY","GET_VOCABULARY_TOKEN_TITLE","getVocabName","qs","getVocabulary","vocabNameOrURL","query","start","size","subrequest","vocabulary","queryString","type","request","op","path","getVocabularyTokenTitle","token","tokens","_objectSpread","stringify","encode"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/actions/vocabularies/vocabularies.js"],"sourcesContent":["/**\n * Vocabularies actions.\n * @module actions/vocabularies/vocabularies\n */\n\nimport {\n  GET_VOCABULARY,\n  GET_VOCABULARY_TOKEN_TITLE,\n} from '@plone/volto/constants/ActionTypes';\nimport { getVocabName } from '@plone/volto/helpers/Vocabularies/Vocabularies';\nimport qs from 'query-string';\n\n/**\n * Get vocabulary given a URL (coming from a Schema) or from a vocabulary name.\n * @function getVocabulary\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} query Only include results containing this string.\n * @param {number} start Start of result batch.\n * @param {number} b_size The size of the batch.\n * @param {string} subrequest Name of the subrequest.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabulary({\n  vocabNameOrURL,\n  query = null,\n  start = 0,\n  size,\n  subrequest,\n}) {\n  const vocabulary = getVocabName(vocabNameOrURL);\n\n  let queryString = `b_start=${start}${size ? '&b_size=' + size : ''}`;\n\n  if (query) {\n    queryString = `${queryString}&title=${query}`;\n  }\n  return {\n    type: GET_VOCABULARY,\n    vocabulary: vocabNameOrURL,\n    start,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?${queryString}`,\n    },\n    subrequest,\n  };\n}\n\n/**\n * Get the title value given a token from vocabulary given a vocabulary URL\n * (coming from a Schema) or from a vocabulary name.\n * @function getVocabularyTokenTitle\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} token Only include results containing this string.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabularyTokenTitle({\n  vocabNameOrURL,\n  token = null,\n  tokens = null,\n  subrequest,\n}) {\n  // In case we have a URL, we have to get the vocabulary name\n  const vocabulary = getVocabName(vocabNameOrURL);\n  const queryString = {\n    ...(token && { token }),\n    ...(tokens && { tokens }),\n  };\n\n  return {\n    type: GET_VOCABULARY_TOKEN_TITLE,\n    vocabulary: vocabNameOrURL,\n    token,\n    tokens,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?b_size=-1&${qs.stringify(\n        queryString,\n        {\n          encode: false,\n        },\n      )}`,\n    },\n  };\n}\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;;AAEA,SACEA,cAAc,EACdC,0BAA0B,QACrB,oCAAoC;AAC3C,SAASC,YAAY,QAAQ,gDAAgD;AAC7E,OAAOC,EAAE,MAAM,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAAC;EAC5BC,cAAc;EACdC,KAAK,GAAG,IAAI;EACZC,KAAK,GAAG,CAAC;EACTC,IAAI;EACJC;AACF,CAAC,EAAE;EACD,MAAMC,UAAU,GAAGR,YAAY,CAACG,cAAc,CAAC;EAE/C,IAAIM,WAAW,GAAG,WAAWJ,KAAK,GAAGC,IAAI,GAAG,UAAU,GAAGA,IAAI,GAAG,EAAE,EAAE;EAEpE,IAAIF,KAAK,EAAE;IACTK,WAAW,GAAG,GAAGA,WAAW,UAAUL,KAAK,EAAE;EAC/C;EACA,OAAO;IACLM,IAAI,EAAEZ,cAAc;IACpBU,UAAU,EAAEL,cAAc;IAC1BE,KAAK;IACLM,OAAO,EAAE;MACPC,EAAE,EAAE,KAAK;MACTC,IAAI,EAAE,kBAAkBL,UAAU,IAAIC,WAAW;IACnD,CAAC;IACDF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,uBAAuBA,CAAC;EACtCX,cAAc;EACdY,KAAK,GAAG,IAAI;EACZC,MAAM,GAAG,IAAI;EACbT;AACF,CAAC,EAAE;EACD;EACA,MAAMC,UAAU,GAAGR,YAAY,CAACG,cAAc,CAAC;EAC/C,MAAMM,WAAW,GAAAQ,aAAA,CAAAA,aAAA,KACXF,KAAK,IAAI;IAAEA;EAAM,CAAC,GAClBC,MAAM,IAAI;IAAEA;EAAO,CAAC,CACzB;EAED,OAAO;IACLN,IAAI,EAAEX,0BAA0B;IAChCS,UAAU,EAAEL,cAAc;IAC1BY,KAAK;IACLC,MAAM;IACNT,UAAU;IACVI,OAAO,EAAE;MACPC,EAAE,EAAE,KAAK;MACTC,IAAI,EAAE,kBAAkBL,UAAU,cAAcP,EAAE,CAACiB,SAAS,CAC1DT,WAAW,EACX;QACEU,MAAM,EAAE;MACV,CACF,CAAC;IACH;EACF,CAAC;AACH","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}