{"ast":null,"code":"import _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport castArray from 'lodash/castArray';\nimport map from 'lodash/map';\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n  const focus = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  return {\n    anchor,\n    focus\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport const autoformatInlineBlock = (editor, {\n  type,\n  markup,\n  preFormat,\n  format\n}) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true\n  });\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format\n    });\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBefore = (editor, at, options) => {\n  var _options$matchString;\n  if (!options || !options.match && !options.matchString) {\n    return Editor.before(editor, at, options);\n  }\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  const stackLength = (((_options$matchString = options.matchString) === null || _options$matchString === void 0 ? void 0 : _options$matchString.length) || 0) + 1;\n  const stack = Array(stackLength);\n  const unitOffset = !options.unit || options.unit === 'offset';\n  let count = 0;\n  while (true) {\n    var _options$match;\n    const beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (!options.multiPaths && !Path.equals(beforePoint.path, previousBeforePoint.path)) {\n      return;\n    }\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint\n    });\n    const matchString = castArray(options.matchString);\n    let beforeStringToMatch = beforeString;\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString\n      });\n      stack.pop();\n      beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n    }\n    if (matchString.includes(beforeStringToMatch) || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {\n      beforeString: beforeStringToMatch,\n      beforePoint,\n      at\n    })) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          var _stack;\n          return (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n    count += 1;\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\nexport const autoformatInline = (editor, {\n  type,\n  between,\n  markup,\n  ignoreTrim\n}) => {\n  const selection = editor.selection;\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n  let endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true\n  });\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore\n  };\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor\n      }\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  Transforms.wrapNodes(editor, {\n    type,\n    children: []\n  }, {\n    split: true\n  });\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n\n  // delete start markup\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter\n    }\n  });\n  return true;\n};\nexport const autoformatBlock = (editor, type, at, {\n  preFormat,\n  format\n}) => {\n  Transforms.delete(editor, {\n    at\n  });\n  if (preFormat) {\n    preFormat(editor);\n  }\n  if (!format) {\n    Transforms.setNodes(editor, {\n      type\n    }, {\n      at\n    }, {\n      match: n => Editor.isBlock(editor, n)\n    });\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = range => !!range && Range.isCollapsed(range);\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport const getText = (editor, at) => {\n  var _ref;\n  return (_ref = at && Editor.string(editor, at)) !== null && _ref !== void 0 ? _ref : '';\n};\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport const getBlockAbove = (editor, options = {}) => Editor.above(editor, _objectSpread({\n  match: n => Editor.isBlock(editor, n)\n}, options)) || [editor, []];\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (editor, {\n  at = editor.selection,\n  focus\n} = {}) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = {\n    path: at,\n    offset: 0\n  };\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n  const start = Editor.start(editor, path);\n  const focus = getPointFromLocation(editor, options);\n  if (!focus) return;\n  return {\n    anchor: start,\n    focus\n  };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport const withAutoformat = ({\n  rules\n}) => editor => {\n  const {\n    insertText\n  } = editor;\n  editor.insertText = text => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n    for (const {\n      trigger = ' ',\n      type,\n      markup,\n      preFormat,\n      format,\n      mode,\n      between,\n      ignoreTrim,\n      insertTrigger\n    } of rules) {\n      const triggers = castArray(trigger);\n\n      // Check trigger\n      if (!triggers.includes(text)) continue;\n      const markups = castArray(markup);\n      const rangeFromBlockStart = getRangeFromBlockStart(editor);\n      const textFromBlockStart = getText(editor, rangeFromBlockStart);\n      const valid = () => insertTrigger && insertText(text);\n      if (markups.includes(textFromBlockStart)) {\n        // Start of the block\n        autoformatBlock(editor, type, rangeFromBlockStart, {\n          preFormat,\n          format\n        });\n        return valid();\n      }\n      if (mode === 'inline-block') {\n        if (autoformatInlineBlock(editor, {\n          preFormat,\n          markup,\n          format,\n          type\n        })) {\n          return valid();\n        }\n      }\n      if (mode === 'inline') {\n        if (autoformatInline(editor, {\n          type,\n          between,\n          ignoreTrim,\n          markup: Array.isArray(markup) ? markup[0] : markup\n        })) {\n          return valid();\n        }\n      }\n    }\n    insertText(text);\n  };\n  return editor;\n};","map":{"version":3,"names":["castArray","map","Editor","Path","Point","Range","Transforms","getRangeBefore","editor","at","options","anchor","getPointBefore","focus","point","edge","autoformatInlineBlock","type","markup","preFormat","format","markupRange","selection","matchString","skipInvalid","autoformatBlock","insertBreak","_options$matchString","match","before","beforeAt","previousBeforePoint","stackLength","length","stack","Array","unitOffset","unit","count","_options$match","beforePoint","multiPaths","equals","path","beforeString","string","beforeStringToMatch","unshift","text","pop","slice","join","includes","call","afterMatch","_stack","autoformatInline","between","ignoreTrim","startMarkup","endMarkup","endMarkupPointBefore","startMarkupPointAfter","markupText","getText","trim","delete","select","wrapNodes","children","split","collapse","startMarkupPointBefore","setNodes","n","isBlock","isCollapsed","range","_ref","getBlockAbove","above","_objectSpread","getPointFromLocation","isRange","isPoint","isPath","offset","getRangeFromBlockStart","start","withAutoformat","rules","insertText","trigger","mode","insertTrigger","triggers","markups","rangeFromBlockStart","textFromBlockStart","valid","isArray"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/plugins/Markdown/extensions.js"],"sourcesContent":["import castArray from 'lodash/castArray';\nimport map from 'lodash/map';\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n\n  const focus = Editor.point(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport const autoformatInlineBlock = (\n  editor,\n  { type, markup, preFormat, format },\n) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true,\n  });\n\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format,\n    });\n\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBefore = (editor, at, options) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return Editor.before(editor, at, options);\n  }\n\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, { edge: 'end' });\n\n  const stackLength = (options.matchString?.length || 0) + 1;\n  const stack = Array(stackLength);\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  let count = 0;\n  while (true) {\n    const beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (\n      !options.multiPaths &&\n      !Path.equals(beforePoint.path, previousBeforePoint.path)\n    ) {\n      return;\n    }\n\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint,\n    });\n\n    const matchString = castArray(options.matchString);\n\n    let beforeStringToMatch = beforeString;\n\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString,\n      });\n      stack.pop();\n\n      beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n    }\n\n    if (\n      matchString.includes(beforeStringToMatch) ||\n      options.match?.({ beforeString: beforeStringToMatch, beforePoint, at })\n    ) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          return stack[stack.length - 1]?.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n\n    count += 1;\n\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\n\nexport const autoformatInline = (\n  editor,\n  { type, between, markup, ignoreTrim },\n) => {\n  const selection = editor.selection;\n\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n\n  let endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true,\n  });\n\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore,\n  };\n\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor,\n      },\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  Transforms.wrapNodes(editor, { type, children: [] }, { split: true });\n  Transforms.collapse(editor, { edge: 'end' });\n\n  // delete start markup\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true,\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter,\n    },\n  });\n\n  return true;\n};\n\nexport const autoformatBlock = (editor, type, at, { preFormat, format }) => {\n  Transforms.delete(editor, { at });\n\n  if (preFormat) {\n    preFormat(editor);\n  }\n\n  if (!format) {\n    Transforms.setNodes(\n      editor,\n      { type },\n      { at },\n      { match: (n) => Editor.isBlock(editor, n) },\n    );\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range) => !!range && Range.isCollapsed(range);\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport const getText = (editor, at) => (at && Editor.string(editor, at)) ?? '';\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport const getBlockAbove = (editor, options = {}) =>\n  Editor.above(editor, {\n    match: (n) => Editor.isBlock(editor, n),\n    ...options,\n  }) || [editor, []];\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (\n  editor,\n  { at = editor.selection, focus } = {},\n) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { path: at, offset: 0 };\n\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n\n  const start = Editor.start(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport const withAutoformat =\n  ({ rules }) =>\n  (editor) => {\n    const { insertText } = editor;\n\n    editor.insertText = (text) => {\n      if (!isCollapsed(editor.selection)) return insertText(text);\n\n      for (const {\n        trigger = ' ',\n        type,\n        markup,\n        preFormat,\n        format,\n        mode,\n        between,\n        ignoreTrim,\n        insertTrigger,\n      } of rules) {\n        const triggers = castArray(trigger);\n\n        // Check trigger\n        if (!triggers.includes(text)) continue;\n\n        const markups = castArray(markup);\n\n        const rangeFromBlockStart = getRangeFromBlockStart(editor);\n        const textFromBlockStart = getText(editor, rangeFromBlockStart);\n\n        const valid = () => insertTrigger && insertText(text);\n\n        if (markups.includes(textFromBlockStart)) {\n          // Start of the block\n          autoformatBlock(editor, type, rangeFromBlockStart, {\n            preFormat,\n            format,\n          });\n          return valid();\n        }\n\n        if (mode === 'inline-block') {\n          if (\n            autoformatInlineBlock(editor, { preFormat, markup, format, type })\n          ) {\n            return valid();\n          }\n        }\n\n        if (mode === 'inline') {\n          if (\n            autoformatInline(editor, {\n              type,\n              between,\n              ignoreTrim,\n              markup: Array.isArray(markup) ? markup[0] : markup,\n            })\n          ) {\n            return valid();\n          }\n        }\n      }\n\n      insertText(text);\n    };\n\n    return editor;\n  };\n"],"mappings":";AAAA,OAAOA,SAAS,MAAM,kBAAkB;AACxC,OAAOC,GAAG,MAAM,YAAY;AAC5B,SAASC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,QAAQ,OAAO;;AAE9D;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAGA,CAACC,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EACrD,MAAMC,MAAM,GAAGC,cAAc,CAACJ,MAAM,EAAEC,EAAE,EAAEC,OAAO,CAAC;EAClD,IAAI,CAACC,MAAM,EAAE;EAEb,MAAME,KAAK,GAAGX,MAAM,CAACY,KAAK,CAACN,MAAM,EAAEC,EAAE,EAAE;IAAEM,IAAI,EAAE;EAAM,CAAC,CAAC;EAEvD,OAAO;IACLJ,MAAM;IACNE;EACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMG,qBAAqB,GAAGA,CACnCR,MAAM,EACN;EAAES,IAAI;EAAEC,MAAM;EAAEC,SAAS;EAAEC;AAAO,CAAC,KAChC;EACH,MAAMC,WAAW,GAAGd,cAAc,CAACC,MAAM,EAAEA,MAAM,CAACc,SAAS,EAAE;IAC3DC,WAAW,EAAEL,MAAM;IACnBM,WAAW,EAAE;EACf,CAAC,CAAC;EAEF,IAAIH,WAAW,EAAE;IACfI,eAAe,CAACjB,MAAM,EAAES,IAAI,EAAEI,WAAW,EAAE;MACzCF,SAAS,EAAEA,CAAA,KAAM;QACfX,MAAM,CAACkB,WAAW,CAAC,CAAC;QACpB,IAAIP,SAAS,EAAE;UACbA,SAAS,CAACX,MAAM,CAAC;QACnB;MACF,CAAC;MACDY;IACF,CAAC,CAAC;IAEF,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMR,cAAc,GAAGA,CAACJ,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EAAA,IAAAiB,oBAAA;EACrD,IAAI,CAACjB,OAAO,IAAK,CAACA,OAAO,CAACkB,KAAK,IAAI,CAAClB,OAAO,CAACa,WAAY,EAAE;IACxD,OAAOrB,MAAM,CAAC2B,MAAM,CAACrB,MAAM,EAAEC,EAAE,EAAEC,OAAO,CAAC;EAC3C;EAEA,IAAIoB,QAAQ,GAAGrB,EAAE;EACjB,IAAIsB,mBAAmB,GAAG7B,MAAM,CAACY,KAAK,CAACN,MAAM,EAAEC,EAAE,EAAE;IAAEM,IAAI,EAAE;EAAM,CAAC,CAAC;EAEnE,MAAMiB,WAAW,GAAG,CAAC,EAAAL,oBAAA,GAAAjB,OAAO,CAACa,WAAW,cAAAI,oBAAA,uBAAnBA,oBAAA,CAAqBM,MAAM,KAAI,CAAC,IAAI,CAAC;EAC1D,MAAMC,KAAK,GAAGC,KAAK,CAACH,WAAW,CAAC;EAEhC,MAAMI,UAAU,GAAG,CAAC1B,OAAO,CAAC2B,IAAI,IAAI3B,OAAO,CAAC2B,IAAI,KAAK,QAAQ;EAE7D,IAAIC,KAAK,GAAG,CAAC;EACb,OAAO,IAAI,EAAE;IAAA,IAAAC,cAAA;IACX,MAAMC,WAAW,GAAGtC,MAAM,CAAC2B,MAAM,CAACrB,MAAM,EAAEsB,QAAQ,EAAEpB,OAAO,CAAC;;IAE5D;IACA,IAAI,CAAC8B,WAAW,EAAE;;IAElB;IACA,IACE,CAAC9B,OAAO,CAAC+B,UAAU,IACnB,CAACtC,IAAI,CAACuC,MAAM,CAACF,WAAW,CAACG,IAAI,EAAEZ,mBAAmB,CAACY,IAAI,CAAC,EACxD;MACA;IACF;IAEA,MAAMC,YAAY,GAAG1C,MAAM,CAAC2C,MAAM,CAACrC,MAAM,EAAE;MACzCG,MAAM,EAAE6B,WAAW;MACnB3B,KAAK,EAAEkB;IACT,CAAC,CAAC;IAEF,MAAMR,WAAW,GAAGvB,SAAS,CAACU,OAAO,CAACa,WAAW,CAAC;IAElD,IAAIuB,mBAAmB,GAAGF,YAAY;IAEtC,IAAIR,UAAU,IAAIJ,WAAW,EAAE;MAC7BE,KAAK,CAACa,OAAO,CAAC;QACZjC,KAAK,EAAE0B,WAAW;QAClBQ,IAAI,EAAEJ;MACR,CAAC,CAAC;MACFV,KAAK,CAACe,GAAG,CAAC,CAAC;MAEXH,mBAAmB,GAAG7C,GAAG,CAACiC,KAAK,CAACgB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC;IAChE;IAEA,IACE5B,WAAW,CAAC6B,QAAQ,CAACN,mBAAmB,CAAC,KAAAP,cAAA,GACzC7B,OAAO,CAACkB,KAAK,cAAAW,cAAA,eAAbA,cAAA,CAAAc,IAAA,CAAA3C,OAAO,EAAS;MAAEkC,YAAY,EAAEE,mBAAmB;MAAEN,WAAW;MAAE/B;IAAG,CAAC,CAAC,EACvE;MACA,IAAIC,OAAO,CAAC4C,UAAU,EAAE;QACtB,IAAItB,WAAW,IAAII,UAAU,EAAE;UAAA,IAAAmB,MAAA;UAC7B,QAAAA,MAAA,GAAOrB,KAAK,CAACA,KAAK,CAACD,MAAM,GAAG,CAAC,CAAC,cAAAsB,MAAA,uBAAvBA,MAAA,CAAyBzC,KAAK;QACvC;QACA,OAAOiB,mBAAmB;MAC5B;MACA,OAAOS,WAAW;IACpB;IAEAT,mBAAmB,GAAGS,WAAW;IACjCV,QAAQ,GAAGU,WAAW;IAEtBF,KAAK,IAAI,CAAC;IAEV,IAAI,CAAC5B,OAAO,CAACc,WAAW,EAAE;MACxB,IAAI,CAACD,WAAW,IAAIe,KAAK,GAAGf,WAAW,CAACU,MAAM,EAAE;IAClD;EACF;AACF,CAAC;AAED,OAAO,MAAMuB,gBAAgB,GAAGA,CAC9BhD,MAAM,EACN;EAAES,IAAI;EAAEwC,OAAO;EAAEvC,MAAM;EAAEwC;AAAW,CAAC,KAClC;EACH,MAAMpC,SAAS,GAAGd,MAAM,CAACc,SAAS;EAElC,MAAMqC,WAAW,GAAGF,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC,GAAGvC,MAAM;EACjD,MAAM0C,SAAS,GAAGH,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE;EAE3C,IAAII,oBAAoB,GAAGvC,SAAS,CAACX,MAAM;EAC3C,IAAIiD,SAAS,EAAE;IACbC,oBAAoB,GAAGjD,cAAc,CAACJ,MAAM,EAAEc,SAAS,EAAE;MACvDC,WAAW,EAAEqC;IACf,CAAC,CAAC;IACF,IAAI,CAACC,oBAAoB,EAAE,OAAO,KAAK;EACzC;EAEA,MAAMC,qBAAqB,GAAGlD,cAAc,CAACJ,MAAM,EAAEqD,oBAAoB,EAAE;IACzEtC,WAAW,EAAEoC,WAAW;IACxBnC,WAAW,EAAE,IAAI;IACjB8B,UAAU,EAAE;EACd,CAAC,CAAC;EAEF,IAAI,CAACQ,qBAAqB,EAAE,OAAO,KAAK;;EAExC;;EAEA,MAAMzC,WAAW,GAAG;IAClBV,MAAM,EAAEmD,qBAAqB;IAC7BjD,KAAK,EAAEgD;EACT,CAAC;EAED,IAAI,CAACH,UAAU,EAAE;IACf,MAAMK,UAAU,GAAGC,OAAO,CAACxD,MAAM,EAAEa,WAAW,CAAC;IAC/C,IAAI0C,UAAU,CAACE,IAAI,CAAC,CAAC,KAAKF,UAAU,EAAE,OAAO,KAAK;EACpD;;EAEA;EACA,IAAIH,SAAS,EAAE;IACbC,oBAAoB,GAAGjD,cAAc,CAACJ,MAAM,EAAEc,SAAS,EAAE;MACvDC,WAAW,EAAEqC;IACf,CAAC,CAAC;IACFtD,UAAU,CAAC4D,MAAM,CAAC1D,MAAM,EAAE;MACxBC,EAAE,EAAE;QACFE,MAAM,EAAEkD,oBAAoB;QAC5BhD,KAAK,EAAES,SAAS,CAACX;MACnB;IACF,CAAC,CAAC;EACJ;;EAEA;EACAL,UAAU,CAAC6D,MAAM,CAAC3D,MAAM,EAAEa,WAAW,CAAC;EACtCf,UAAU,CAAC8D,SAAS,CAAC5D,MAAM,EAAE;IAAES,IAAI;IAAEoD,QAAQ,EAAE;EAAG,CAAC,EAAE;IAAEC,KAAK,EAAE;EAAK,CAAC,CAAC;EACrEhE,UAAU,CAACiE,QAAQ,CAAC/D,MAAM,EAAE;IAAEO,IAAI,EAAE;EAAM,CAAC,CAAC;;EAE5C;EACA,MAAMyD,sBAAsB,GAAG5D,cAAc,CAACJ,MAAM,EAAEc,SAAS,EAAE;IAC/DC,WAAW,EAAEoC,WAAW;IACxBnC,WAAW,EAAE;EACf,CAAC,CAAC;EACFlB,UAAU,CAAC4D,MAAM,CAAC1D,MAAM,EAAE;IACxBC,EAAE,EAAE;MACFE,MAAM,EAAE6D,sBAAsB;MAC9B3D,KAAK,EAAEiD;IACT;EACF,CAAC,CAAC;EAEF,OAAO,IAAI;AACb,CAAC;AAED,OAAO,MAAMrC,eAAe,GAAGA,CAACjB,MAAM,EAAES,IAAI,EAAER,EAAE,EAAE;EAAEU,SAAS;EAAEC;AAAO,CAAC,KAAK;EAC1Ed,UAAU,CAAC4D,MAAM,CAAC1D,MAAM,EAAE;IAAEC;EAAG,CAAC,CAAC;EAEjC,IAAIU,SAAS,EAAE;IACbA,SAAS,CAACX,MAAM,CAAC;EACnB;EAEA,IAAI,CAACY,MAAM,EAAE;IACXd,UAAU,CAACmE,QAAQ,CACjBjE,MAAM,EACN;MAAES;IAAK,CAAC,EACR;MAAER;IAAG,CAAC,EACN;MAAEmB,KAAK,EAAG8C,CAAC,IAAKxE,MAAM,CAACyE,OAAO,CAACnE,MAAM,EAAEkE,CAAC;IAAE,CAC5C,CAAC;EACH,CAAC,MAAM;IACLtD,MAAM,CAACZ,MAAM,CAAC;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMoE,WAAW,GAAIC,KAAK,IAAK,CAAC,CAACA,KAAK,IAAIxE,KAAK,CAACuE,WAAW,CAACC,KAAK,CAAC;;AAEzE;AACA;AACA;AACA;AACA,OAAO,MAAMb,OAAO,GAAGA,CAACxD,MAAM,EAAEC,EAAE;EAAA,IAAAqE,IAAA;EAAA,QAAAA,IAAA,GAAMrE,EAAE,IAAIP,MAAM,CAAC2C,MAAM,CAACrC,MAAM,EAAEC,EAAE,CAAC,cAAAqE,IAAA,cAAAA,IAAA,GAAK,EAAE;AAAA;;AAE9E;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAGA,CAACvE,MAAM,EAAEE,OAAO,GAAG,CAAC,CAAC,KAChDR,MAAM,CAAC8E,KAAK,CAACxE,MAAM,EAAAyE,aAAA;EACjBrD,KAAK,EAAG8C,CAAC,IAAKxE,MAAM,CAACyE,OAAO,CAACnE,MAAM,EAAEkE,CAAC;AAAC,GACpChE,OAAO,CACX,CAAC,IAAI,CAACF,MAAM,EAAE,EAAE,CAAC;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM0E,oBAAoB,GAAGA,CAClC1E,MAAM,EACN;EAAEC,EAAE,GAAGD,MAAM,CAACc,SAAS;EAAET;AAAM,CAAC,GAAG,CAAC,CAAC,KAClC;EACH,IAAIC,KAAK;EACT,IAAIT,KAAK,CAAC8E,OAAO,CAAC1E,EAAE,CAAC,EAAEK,KAAK,GAAG,CAACD,KAAK,GAAGJ,EAAE,CAACE,MAAM,GAAGF,EAAE,CAACI,KAAK;EAC5D,IAAIT,KAAK,CAACgF,OAAO,CAAC3E,EAAE,CAAC,EAAEK,KAAK,GAAGL,EAAE;EACjC,IAAIN,IAAI,CAACkF,MAAM,CAAC5E,EAAE,CAAC,EAAEK,KAAK,GAAG;IAAE6B,IAAI,EAAElC,EAAE;IAAE6E,MAAM,EAAE;EAAE,CAAC;EAEpD,OAAOxE,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMyE,sBAAsB,GAAGA,CAAC/E,MAAM,EAAEE,OAAO,GAAG,CAAC,CAAC,KAAK;EAC9D,MAAM,GAAGiC,IAAI,CAAC,GAAGoC,aAAa,CAACvE,MAAM,EAAEE,OAAO,CAAC;EAE/C,MAAM8E,KAAK,GAAGtF,MAAM,CAACsF,KAAK,CAAChF,MAAM,EAAEmC,IAAI,CAAC;EAExC,MAAM9B,KAAK,GAAGqE,oBAAoB,CAAC1E,MAAM,EAAEE,OAAO,CAAC;EAEnD,IAAI,CAACG,KAAK,EAAE;EAEZ,OAAO;IAAEF,MAAM,EAAE6E,KAAK;IAAE3E;EAAM,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAM4E,cAAc,GACzBA,CAAC;EAAEC;AAAM,CAAC,KACTlF,MAAM,IAAK;EACV,MAAM;IAAEmF;EAAW,CAAC,GAAGnF,MAAM;EAE7BA,MAAM,CAACmF,UAAU,GAAI3C,IAAI,IAAK;IAC5B,IAAI,CAAC4B,WAAW,CAACpE,MAAM,CAACc,SAAS,CAAC,EAAE,OAAOqE,UAAU,CAAC3C,IAAI,CAAC;IAE3D,KAAK,MAAM;MACT4C,OAAO,GAAG,GAAG;MACb3E,IAAI;MACJC,MAAM;MACNC,SAAS;MACTC,MAAM;MACNyE,IAAI;MACJpC,OAAO;MACPC,UAAU;MACVoC;IACF,CAAC,IAAIJ,KAAK,EAAE;MACV,MAAMK,QAAQ,GAAG/F,SAAS,CAAC4F,OAAO,CAAC;;MAEnC;MACA,IAAI,CAACG,QAAQ,CAAC3C,QAAQ,CAACJ,IAAI,CAAC,EAAE;MAE9B,MAAMgD,OAAO,GAAGhG,SAAS,CAACkB,MAAM,CAAC;MAEjC,MAAM+E,mBAAmB,GAAGV,sBAAsB,CAAC/E,MAAM,CAAC;MAC1D,MAAM0F,kBAAkB,GAAGlC,OAAO,CAACxD,MAAM,EAAEyF,mBAAmB,CAAC;MAE/D,MAAME,KAAK,GAAGA,CAAA,KAAML,aAAa,IAAIH,UAAU,CAAC3C,IAAI,CAAC;MAErD,IAAIgD,OAAO,CAAC5C,QAAQ,CAAC8C,kBAAkB,CAAC,EAAE;QACxC;QACAzE,eAAe,CAACjB,MAAM,EAAES,IAAI,EAAEgF,mBAAmB,EAAE;UACjD9E,SAAS;UACTC;QACF,CAAC,CAAC;QACF,OAAO+E,KAAK,CAAC,CAAC;MAChB;MAEA,IAAIN,IAAI,KAAK,cAAc,EAAE;QAC3B,IACE7E,qBAAqB,CAACR,MAAM,EAAE;UAAEW,SAAS;UAAED,MAAM;UAAEE,MAAM;UAAEH;QAAK,CAAC,CAAC,EAClE;UACA,OAAOkF,KAAK,CAAC,CAAC;QAChB;MACF;MAEA,IAAIN,IAAI,KAAK,QAAQ,EAAE;QACrB,IACErC,gBAAgB,CAAChD,MAAM,EAAE;UACvBS,IAAI;UACJwC,OAAO;UACPC,UAAU;UACVxC,MAAM,EAAEiB,KAAK,CAACiE,OAAO,CAAClF,MAAM,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,GAAGA;QAC9C,CAAC,CAAC,EACF;UACA,OAAOiF,KAAK,CAAC,CAAC;QAChB;MACF;IACF;IAEAR,UAAU,CAAC3C,IAAI,CAAC;EAClB,CAAC;EAED,OAAOxC,MAAM;AACf,CAAC","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}