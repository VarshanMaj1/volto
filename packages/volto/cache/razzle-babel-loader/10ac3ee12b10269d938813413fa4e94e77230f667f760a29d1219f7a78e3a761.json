{"ast":null,"code":"import { Editor, Range, Transforms } from 'slate';\nimport config from '@plone/volto/registry';\nimport { isCursorAtBlockEnd } from '@plone/volto-slate/utils/selection';\nimport { splitEditorInTwoFragments } from '@plone/volto-slate/utils/ops';\nimport { setEditorContent } from '@plone/volto-slate/utils/editor';\nimport { createAndSelectNewBlockAfter } from '@plone/volto-slate/utils/volto-blocks';\nimport { getCurrentListItem } from '@plone/volto-slate/utils/lists';\nimport { createEmptyParagraph } from '@plone/volto-slate/utils/blocks';\n\n/**\n * Handles `Enter` key on empty and non-empty list items.\n *\n * @param {Editor} editor The editor which should be modified by this extension\n * @param {Object} intl intl object.\n * with a new version of the `insertBreak` method of the Slate editor.\n *\n * @description If the selection does not exist or is expanded, handle with the\n * default behavior. If the selection is inside a LI and it starts at a non-0\n * offset, split the LI. If the selection anchor is not in a LI or it is not at\n * offset 0, handle with the default behavior. Else delete the line before the\n * text cursor and then split the editor in two fragments, and convert them to\n * separate Slate Text blocks, based on the selection.\n */\nexport const breakList = (editor, intl) => {\n  const {\n    insertBreak\n  } = editor;\n  editor.insertBreak = () => {\n    // If the selection does not exist or is expanded, handle with the default\n    // behavior.\n    if (!(editor.selection && Range.isCollapsed(editor.selection))) {\n      insertBreak();\n      return false;\n    }\n    const {\n      slate\n    } = config.settings;\n    const {\n      anchor\n    } = editor.selection;\n    const blockProps = editor.getBlockProps();\n    const detached = blockProps.detached;\n    const ref = Editor.rangeRef(editor, editor.selection, {\n      affinity: 'inward'\n    });\n\n    // If the selection is inside a LI and it starts at a non-0 offset, split\n    // the LI. (if one of the parents is a list item, break that list item)\n    const [listItem, listItemPath] = getCurrentListItem(editor);\n    if (listItem) {\n      // if there is text in the selection\n      if (Editor.string(editor, listItemPath)) {\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n          match: node => node.type === slate.listItemType,\n          always: true // in case cursor is at end of line\n        });\n        return true;\n      }\n    }\n\n    // If the selection anchor is not in a LI or it is not at offset 0, handle\n    // with the default behavior.\n    const [parent] = Editor.parent(editor, anchor.path); // , parentPath\n\n    if (parent.type !== slate.listItemType || anchor.offset > 0) {\n      insertBreak();\n      return; // applies default behaviour, as defined in insertBreak.js extension\n    }\n    if (parent && !detached) {\n      const {\n        data\n      } = blockProps;\n      // Don't add new block if not allowed\n      if (data !== null && data !== void 0 && data.disableNewBlocks) {\n        return insertBreak();\n      }\n    }\n    Editor.deleteBackward(editor, {\n      unit: 'line'\n    });\n    // also account for empty nodes [{text: ''}]\n    if (Editor.isEmpty(editor, parent)) {\n      if (detached) {\n        Transforms.removeNodes(editor, {\n          at: ref.current\n        });\n        Transforms.insertNodes(editor, createEmptyParagraph(), {\n          at: [editor.children.length]\n        });\n        Transforms.select(editor, Editor.end(editor, []));\n      } else {\n        createAndSelectNewBlockAfter(editor, [createEmptyParagraph()], intl);\n        Transforms.removeNodes(editor, {\n          at: ref.current\n        });\n      }\n      return true;\n    }\n    Transforms.removeNodes(editor, {\n      at: ref.current\n    });\n    if (isCursorAtBlockEnd(editor)) {\n      if (detached) {\n        Editor.insertNode(editor, createEmptyParagraph());\n      } else {\n        createAndSelectNewBlockAfter(editor, [createEmptyParagraph()], intl);\n      }\n      return true;\n    }\n    if (!detached) {\n      const [top, bottom] = splitEditorInTwoFragments(editor, ref.current);\n      setEditorContent(editor, top);\n      createAndSelectNewBlockAfter(editor, bottom, intl);\n    }\n    return true;\n  };\n  return editor;\n};","map":{"version":3,"names":["Editor","Range","Transforms","config","isCursorAtBlockEnd","splitEditorInTwoFragments","setEditorContent","createAndSelectNewBlockAfter","getCurrentListItem","createEmptyParagraph","breakList","editor","intl","insertBreak","selection","isCollapsed","slate","settings","anchor","blockProps","getBlockProps","detached","ref","rangeRef","affinity","listItem","listItemPath","string","splitNodes","at","match","node","type","listItemType","always","parent","path","offset","data","disableNewBlocks","deleteBackward","unit","isEmpty","removeNodes","current","insertNodes","children","length","select","end","insertNode","top","bottom"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/blocks/Text/extensions/breakList.js"],"sourcesContent":["import { Editor, Range, Transforms } from 'slate';\nimport config from '@plone/volto/registry';\nimport { isCursorAtBlockEnd } from '@plone/volto-slate/utils/selection';\nimport { splitEditorInTwoFragments } from '@plone/volto-slate/utils/ops';\nimport { setEditorContent } from '@plone/volto-slate/utils/editor';\nimport { createAndSelectNewBlockAfter } from '@plone/volto-slate/utils/volto-blocks';\nimport { getCurrentListItem } from '@plone/volto-slate/utils/lists';\nimport { createEmptyParagraph } from '@plone/volto-slate/utils/blocks';\n\n/**\n * Handles `Enter` key on empty and non-empty list items.\n *\n * @param {Editor} editor The editor which should be modified by this extension\n * @param {Object} intl intl object.\n * with a new version of the `insertBreak` method of the Slate editor.\n *\n * @description If the selection does not exist or is expanded, handle with the\n * default behavior. If the selection is inside a LI and it starts at a non-0\n * offset, split the LI. If the selection anchor is not in a LI or it is not at\n * offset 0, handle with the default behavior. Else delete the line before the\n * text cursor and then split the editor in two fragments, and convert them to\n * separate Slate Text blocks, based on the selection.\n */\nexport const breakList = (editor, intl) => {\n  const { insertBreak } = editor;\n\n  editor.insertBreak = () => {\n    // If the selection does not exist or is expanded, handle with the default\n    // behavior.\n    if (!(editor.selection && Range.isCollapsed(editor.selection))) {\n      insertBreak();\n      return false;\n    }\n\n    const { slate } = config.settings;\n    const { anchor } = editor.selection;\n    const blockProps = editor.getBlockProps();\n    const detached = blockProps.detached;\n\n    const ref = Editor.rangeRef(editor, editor.selection, {\n      affinity: 'inward',\n    });\n\n    // If the selection is inside a LI and it starts at a non-0 offset, split\n    // the LI. (if one of the parents is a list item, break that list item)\n    const [listItem, listItemPath] = getCurrentListItem(editor);\n    if (listItem) {\n      // if there is text in the selection\n      if (Editor.string(editor, listItemPath)) {\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n          match: (node) => node.type === slate.listItemType,\n          always: true, // in case cursor is at end of line\n        });\n\n        return true;\n      }\n    }\n\n    // If the selection anchor is not in a LI or it is not at offset 0, handle\n    // with the default behavior.\n    const [parent] = Editor.parent(editor, anchor.path); // , parentPath\n\n    if (parent.type !== slate.listItemType || anchor.offset > 0) {\n      insertBreak();\n      return; // applies default behaviour, as defined in insertBreak.js extension\n    }\n\n    if (parent && !detached) {\n      const { data } = blockProps;\n      // Don't add new block if not allowed\n      if (data?.disableNewBlocks) {\n        return insertBreak();\n      }\n    }\n\n    Editor.deleteBackward(editor, { unit: 'line' });\n    // also account for empty nodes [{text: ''}]\n    if (Editor.isEmpty(editor, parent)) {\n      if (detached) {\n        Transforms.removeNodes(editor, { at: ref.current });\n\n        Transforms.insertNodes(editor, createEmptyParagraph(), {\n          at: [editor.children.length],\n        });\n        Transforms.select(editor, Editor.end(editor, []));\n      } else {\n        createAndSelectNewBlockAfter(editor, [createEmptyParagraph()], intl);\n        Transforms.removeNodes(editor, { at: ref.current });\n      }\n      return true;\n    }\n\n    Transforms.removeNodes(editor, { at: ref.current });\n\n    if (isCursorAtBlockEnd(editor)) {\n      if (detached) {\n        Editor.insertNode(editor, createEmptyParagraph());\n      } else {\n        createAndSelectNewBlockAfter(editor, [createEmptyParagraph()], intl);\n      }\n      return true;\n    }\n\n    if (!detached) {\n      const [top, bottom] = splitEditorInTwoFragments(editor, ref.current);\n      setEditorContent(editor, top);\n      createAndSelectNewBlockAfter(editor, bottom, intl);\n    }\n    return true;\n  };\n\n  return editor;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}