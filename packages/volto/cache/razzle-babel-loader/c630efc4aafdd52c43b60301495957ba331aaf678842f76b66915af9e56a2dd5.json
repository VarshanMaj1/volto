{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport isArray from 'lodash/isArray';\nimport { getBlocksLayoutFieldname } from '@plone/volto/helpers/Blocks/Blocks';\nfunction getDragDepth(offset, indentationWidth) {\n  return Math.round(offset / indentationWidth);\n}\nexport function getProjection(items, activeId, overId, dragOffset, indentationWidth, arrayMove) {\n  const overItemIndex = items.findIndex(({\n    id\n  }) => id === overId);\n  const activeItemIndex = items.findIndex(({\n    id\n  }) => id === activeId);\n  const activeItem = items[activeItemIndex];\n  const newItems = arrayMove(items, activeItemIndex, overItemIndex);\n  const previousItem = newItems[overItemIndex - 1];\n  const nextItem = newItems[overItemIndex + 1];\n  const dragDepth = getDragDepth(dragOffset, indentationWidth);\n  const projectedDepth = activeItem.depth + dragDepth;\n  const maxDepth = getMaxDepth({\n    previousItem\n  });\n  const minDepth = getMinDepth({\n    nextItem\n  });\n  let depth = projectedDepth;\n  if (projectedDepth >= maxDepth) {\n    depth = maxDepth;\n  } else if (projectedDepth < minDepth) {\n    depth = minDepth;\n  }\n  return {\n    depth,\n    maxDepth,\n    minDepth,\n    parentId: getParentId()\n  };\n  function getParentId() {\n    var _newItems$slice$rever;\n    if (depth === 0 || !previousItem) {\n      return null;\n    }\n    if (depth <= previousItem.depth) {\n      return previousItem.parentId;\n    }\n    if (depth > previousItem.depth) {\n      return previousItem.id;\n    }\n    const newParent = (_newItems$slice$rever = newItems.slice(0, overItemIndex).reverse().find(item => item.depth === depth)) === null || _newItems$slice$rever === void 0 ? void 0 : _newItems$slice$rever.parentId;\n    return newParent !== null && newParent !== void 0 ? newParent : null;\n  }\n}\nfunction getMaxDepth({\n  previousItem\n}) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname((previousItem === null || previousItem === void 0 ? void 0 : previousItem.data) || {});\n  if (previousItem) {\n    var _previousItem$data, _previousItem$data$bl;\n    return isArray((_previousItem$data = previousItem.data) === null || _previousItem$data === void 0 ? void 0 : (_previousItem$data$bl = _previousItem$data[blocksLayoutFieldname]) === null || _previousItem$data$bl === void 0 ? void 0 : _previousItem$data$bl.items) ? previousItem.depth + 1 : previousItem.depth;\n  }\n  return 0;\n}\nfunction getMinDepth({\n  nextItem\n}) {\n  if (nextItem) {\n    return nextItem.depth;\n  }\n  return 0;\n}\nfunction flatten(items = [], parentId = null, depth = 0) {\n  return items.reduce((acc, item, index) => {\n    return [...acc, _objectSpread(_objectSpread({}, item), {}, {\n      parentId,\n      depth,\n      index\n    }), ...flatten(item.children, item.id, depth + 1)];\n  }, []);\n}\nexport function flattenTree(items) {\n  return flatten(items);\n}\nexport function findItem(items, itemId) {\n  return items.find(({\n    id\n  }) => id === itemId);\n}\nexport function removeChildrenOf(items, ids) {\n  const excludeParentIds = [...ids];\n  return items.filter(item => {\n    if (item.parentId && excludeParentIds.includes(item.parentId)) {\n      if (item.children.length) {\n        excludeParentIds.push(item.id);\n      }\n      return false;\n    }\n    return true;\n  });\n}","map":{"version":3,"names":["isArray","getBlocksLayoutFieldname","getDragDepth","offset","indentationWidth","Math","round","getProjection","items","activeId","overId","dragOffset","arrayMove","overItemIndex","findIndex","id","activeItemIndex","activeItem","newItems","previousItem","nextItem","dragDepth","projectedDepth","depth","maxDepth","getMaxDepth","minDepth","getMinDepth","parentId","getParentId","_newItems$slice$rever","newParent","slice","reverse","find","item","blocksLayoutFieldname","data","_previousItem$data","_previousItem$data$bl","flatten","reduce","acc","index","_objectSpread","children","flattenTree","findItem","itemId","removeChildrenOf","ids","excludeParentIds","filter","includes","length","push"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Block/Order/utilities.js"],"sourcesContent":["import isArray from 'lodash/isArray';\n\nimport { getBlocksLayoutFieldname } from '@plone/volto/helpers/Blocks/Blocks';\n\nfunction getDragDepth(offset, indentationWidth) {\n  return Math.round(offset / indentationWidth);\n}\n\nexport function getProjection(\n  items,\n  activeId,\n  overId,\n  dragOffset,\n  indentationWidth,\n  arrayMove,\n) {\n  const overItemIndex = items.findIndex(({ id }) => id === overId);\n  const activeItemIndex = items.findIndex(({ id }) => id === activeId);\n  const activeItem = items[activeItemIndex];\n  const newItems = arrayMove(items, activeItemIndex, overItemIndex);\n  const previousItem = newItems[overItemIndex - 1];\n  const nextItem = newItems[overItemIndex + 1];\n  const dragDepth = getDragDepth(dragOffset, indentationWidth);\n  const projectedDepth = activeItem.depth + dragDepth;\n  const maxDepth = getMaxDepth({\n    previousItem,\n  });\n  const minDepth = getMinDepth({ nextItem });\n  let depth = projectedDepth;\n\n  if (projectedDepth >= maxDepth) {\n    depth = maxDepth;\n  } else if (projectedDepth < minDepth) {\n    depth = minDepth;\n  }\n\n  return { depth, maxDepth, minDepth, parentId: getParentId() };\n\n  function getParentId() {\n    if (depth === 0 || !previousItem) {\n      return null;\n    }\n\n    if (depth <= previousItem.depth) {\n      return previousItem.parentId;\n    }\n\n    if (depth > previousItem.depth) {\n      return previousItem.id;\n    }\n\n    const newParent = newItems\n      .slice(0, overItemIndex)\n      .reverse()\n      .find((item) => item.depth === depth)?.parentId;\n\n    return newParent ?? null;\n  }\n}\n\nfunction getMaxDepth({ previousItem }) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(\n    previousItem?.data || {},\n  );\n  if (previousItem) {\n    return isArray(previousItem.data?.[blocksLayoutFieldname]?.items)\n      ? previousItem.depth + 1\n      : previousItem.depth;\n  }\n\n  return 0;\n}\n\nfunction getMinDepth({ nextItem }) {\n  if (nextItem) {\n    return nextItem.depth;\n  }\n\n  return 0;\n}\n\nfunction flatten(items = [], parentId = null, depth = 0) {\n  return items.reduce((acc, item, index) => {\n    return [\n      ...acc,\n      { ...item, parentId, depth, index },\n      ...flatten(item.children, item.id, depth + 1),\n    ];\n  }, []);\n}\n\nexport function flattenTree(items) {\n  return flatten(items);\n}\n\nexport function findItem(items, itemId) {\n  return items.find(({ id }) => id === itemId);\n}\n\nexport function removeChildrenOf(items, ids) {\n  const excludeParentIds = [...ids];\n\n  return items.filter((item) => {\n    if (item.parentId && excludeParentIds.includes(item.parentId)) {\n      if (item.children.length) {\n        excludeParentIds.push(item.id);\n      }\n      return false;\n    }\n\n    return true;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}