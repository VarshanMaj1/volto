{"ast":null,"code":"import _extends from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/extends.js\";\nimport _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nvar __jsx = React.createElement;\nimport React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\nimport { usePrevious } from '@plone/volto/helpers/Utils/usePrevious';\nimport isEqual from 'lodash/isEqual';\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\nconst SEARCH_ENDPOINT_FIELDS = ['SearchableText', 'b_size', 'limit', 'sort_on', 'sort_order', 'depth'];\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id, sortOnParam, sortOrderParam) {\n  var _data$query, _data$query2, _data$query3, _data$query4, _data$query5, _data$query6;\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = (data === null || data === void 0 ? void 0 : data.facets) || [];\n  return {\n    query: [...(((_data$query = data.query) === null || _data$query === void 0 ? void 0 : _data$query.query) || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    }).filter(f => !!f), ...(urlSearchText ? [{\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: urlSearchText\n    }] : [])],\n    sort_on: sortOnParam || ((_data$query2 = data.query) === null || _data$query2 === void 0 ? void 0 : _data$query2.sort_on),\n    sort_order: sortOrderParam || ((_data$query3 = data.query) === null || _data$query3 === void 0 ? void 0 : _data$query3.sort_order),\n    b_size: (_data$query4 = data.query) === null || _data$query4 === void 0 ? void 0 : _data$query4.b_size,\n    limit: (_data$query5 = data.query) === null || _data$query5 === void 0 ? void 0 : _data$query5.limit,\n    depth: (_data$query6 = data.query) === null || _data$query6 === void 0 ? void 0 : _data$query6.depth,\n    block: id\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query,\n  // base query\n  facets,\n  // facet values\n  id,\n  // block id\n  searchText,\n  // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings // data.facets extracted from block data\n}) {\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  // Here, we are removing the QueryString of the Listing ones, which is present in the Facet\n  // because we already initialize the facet with those values.\n  const configuredFacets = facetSettings ? facetSettings.map(facet => {\n    var _facet$field;\n    return facet === null || facet === void 0 ? void 0 : (_facet$field = facet.field) === null || _facet$field === void 0 ? void 0 : _facet$field.value;\n  }) : [];\n  let copyOfQuery = query.query ? [...query.query] : [];\n  const queryWithoutFacet = copyOfQuery.filter(query => {\n    return !configuredFacets.includes(query.i);\n  });\n  const params = {\n    query: [...(queryWithoutFacet || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    })].filter(o => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    depth: query.depth,\n    block: id\n  };\n\n  // Note Ideally the searchtext functionality should be restructured as being just\n  // another facet. But right now it's the same. This means that if a searchText\n  // is provided, it will override the SearchableText facet.\n  // If there is no searchText, the SearchableText in the query remains in effect.\n  // TODO eventually the searchText should be a distinct facet from SearchableText, and\n  // the two conditions could be combined, in comparison to the current state, when\n  // one overrides the other.\n  if (searchText) {\n    params.query = params.query.reduce(\n    // Remove SearchableText from query\n    (acc, kvp) => kvp.i === 'SearchableText' ? acc : [...acc, kvp], []);\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText\n    });\n  }\n  return params;\n}\nconst getSearchFields = searchData => {\n  return Object.assign({}, ...SEARCH_ENDPOINT_FIELDS.map(k => {\n    return searchData[k] ? {\n      [k]: searchData[k]\n    } : {};\n  }), searchData.query ? {\n    query: serializeQuery(searchData['query'])\n  } : {});\n};\n\n/**\n * A hook that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  _s();\n  const location = useLocation();\n  const history = useHistory();\n\n  /**\n   * Required to maintain parameter compatibility.\n    With this we will maintain support for receiving hash (#) and search (?) type parameters.\n  */\n  const oldState = React.useMemo(() => {\n    return _objectSpread(_objectSpread({}, qs.parse(location.search)), qs.parse(location.hash));\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign({}, ...Array.from(Object.keys(oldState)).map(k => ({\n    [k]: oldState[k]\n  })));\n  const setSearchData = React.useCallback(searchData => {\n    const newParams = qs.parse(location.search);\n    let changed = false;\n    Object.keys(searchData).sort().forEach(k => {\n      if (searchData[k]) {\n        newParams[k] = searchData[k];\n        if (oldState[k] !== searchData[k]) {\n          changed = true;\n        }\n      }\n    });\n    if (changed) {\n      history.push({\n        search: qs.stringify(newParams)\n      });\n    }\n  }, [history, oldState, location.search]);\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\n_s(useHashState, \"RKebonFl10519tdQ2E8Tb9qO30c=\", false, function () {\n  return [useLocation, useHistory];\n});\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  _s2();\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n  return isEditMode ? [internalState, setInternalState] : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\n_s2(useSearchBlockState, \"64MUY7jQ4c8NOtDIu0I8w22Ik4A=\", false, function () {\n  return [useHashState];\n});\nconst deserializeQuery = q => {\n  var _JSON$parse;\n  return (_JSON$parse = JSON.parse(q)) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(/^paqo/, PAQO)\n  }));\n};\nconst serializeQuery = q => {\n  return JSON.stringify(q === null || q === void 0 ? void 0 : q.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(PAQO, 'paqo')\n  })));\n};\nconst withSearch = options => WrappedComponent => {\n  var _s3 = $RefreshSig$();\n  const {\n    inputDelay = 1000\n  } = options || {};\n  function WithSearch(props) {\n    _s3();\n    var _urlQuery$find, _data$facets, _data$query7, _data$query8, _data$facets2, _data$query9, _data$query10, _querystringResults$i, _querystringResults$i2, _querystringResults$i3;\n    const {\n      data,\n      id,\n      editable = false\n    } = props;\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(id, editable);\n\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const urlQuery = locationSearchData.query ? deserializeQuery(locationSearchData.query) : [];\n    const urlSearchText = locationSearchData.SearchableText || ((_urlQuery$find = urlQuery.find(({\n      i\n    }) => i === 'SearchableText')) === null || _urlQuery$find === void 0 ? void 0 : _urlQuery$find.v) || '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const configuredFacets = ((_data$facets = data.facets) === null || _data$facets === void 0 ? void 0 : _data$facets.map(facet => {\n      var _facet$field2;\n      return facet === null || facet === void 0 ? void 0 : (_facet$field2 = facet.field) === null || _facet$field2 === void 0 ? void 0 : _facet$field2.value;\n    })) || [];\n\n    // Here we are getting the initial value of the facet if Listing Query contains the same criteria as\n    // facet.\n    const queryData = data !== null && data !== void 0 && (_data$query7 = data.query) !== null && _data$query7 !== void 0 && _data$query7.query ? deserializeQuery(JSON.stringify(data === null || data === void 0 ? void 0 : (_data$query8 = data.query) === null || _data$query8 === void 0 ? void 0 : _data$query8.query)) : [];\n    let intializeFacetWithQueryValue = [];\n    for (let value of configuredFacets) {\n      const queryString = queryData.find(item => item.i === value);\n      if (queryString) {\n        intializeFacetWithQueryValue = [...intializeFacetWithQueryValue, {\n          [queryString.i]: queryString.v\n        }];\n      }\n    }\n    const multiFacets = (_data$facets2 = data.facets) === null || _data$facets2 === void 0 ? void 0 : _data$facets2.filter(facet => facet === null || facet === void 0 ? void 0 : facet.multiple).map(facet => {\n      var _facet$field3;\n      return facet === null || facet === void 0 ? void 0 : (_facet$field3 = facet.field) === null || _facet$field3 === void 0 ? void 0 : _facet$field3.value;\n    });\n    const [facets, setFacets] = React.useState(Object.assign({}, ...urlQuery.map(({\n      i,\n      v\n    }) => ({\n      [i]: v\n    })),\n    // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n    ...intializeFacetWithQueryValue,\n    // support for simple filters like ?Subject=something\n    // TODO: since the move to hash params this is no longer working.\n    // We'd have to treat the location.search and manage it just like the\n    // hash, to support it. We can read it, but we'd have to reset it as\n    // well, so at that point what's the difference to the hash?\n    ...configuredFacets.map(f => locationSearchData[f] ? {\n      [f]: multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]\n    } : {})));\n    const previousUrlQuery = usePrevious(urlQuery);\n\n    // During first render the previousUrlQuery is undefined and urlQuery\n    // is empty so it resetting the facet when you are navigating but during reload we have urlQuery and we need\n    // to set the facet at first render.\n    const preventOverrideOfFacetState = previousUrlQuery === undefined && urlQuery.length === 0;\n    React.useEffect(() => {\n      if (!isEqual(urlQuery, previousUrlQuery) && !preventOverrideOfFacetState) {\n        setFacets(Object.assign({}, ...urlQuery.map(({\n          i,\n          v\n        }) => ({\n          [i]: v\n        })),\n        // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map(f => locationSearchData[f] ? {\n          [f]: multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]\n        } : {})));\n      }\n    }, [urlQuery, configuredFacets, locationSearchData, multiFacets, previousUrlQuery, preventOverrideOfFacetState]);\n    const [sortOn, setSortOn] = React.useState(data === null || data === void 0 ? void 0 : (_data$query9 = data.query) === null || _data$query9 === void 0 ? void 0 : _data$query9.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data === null || data === void 0 ? void 0 : (_data$query10 = data.query) === null || _data$query10 === void 0 ? void 0 : _data$query10.sort_order);\n    const [searchData, setSearchData] = React.useState(getInitialState(data, facets, urlSearchText, id));\n    const deepFacets = JSON.stringify(facets);\n    const deepData = JSON.stringify(data);\n    React.useEffect(() => {\n      setSearchData(getInitialState(JSON.parse(deepData), JSON.parse(deepFacets), urlSearchText, id, sortOn, sortOrder));\n    }, [deepData, deepFacets, urlSearchText, id, sortOn, sortOrder]);\n    const timeoutRef = React.useRef();\n    const facetSettings = data === null || data === void 0 ? void 0 : data.facets;\n    const deepQuery = JSON.stringify(data.query);\n    const onTriggerSearch = React.useCallback((toSearchText = undefined, toSearchFacets = undefined, toSortOn = undefined, toSortOrder = undefined) => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => {\n        const newSearchData = normalizeState({\n          id,\n          query: data.query || {},\n          facets: toSearchFacets || facets,\n          searchText: toSearchText ? toSearchText.trim() : '',\n          sortOn: toSortOn || undefined,\n          sortOrder: toSortOrder || sortOrder,\n          facetSettings\n        });\n        if (toSearchFacets) setFacets(toSearchFacets);\n        if (toSortOn) setSortOn(toSortOn || undefined);\n        if (toSortOrder) setSortOrder(toSortOrder);\n        setSearchData(newSearchData);\n        setLocationSearchData(getSearchFields(newSearchData));\n      }, toSearchFacets ? inputDelay / 3 : inputDelay);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n    // Use deep comparison of data.query\n    deepQuery, facets, id, setLocationSearchData, searchText, sortOn, sortOrder, facetSettings]);\n    const removeSearchQuery = () => {\n      let newSearchData = _objectSpread({}, searchData);\n      newSearchData.query = searchData.query.reduce(\n      // Remove SearchableText from query\n      (acc, kvp) => kvp.i === 'SearchableText' ? acc : [...acc, kvp], []);\n      setSearchData(newSearchData);\n      setLocationSearchData(getSearchFields(newSearchData));\n    };\n    const querystringResults = useSelector(state => state.querystringsearch.subrequests);\n    const totalItems = ((_querystringResults$i = querystringResults[id]) === null || _querystringResults$i === void 0 ? void 0 : _querystringResults$i.total) || ((_querystringResults$i2 = querystringResults[id]) === null || _querystringResults$i2 === void 0 ? void 0 : (_querystringResults$i3 = _querystringResults$i2.items) === null || _querystringResults$i3 === void 0 ? void 0 : _querystringResults$i3.length);\n    return __jsx(WrappedComponent, _extends({}, props, {\n      searchData: searchData,\n      facets: facets,\n      setFacets: setFacets,\n      setSortOn: setSortOn,\n      setSortOrder: setSortOrder,\n      sortOn: sortOn,\n      sortOrder: sortOrder,\n      searchedText: urlSearchText,\n      searchText: searchText,\n      removeSearchQuery: removeSearchQuery,\n      setSearchText: setSearchText,\n      onTriggerSearch: onTriggerSearch,\n      totalItems: totalItems,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 455,\n        columnNumber: 7\n      }\n    }));\n  }\n  _s3(WithSearch, \"jqWJ0Tqn9OY/RhtEt3nuTz0NBDg=\", false, function () {\n    return [useSearchBlockState, usePrevious, useSelector];\n  });\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n  return WithSearch;\n};\nexport default withSearch;","map":{"version":3,"names":["React","useSelector","qs","useLocation","useHistory","resolveExtension","config","usePrevious","isEqual","getDisplayName","WrappedComponent","displayName","name","SEARCH_ENDPOINT_FIELDS","PAQO","getInitialState","data","facets","urlSearchText","id","sortOnParam","sortOrderParam","_data$query","_data$query2","_data$query3","_data$query4","_data$query5","_data$query6","types","facetWidgetTypes","blocks","blocksConfig","search","extensions","facetWidgets","facetSettings","query","map","facet","field","valueToQuery","value","filter","f","i","o","v","sort_on","sort_order","b_size","limit","depth","block","normalizeState","searchText","sortOn","sortOrder","configuredFacets","_facet$field","copyOfQuery","queryWithoutFacet","includes","params","reduce","acc","kvp","push","getSearchFields","searchData","Object","assign","k","serializeQuery","useHashState","_s","location","history","oldState","useMemo","_objectSpread","parse","hash","current","Array","from","keys","setSearchData","useCallback","newParams","changed","sort","forEach","stringify","useSearchBlockState","uniqueId","isEditMode","_s2","hashState","setHashState","internalState","setInternalState","useState","deserializeQuery","q","_JSON$parse","JSON","replace","withSearch","options","_s3","$RefreshSig$","inputDelay","WithSearch","props","_urlQuery$find","_data$facets","_data$query7","_data$query8","_data$facets2","_data$query9","_data$query10","_querystringResults$i","_querystringResults$i2","_querystringResults$i3","editable","locationSearchData","setLocationSearchData","urlQuery","SearchableText","find","setSearchText","_facet$field2","queryData","intializeFacetWithQueryValue","queryString","item","multiFacets","multiple","_facet$field3","setFacets","indexOf","previousUrlQuery","preventOverrideOfFacetState","undefined","length","useEffect","setSortOn","setSortOrder","deepFacets","deepData","timeoutRef","useRef","deepQuery","onTriggerSearch","toSearchText","toSearchFacets","toSortOn","toSortOrder","clearTimeout","setTimeout","newSearchData","trim","removeSearchQuery","querystringResults","state","querystringsearch","subrequests","totalItems","total","items","__jsx","_extends","searchedText","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx"],"sourcesContent":["import React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\n\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\nimport { usePrevious } from '@plone/volto/helpers/Utils/usePrevious';\nimport isEqual from 'lodash/isEqual';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst SEARCH_ENDPOINT_FIELDS = [\n  'SearchableText',\n  'b_size',\n  'limit',\n  'sort_on',\n  'sort_order',\n  'depth',\n];\n\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(\n  data,\n  facets,\n  urlSearchText,\n  id,\n  sortOnParam,\n  sortOrderParam,\n) {\n  const { types: facetWidgetTypes } =\n    config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = data?.facets || [];\n\n  return {\n    query: [\n      ...(data.query?.query || []),\n      ...(facetSettings || [])\n        .map((facet) => {\n          if (!facet?.field) return null;\n\n          const { valueToQuery } = resolveExtension(\n            'type',\n            facetWidgetTypes,\n            facet,\n          );\n\n          const name = facet.field.value;\n          const value = facets[name];\n\n          return valueToQuery({ value, facet });\n        })\n        .filter((f) => !!f),\n      ...(urlSearchText\n        ? [\n            {\n              i: 'SearchableText',\n              o: 'plone.app.querystring.operation.string.contains',\n              v: urlSearchText,\n            },\n          ]\n        : []),\n    ],\n    sort_on: sortOnParam || data.query?.sort_on,\n    sort_order: sortOrderParam || data.query?.sort_order,\n    b_size: data.query?.b_size,\n    limit: data.query?.limit,\n    depth: data.query?.depth,\n    block: id,\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query, // base query\n  facets, // facet values\n  id, // block id\n  searchText, // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings, // data.facets extracted from block data\n}) {\n  const { types: facetWidgetTypes } =\n    config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  // Here, we are removing the QueryString of the Listing ones, which is present in the Facet\n  // because we already initialize the facet with those values.\n  const configuredFacets = facetSettings\n    ? facetSettings.map((facet) => facet?.field?.value)\n    : [];\n\n  let copyOfQuery = query.query ? [...query.query] : [];\n\n  const queryWithoutFacet = copyOfQuery.filter((query) => {\n    return !configuredFacets.includes(query.i);\n  });\n\n  const params = {\n    query: [\n      ...(queryWithoutFacet || []),\n      ...(facetSettings || []).map((facet) => {\n        if (!facet?.field) return null;\n\n        const { valueToQuery } = resolveExtension(\n          'type',\n          facetWidgetTypes,\n          facet,\n        );\n\n        const name = facet.field.value;\n        const value = facets[name];\n\n        return valueToQuery({ value, facet });\n      }),\n    ].filter((o) => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    depth: query.depth,\n    block: id,\n  };\n\n  // Note Ideally the searchtext functionality should be restructured as being just\n  // another facet. But right now it's the same. This means that if a searchText\n  // is provided, it will override the SearchableText facet.\n  // If there is no searchText, the SearchableText in the query remains in effect.\n  // TODO eventually the searchText should be a distinct facet from SearchableText, and\n  // the two conditions could be combined, in comparison to the current state, when\n  // one overrides the other.\n  if (searchText) {\n    params.query = params.query.reduce(\n      // Remove SearchableText from query\n      (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n      [],\n    );\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText,\n    });\n  }\n\n  return params;\n}\n\nconst getSearchFields = (searchData) => {\n  return Object.assign(\n    {},\n    ...SEARCH_ENDPOINT_FIELDS.map((k) => {\n      return searchData[k] ? { [k]: searchData[k] } : {};\n    }),\n    searchData.query ? { query: serializeQuery(searchData['query']) } : {},\n  );\n};\n\n/**\n * A hook that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n\n  /**\n   * Required to maintain parameter compatibility.\n    With this we will maintain support for receiving hash (#) and search (?) type parameters.\n  */\n  const oldState = React.useMemo(() => {\n    return {\n      ...qs.parse(location.search),\n      ...qs.parse(location.hash),\n    };\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign(\n    {},\n    ...Array.from(Object.keys(oldState)).map((k) => ({ [k]: oldState[k] })),\n  );\n\n  const setSearchData = React.useCallback(\n    (searchData) => {\n      const newParams = qs.parse(location.search);\n\n      let changed = false;\n\n      Object.keys(searchData)\n        .sort()\n        .forEach((k) => {\n          if (searchData[k]) {\n            newParams[k] = searchData[k];\n            if (oldState[k] !== searchData[k]) {\n              changed = true;\n            }\n          }\n        });\n\n      if (changed) {\n        history.push({\n          search: qs.stringify(newParams),\n        });\n      }\n    },\n    [history, oldState, location.search],\n  );\n\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n\n  return isEditMode\n    ? [internalState, setInternalState]\n    : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = (q) => {\n  return JSON.parse(q)?.map((kvp) => ({\n    ...kvp,\n    o: kvp.o.replace(/^paqo/, PAQO),\n  }));\n};\nconst serializeQuery = (q) => {\n  return JSON.stringify(\n    q?.map((kvp) => ({ ...kvp, o: kvp.o.replace(PAQO, 'paqo') })),\n  );\n};\n\nconst withSearch = (options) => (WrappedComponent) => {\n  const { inputDelay = 1000 } = options || {};\n\n  function WithSearch(props) {\n    const { data, id, editable = false } = props;\n\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(\n      id,\n      editable,\n    );\n\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const urlQuery = locationSearchData.query\n      ? deserializeQuery(locationSearchData.query)\n      : [];\n    const urlSearchText =\n      locationSearchData.SearchableText ||\n      urlQuery.find(({ i }) => i === 'SearchableText')?.v ||\n      '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const configuredFacets =\n      data.facets?.map((facet) => facet?.field?.value) || [];\n\n    // Here we are getting the initial value of the facet if Listing Query contains the same criteria as\n    // facet.\n    const queryData = data?.query?.query\n      ? deserializeQuery(JSON.stringify(data?.query?.query))\n      : [];\n\n    let intializeFacetWithQueryValue = [];\n\n    for (let value of configuredFacets) {\n      const queryString = queryData.find((item) => item.i === value);\n      if (queryString) {\n        intializeFacetWithQueryValue = [\n          ...intializeFacetWithQueryValue,\n          { [queryString.i]: queryString.v },\n        ];\n      }\n    }\n\n    const multiFacets = data.facets\n      ?.filter((facet) => facet?.multiple)\n      .map((facet) => facet?.field?.value);\n    const [facets, setFacets] = React.useState(\n      Object.assign(\n        {},\n        ...urlQuery.map(({ i, v }) => ({ [i]: v })),\n        // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n        ...intializeFacetWithQueryValue,\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map((f) =>\n          locationSearchData[f]\n            ? {\n                [f]:\n                  multiFacets.indexOf(f) > -1\n                    ? [locationSearchData[f]]\n                    : locationSearchData[f],\n              }\n            : {},\n        ),\n      ),\n    );\n    const previousUrlQuery = usePrevious(urlQuery);\n\n    // During first render the previousUrlQuery is undefined and urlQuery\n    // is empty so it resetting the facet when you are navigating but during reload we have urlQuery and we need\n    // to set the facet at first render.\n    const preventOverrideOfFacetState =\n      previousUrlQuery === undefined && urlQuery.length === 0;\n\n    React.useEffect(() => {\n      if (\n        !isEqual(urlQuery, previousUrlQuery) &&\n        !preventOverrideOfFacetState\n      ) {\n        setFacets(\n          Object.assign(\n            {},\n            ...urlQuery.map(({ i, v }) => ({ [i]: v })), // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n            // support for simple filters like ?Subject=something\n            // TODO: since the move to hash params this is no longer working.\n            // We'd have to treat the location.search and manage it just like the\n            // hash, to support it. We can read it, but we'd have to reset it as\n            // well, so at that point what's the difference to the hash?\n            ...configuredFacets.map((f) =>\n              locationSearchData[f]\n                ? {\n                    [f]:\n                      multiFacets.indexOf(f) > -1\n                        ? [locationSearchData[f]]\n                        : locationSearchData[f],\n                  }\n                : {},\n            ),\n          ),\n        );\n      }\n    }, [\n      urlQuery,\n      configuredFacets,\n      locationSearchData,\n      multiFacets,\n      previousUrlQuery,\n      preventOverrideOfFacetState,\n    ]);\n\n    const [sortOn, setSortOn] = React.useState(data?.query?.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data?.query?.sort_order);\n\n    const [searchData, setSearchData] = React.useState(\n      getInitialState(data, facets, urlSearchText, id),\n    );\n\n    const deepFacets = JSON.stringify(facets);\n    const deepData = JSON.stringify(data);\n    React.useEffect(() => {\n      setSearchData(\n        getInitialState(\n          JSON.parse(deepData),\n          JSON.parse(deepFacets),\n          urlSearchText,\n          id,\n          sortOn,\n          sortOrder,\n        ),\n      );\n    }, [deepData, deepFacets, urlSearchText, id, sortOn, sortOrder]);\n\n    const timeoutRef = React.useRef();\n    const facetSettings = data?.facets;\n\n    const deepQuery = JSON.stringify(data.query);\n    const onTriggerSearch = React.useCallback(\n      (\n        toSearchText = undefined,\n        toSearchFacets = undefined,\n        toSortOn = undefined,\n        toSortOrder = undefined,\n      ) => {\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(\n          () => {\n            const newSearchData = normalizeState({\n              id,\n              query: data.query || {},\n              facets: toSearchFacets || facets,\n              searchText: toSearchText ? toSearchText.trim() : '',\n              sortOn: toSortOn || undefined,\n              sortOrder: toSortOrder || sortOrder,\n              facetSettings,\n            });\n            if (toSearchFacets) setFacets(toSearchFacets);\n            if (toSortOn) setSortOn(toSortOn || undefined);\n            if (toSortOrder) setSortOrder(toSortOrder);\n            setSearchData(newSearchData);\n            setLocationSearchData(getSearchFields(newSearchData));\n          },\n          toSearchFacets ? inputDelay / 3 : inputDelay,\n        );\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [\n        // Use deep comparison of data.query\n        deepQuery,\n        facets,\n        id,\n        setLocationSearchData,\n        searchText,\n        sortOn,\n        sortOrder,\n        facetSettings,\n      ],\n    );\n\n    const removeSearchQuery = () => {\n      let newSearchData = { ...searchData };\n      newSearchData.query = searchData.query.reduce(\n        // Remove SearchableText from query\n        (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n        [],\n      );\n      setSearchData(newSearchData);\n      setLocationSearchData(getSearchFields(newSearchData));\n    };\n\n    const querystringResults = useSelector(\n      (state) => state.querystringsearch.subrequests,\n    );\n    const totalItems =\n      querystringResults[id]?.total || querystringResults[id]?.items?.length;\n\n    return (\n      <WrappedComponent\n        {...props}\n        searchData={searchData}\n        facets={facets}\n        setFacets={setFacets}\n        setSortOn={setSortOn}\n        setSortOrder={setSortOrder}\n        sortOn={sortOn}\n        sortOrder={sortOrder}\n        searchedText={urlSearchText}\n        searchText={searchText}\n        removeSearchQuery={removeSearchQuery}\n        setSearchText={setSearchText}\n        onTriggerSearch={onTriggerSearch}\n        totalItems={totalItems}\n      />\n    );\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n\n  return WithSearch;\n};\n\nexport default withSearch;\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}