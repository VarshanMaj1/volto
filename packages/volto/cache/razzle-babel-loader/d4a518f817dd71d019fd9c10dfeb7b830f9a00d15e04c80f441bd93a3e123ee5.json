{"ast":null,"code":"const _excluded = [\"reduxConnectStore\"],\n  _excluded2 = [\"context\"];\nvar _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/AsyncConnect/AsyncConnect.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location\n    };\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded();\n\n    // we dont need it if we already made it on server-side\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const {\n      location,\n      reloadOnPropsChange\n    } = this.props;\n    const navigated = location !== nextProps.location;\n\n    // Allow a user supplied function to determine if an async reload is necessary\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n  isLoaded() {\n    const {\n      reduxConnectStore\n    } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect.loaded;\n  }\n  loadAsyncData(_ref) {\n    let {\n        reduxConnectStore\n      } = _ref,\n      otherProps = _objectWithoutProperties(_ref, _excluded);\n    const {\n      location,\n      beginGlobalLoad,\n      endGlobalLoad\n    } = this.props;\n    const loadResult = loadAsyncConnect(_objectSpread(_objectSpread({}, otherProps), {}, {\n      store: reduxConnectStore\n    }));\n    this.setState({\n      previousLocation: location\n    });\n\n    // TODO: think of a better solution to a problem?\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return (loadDataCounterOriginal => loadResult.then(() => {\n      // We need to change propsToShow only if loadAsyncData that called this promise\n      // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n      // when user is changing route several times and we finally show him route that has\n      // loaded props last time and not the last called route\n      if (this.loadDataCounter === loadDataCounterOriginal && this.mounted !== false) {\n        this.setState({\n          previousLocation: null\n        });\n      }\n\n      // TODO: investigate race conditions\n      // do we need to call this if it's not last invocation?\n      endGlobalLoad();\n    }))(this.loadDataCounter);\n  }\n  render() {\n    const {\n      previousLocation\n    } = this.state;\n    const {\n      location,\n      render\n    } = this.props;\n    return __jsx(Route, {\n      location: previousLocation || location,\n      render: () => render(this.props),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89,\n        columnNumber: 7\n      }\n    });\n  }\n}\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired\n};\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange() {\n    return true;\n  },\n  render({\n    routes\n  }) {\n    return renderRoutes(routes);\n  }\n};\nexport const AsyncConnectWithContext = _ref2 => {\n  let {\n      context\n    } = _ref2,\n    otherProps = _objectWithoutProperties(_ref2, _excluded2);\n  const Context = context || ReactReduxContext;\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n  return __jsx(Context.Consumer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 5\n    }\n  }, ({\n    store: reduxConnectStore\n  }) => __jsx(AsyncConnect, _extends({\n    reduxConnectStore: reduxConnectStore\n  }, otherProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 9\n    }\n  })));\n};\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object\n};","map":{"version":3,"names":["React","Component","PropTypes","Route","renderRoutes","ReactReduxContext","loadAsyncConnect","getMutableState","AsyncConnect","constructor","props","state","previousLocation","isLoaded","location","mounted","loadDataCounter","componentDidMount","dataLoaded","loadAsyncData","UNSAFE_componentWillReceiveProps","nextProps","reloadOnPropsChange","navigated","componentWillUnmount","reduxConnectStore","getState","reduxAsyncConnect","loaded","_ref","otherProps","_objectWithoutProperties","_excluded","beginGlobalLoad","endGlobalLoad","loadResult","_objectSpread","store","setState","loadDataCounterOriginal","then","render","__jsx","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","propTypes","func","isRequired","routes","array","object","match","helpers","any","defaultProps","AsyncConnectWithContext","_ref2","context","_excluded2","Context","Error","Consumer","_extends"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/AsyncConnect/AsyncConnect.jsx"],"sourcesContent":["/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\n\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location,\n    };\n\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded();\n\n    // we dont need it if we already made it on server-side\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const { location, reloadOnPropsChange } = this.props;\n    const navigated = location !== nextProps.location;\n\n    // Allow a user supplied function to determine if an async reload is necessary\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  isLoaded() {\n    const { reduxConnectStore } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect\n      .loaded;\n  }\n\n  loadAsyncData({ reduxConnectStore, ...otherProps }) {\n    const { location, beginGlobalLoad, endGlobalLoad } = this.props;\n    const loadResult = loadAsyncConnect({\n      ...otherProps,\n      store: reduxConnectStore,\n    });\n\n    this.setState({ previousLocation: location });\n\n    // TODO: think of a better solution to a problem?\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return ((loadDataCounterOriginal) =>\n      loadResult.then(() => {\n        // We need to change propsToShow only if loadAsyncData that called this promise\n        // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n        // when user is changing route several times and we finally show him route that has\n        // loaded props last time and not the last called route\n        if (\n          this.loadDataCounter === loadDataCounterOriginal &&\n          this.mounted !== false\n        ) {\n          this.setState({ previousLocation: null });\n        }\n\n        // TODO: investigate race conditions\n        // do we need to call this if it's not last invocation?\n        endGlobalLoad();\n      }))(this.loadDataCounter);\n  }\n\n  render() {\n    const { previousLocation } = this.state;\n    const { location, render } = this.props;\n\n    return (\n      <Route\n        location={previousLocation || location}\n        render={() => render(this.props)}\n      />\n    );\n  }\n}\n\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired,\n};\n\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange() {\n    return true;\n  },\n  render({ routes }) {\n    return renderRoutes(routes);\n  },\n};\n\nexport const AsyncConnectWithContext = ({ context, ...otherProps }) => {\n  const Context = context || ReactReduxContext;\n\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n\n  return (\n    <Context.Consumer>\n      {({ store: reduxConnectStore }) => (\n        <AsyncConnect reduxConnectStore={reduxConnectStore} {...otherProps} />\n      )}\n    </Context.Consumer>\n  );\n};\n\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}