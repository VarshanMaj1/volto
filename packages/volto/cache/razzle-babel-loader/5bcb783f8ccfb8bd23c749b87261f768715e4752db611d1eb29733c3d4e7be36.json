{"ast":null,"code":"import ReactDOM from 'react-dom';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport { getPreviousVoltoBlock, getNextVoltoBlock, mergeSlateWithBlockBackward, mergeSlateWithBlockForward } from '@plone/volto-slate/utils/volto-blocks';\nimport { isCursorAtBlockStart, isCursorAtBlockEnd } from '@plone/volto-slate/utils/selection';\nimport { makeEditor } from '@plone/volto-slate/utils/editor';\nimport { changeBlock, deleteBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers/Blocks/Blocks';\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock({\n  editor,\n  event\n}, intl) {\n  if (!isCursorAtBlockStart(editor)) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField\n  } = blockProps;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev;\n\n  // Don't join with required blocks\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  const text = Editor.string(editor, []);\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block, intl);\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n      onSelectBlock(otherBlockId);\n    });\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate',\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  const newFormData = deleteBlock(formData, block, intl);\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock({\n  editor,\n  event\n}, intl) {\n  if (!isCursorAtBlockEnd(editor)) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data\n  } = blockProps;\n  const {\n    properties,\n    onChangeField\n  } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties);\n\n  // Don't join with required blocks\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  const newFormData = deleteBlock(formData, block, intl);\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  const {\n    value\n  } = block;\n  const location = [value.length - 1]; // adress of root node\n  const editor = {\n    children: value\n  };\n  const newEditor = makeEditor();\n  newEditor.children = cloneDeep(editor.children);\n  const path = Editor.last(newEditor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  const [leaf, leafpath] = Editor.leaf(newEditor, path);\n  // The offset of the Points in the collapsed Range computed below:\n  const offset = (leaf.text || '').length;\n  return {\n    anchor: {\n      path: leafpath,\n      offset\n    },\n    focus: {\n      path: leafpath,\n      offset\n    }\n  };\n}","map":{"version":3,"names":["ReactDOM","cloneDeep","serializeNodesToText","Editor","getPreviousVoltoBlock","getNextVoltoBlock","mergeSlateWithBlockBackward","mergeSlateWithBlockForward","isCursorAtBlockStart","isCursorAtBlockEnd","makeEditor","changeBlock","deleteBlock","getBlocksFieldname","getBlocksLayoutFieldname","joinWithPreviousBlock","editor","event","intl","blockProps","getBlockProps","block","index","saveSlateBlockSelection","onSelectBlock","data","properties","onChangeField","blocksFieldname","blocksLayoutFieldname","prev","otherBlock","otherBlockId","required","stopPropagation","preventDefault","text","string","cursor","getBlockEndAsRange","newFormData","unstable_batchedUpdates","combined","JSON","parse","stringify","children","formData","value","plaintext","joinWithNextBlock","location","length","newEditor","path","last","leaf","leafpath","offset","anchor","focus"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/blocks/Text/keyboard/joinBlocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport {\n  getPreviousVoltoBlock,\n  getNextVoltoBlock,\n  mergeSlateWithBlockBackward,\n  mergeSlateWithBlockForward,\n} from '@plone/volto-slate/utils/volto-blocks';\nimport {\n  isCursorAtBlockStart,\n  isCursorAtBlockEnd,\n} from '@plone/volto-slate/utils/selection';\nimport { makeEditor } from '@plone/volto-slate/utils/editor';\nimport {\n  changeBlock,\n  deleteBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers/Blocks/Blocks';\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock({ editor, event }, intl) {\n  if (!isCursorAtBlockStart(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField,\n  } = blockProps;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev;\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  const text = Editor.string(editor, []);\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block, intl);\n\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n\n      onSelectBlock(otherBlockId);\n    });\n\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate', // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block, intl);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock({ editor, event }, intl) {\n  if (!isCursorAtBlockEnd(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n  } = blockProps;\n\n  const { properties, onChangeField } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties);\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block, intl);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  const { value } = block;\n  const location = [value.length - 1]; // adress of root node\n  const editor = { children: value };\n  const newEditor = makeEditor();\n  newEditor.children = cloneDeep(editor.children);\n  const path = Editor.last(newEditor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  const [leaf, leafpath] = Editor.leaf(newEditor, path);\n  // The offset of the Points in the collapsed Range computed below:\n  const offset = (leaf.text || '').length;\n\n  return {\n    anchor: { path: leafpath, offset },\n    focus: { path: leafpath, offset },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}