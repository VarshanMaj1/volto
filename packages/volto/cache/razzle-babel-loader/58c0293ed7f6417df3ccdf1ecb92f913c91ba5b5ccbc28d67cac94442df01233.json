{"ast":null,"code":"var _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\nimport { usePrevious } from '@plone/volto/helpers/Utils/usePrevious';\nimport isEqual from 'lodash/isEqual';\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\nconst SEARCH_ENDPOINT_FIELDS = ['SearchableText', 'b_size', 'limit', 'sort_on', 'sort_order', 'depth'];\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id, sortOnParam, sortOrderParam) {\n  var _data$query, _data$query2, _data$query3, _data$query4, _data$query5, _data$query6;\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = (data === null || data === void 0 ? void 0 : data.facets) || [];\n  return {\n    query: [...(((_data$query = data.query) === null || _data$query === void 0 ? void 0 : _data$query.query) || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    }).filter(f => !!f), ...(urlSearchText ? [{\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: urlSearchText\n    }] : [])],\n    sort_on: sortOnParam || ((_data$query2 = data.query) === null || _data$query2 === void 0 ? void 0 : _data$query2.sort_on),\n    sort_order: sortOrderParam || ((_data$query3 = data.query) === null || _data$query3 === void 0 ? void 0 : _data$query3.sort_order),\n    b_size: (_data$query4 = data.query) === null || _data$query4 === void 0 ? void 0 : _data$query4.b_size,\n    limit: (_data$query5 = data.query) === null || _data$query5 === void 0 ? void 0 : _data$query5.limit,\n    depth: (_data$query6 = data.query) === null || _data$query6 === void 0 ? void 0 : _data$query6.depth,\n    block: id\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query,\n  // base query\n  facets,\n  // facet values\n  id,\n  // block id\n  searchText,\n  // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings // data.facets extracted from block data\n}) {\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  // Here, we are removing the QueryString of the Listing ones, which is present in the Facet\n  // because we already initialize the facet with those values.\n  const configuredFacets = facetSettings ? facetSettings.map(facet => {\n    var _facet$field;\n    return facet === null || facet === void 0 ? void 0 : (_facet$field = facet.field) === null || _facet$field === void 0 ? void 0 : _facet$field.value;\n  }) : [];\n  let copyOfQuery = query.query ? [...query.query] : [];\n  const queryWithoutFacet = copyOfQuery.filter(query => {\n    return !configuredFacets.includes(query.i);\n  });\n  const params = {\n    query: [...(queryWithoutFacet || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    })].filter(o => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    depth: query.depth,\n    block: id\n  };\n\n  // Note Ideally the searchtext functionality should be restructured as being just\n  // another facet. But right now it's the same. This means that if a searchText\n  // is provided, it will override the SearchableText facet.\n  // If there is no searchText, the SearchableText in the query remains in effect.\n  // TODO eventually the searchText should be a distinct facet from SearchableText, and\n  // the two conditions could be combined, in comparison to the current state, when\n  // one overrides the other.\n  if (searchText) {\n    params.query = params.query.reduce(\n    // Remove SearchableText from query\n    (acc, kvp) => kvp.i === 'SearchableText' ? acc : [...acc, kvp], []);\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText\n    });\n  }\n  return params;\n}\nconst getSearchFields = searchData => {\n  return Object.assign({}, ...SEARCH_ENDPOINT_FIELDS.map(k => {\n    return searchData[k] ? {\n      [k]: searchData[k]\n    } : {};\n  }), searchData.query ? {\n    query: serializeQuery(searchData['query'])\n  } : {});\n};\n\n/**\n * A hook that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n\n  /**\n   * Required to maintain parameter compatibility.\n    With this we will maintain support for receiving hash (#) and search (?) type parameters.\n  */\n  const oldState = React.useMemo(() => {\n    return _objectSpread(_objectSpread({}, qs.parse(location.search)), qs.parse(location.hash));\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign({}, ...Array.from(Object.keys(oldState)).map(k => ({\n    [k]: oldState[k]\n  })));\n  const setSearchData = React.useCallback(searchData => {\n    const newParams = qs.parse(location.search);\n    let changed = false;\n    Object.keys(searchData).sort().forEach(k => {\n      if (searchData[k]) {\n        newParams[k] = searchData[k];\n        if (oldState[k] !== searchData[k]) {\n          changed = true;\n        }\n      }\n    });\n    if (changed) {\n      history.push({\n        search: qs.stringify(newParams)\n      });\n    }\n  }, [history, oldState, location.search]);\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n  return isEditMode ? [internalState, setInternalState] : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = q => {\n  var _JSON$parse;\n  return (_JSON$parse = JSON.parse(q)) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(/^paqo/, PAQO)\n  }));\n};\nconst serializeQuery = q => {\n  return JSON.stringify(q === null || q === void 0 ? void 0 : q.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(PAQO, 'paqo')\n  })));\n};\nconst withSearch = options => WrappedComponent => {\n  const {\n    inputDelay = 1000\n  } = options || {};\n  function WithSearch(props) {\n    var _urlQuery$find, _data$facets, _data$query7, _data$query8, _data$facets2, _data$query9, _data$query10, _querystringResults$i, _querystringResults$i2, _querystringResults$i3;\n    const {\n      data,\n      id,\n      editable = false\n    } = props;\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(id, editable);\n\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const urlQuery = locationSearchData.query ? deserializeQuery(locationSearchData.query) : [];\n    const urlSearchText = locationSearchData.SearchableText || ((_urlQuery$find = urlQuery.find(({\n      i\n    }) => i === 'SearchableText')) === null || _urlQuery$find === void 0 ? void 0 : _urlQuery$find.v) || '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const configuredFacets = ((_data$facets = data.facets) === null || _data$facets === void 0 ? void 0 : _data$facets.map(facet => {\n      var _facet$field2;\n      return facet === null || facet === void 0 ? void 0 : (_facet$field2 = facet.field) === null || _facet$field2 === void 0 ? void 0 : _facet$field2.value;\n    })) || [];\n\n    // Here we are getting the initial value of the facet if Listing Query contains the same criteria as\n    // facet.\n    const queryData = data !== null && data !== void 0 && (_data$query7 = data.query) !== null && _data$query7 !== void 0 && _data$query7.query ? deserializeQuery(JSON.stringify(data === null || data === void 0 ? void 0 : (_data$query8 = data.query) === null || _data$query8 === void 0 ? void 0 : _data$query8.query)) : [];\n    let intializeFacetWithQueryValue = [];\n    for (let value of configuredFacets) {\n      const queryString = queryData.find(item => item.i === value);\n      if (queryString) {\n        intializeFacetWithQueryValue = [...intializeFacetWithQueryValue, {\n          [queryString.i]: queryString.v\n        }];\n      }\n    }\n    const multiFacets = (_data$facets2 = data.facets) === null || _data$facets2 === void 0 ? void 0 : _data$facets2.filter(facet => facet === null || facet === void 0 ? void 0 : facet.multiple).map(facet => {\n      var _facet$field3;\n      return facet === null || facet === void 0 ? void 0 : (_facet$field3 = facet.field) === null || _facet$field3 === void 0 ? void 0 : _facet$field3.value;\n    });\n    const [facets, setFacets] = React.useState(Object.assign({}, ...urlQuery.map(({\n      i,\n      v\n    }) => ({\n      [i]: v\n    })),\n    // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n    ...intializeFacetWithQueryValue,\n    // support for simple filters like ?Subject=something\n    // TODO: since the move to hash params this is no longer working.\n    // We'd have to treat the location.search and manage it just like the\n    // hash, to support it. We can read it, but we'd have to reset it as\n    // well, so at that point what's the difference to the hash?\n    ...configuredFacets.map(f => locationSearchData[f] ? {\n      [f]: multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]\n    } : {})));\n    const previousUrlQuery = usePrevious(urlQuery);\n\n    // During first render the previousUrlQuery is undefined and urlQuery\n    // is empty so it resetting the facet when you are navigating but during reload we have urlQuery and we need\n    // to set the facet at first render.\n    const preventOverrideOfFacetState = previousUrlQuery === undefined && urlQuery.length === 0;\n    React.useEffect(() => {\n      if (!isEqual(urlQuery, previousUrlQuery) && !preventOverrideOfFacetState) {\n        setFacets(Object.assign({}, ...urlQuery.map(({\n          i,\n          v\n        }) => ({\n          [i]: v\n        })),\n        // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map(f => locationSearchData[f] ? {\n          [f]: multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]\n        } : {})));\n      }\n    }, [urlQuery, configuredFacets, locationSearchData, multiFacets, previousUrlQuery, preventOverrideOfFacetState]);\n    const [sortOn, setSortOn] = React.useState(data === null || data === void 0 ? void 0 : (_data$query9 = data.query) === null || _data$query9 === void 0 ? void 0 : _data$query9.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data === null || data === void 0 ? void 0 : (_data$query10 = data.query) === null || _data$query10 === void 0 ? void 0 : _data$query10.sort_order);\n    const [searchData, setSearchData] = React.useState(getInitialState(data, facets, urlSearchText, id));\n    const deepFacets = JSON.stringify(facets);\n    const deepData = JSON.stringify(data);\n    React.useEffect(() => {\n      setSearchData(getInitialState(JSON.parse(deepData), JSON.parse(deepFacets), urlSearchText, id, sortOn, sortOrder));\n    }, [deepData, deepFacets, urlSearchText, id, sortOn, sortOrder]);\n    const timeoutRef = React.useRef();\n    const facetSettings = data === null || data === void 0 ? void 0 : data.facets;\n    const deepQuery = JSON.stringify(data.query);\n    const onTriggerSearch = React.useCallback((toSearchText = undefined, toSearchFacets = undefined, toSortOn = undefined, toSortOrder = undefined) => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => {\n        const newSearchData = normalizeState({\n          id,\n          query: data.query || {},\n          facets: toSearchFacets || facets,\n          searchText: toSearchText ? toSearchText.trim() : '',\n          sortOn: toSortOn || undefined,\n          sortOrder: toSortOrder || sortOrder,\n          facetSettings\n        });\n        if (toSearchFacets) setFacets(toSearchFacets);\n        if (toSortOn) setSortOn(toSortOn || undefined);\n        if (toSortOrder) setSortOrder(toSortOrder);\n        setSearchData(newSearchData);\n        setLocationSearchData(getSearchFields(newSearchData));\n      }, toSearchFacets ? inputDelay / 3 : inputDelay);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n    // Use deep comparison of data.query\n    deepQuery, facets, id, setLocationSearchData, searchText, sortOn, sortOrder, facetSettings]);\n    const removeSearchQuery = () => {\n      let newSearchData = _objectSpread({}, searchData);\n      newSearchData.query = searchData.query.reduce(\n      // Remove SearchableText from query\n      (acc, kvp) => kvp.i === 'SearchableText' ? acc : [...acc, kvp], []);\n      setSearchData(newSearchData);\n      setLocationSearchData(getSearchFields(newSearchData));\n    };\n    const querystringResults = useSelector(state => state.querystringsearch.subrequests);\n    const totalItems = ((_querystringResults$i = querystringResults[id]) === null || _querystringResults$i === void 0 ? void 0 : _querystringResults$i.total) || ((_querystringResults$i2 = querystringResults[id]) === null || _querystringResults$i2 === void 0 ? void 0 : (_querystringResults$i3 = _querystringResults$i2.items) === null || _querystringResults$i3 === void 0 ? void 0 : _querystringResults$i3.length);\n    return __jsx(WrappedComponent, _extends({}, props, {\n      searchData: searchData,\n      facets: facets,\n      setFacets: setFacets,\n      setSortOn: setSortOn,\n      setSortOrder: setSortOrder,\n      sortOn: sortOn,\n      sortOrder: sortOrder,\n      searchedText: urlSearchText,\n      searchText: searchText,\n      removeSearchQuery: removeSearchQuery,\n      setSearchText: setSearchText,\n      onTriggerSearch: onTriggerSearch,\n      totalItems: totalItems,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 455,\n        columnNumber: 7\n      }\n    }));\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n  return WithSearch;\n};\nexport default withSearch;","map":{"version":3,"names":["React","useSelector","qs","useLocation","useHistory","resolveExtension","config","usePrevious","isEqual","getDisplayName","WrappedComponent","displayName","name","SEARCH_ENDPOINT_FIELDS","PAQO","getInitialState","data","facets","urlSearchText","id","sortOnParam","sortOrderParam","_data$query","_data$query2","_data$query3","_data$query4","_data$query5","_data$query6","types","facetWidgetTypes","blocks","blocksConfig","search","extensions","facetWidgets","facetSettings","query","map","facet","field","valueToQuery","value","filter","f","i","o","v","sort_on","sort_order","b_size","limit","depth","block","normalizeState","searchText","sortOn","sortOrder","configuredFacets","_facet$field","copyOfQuery","queryWithoutFacet","includes","params","reduce","acc","kvp","push","getSearchFields","searchData","Object","assign","k","serializeQuery","useHashState","location","history","oldState","useMemo","_objectSpread","parse","hash","current","Array","from","keys","setSearchData","useCallback","newParams","changed","sort","forEach","stringify","useSearchBlockState","uniqueId","isEditMode","hashState","setHashState","internalState","setInternalState","useState","deserializeQuery","q","_JSON$parse","JSON","replace","withSearch","options","inputDelay","WithSearch","props","_urlQuery$find","_data$facets","_data$query7","_data$query8","_data$facets2","_data$query9","_data$query10","_querystringResults$i","_querystringResults$i2","_querystringResults$i3","editable","locationSearchData","setLocationSearchData","urlQuery","SearchableText","find","setSearchText","_facet$field2","queryData","intializeFacetWithQueryValue","queryString","item","multiFacets","multiple","_facet$field3","setFacets","indexOf","previousUrlQuery","preventOverrideOfFacetState","undefined","length","useEffect","setSortOn","setSortOrder","deepFacets","deepData","timeoutRef","useRef","deepQuery","onTriggerSearch","toSearchText","toSearchFacets","toSortOn","toSortOrder","clearTimeout","setTimeout","newSearchData","trim","removeSearchQuery","querystringResults","state","querystringsearch","subrequests","totalItems","total","items","__jsx","_extends","searchedText","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx"],"sourcesContent":["import React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\n\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\nimport { usePrevious } from '@plone/volto/helpers/Utils/usePrevious';\nimport isEqual from 'lodash/isEqual';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst SEARCH_ENDPOINT_FIELDS = [\n  'SearchableText',\n  'b_size',\n  'limit',\n  'sort_on',\n  'sort_order',\n  'depth',\n];\n\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(\n  data,\n  facets,\n  urlSearchText,\n  id,\n  sortOnParam,\n  sortOrderParam,\n) {\n  const { types: facetWidgetTypes } =\n    config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = data?.facets || [];\n\n  return {\n    query: [\n      ...(data.query?.query || []),\n      ...(facetSettings || [])\n        .map((facet) => {\n          if (!facet?.field) return null;\n\n          const { valueToQuery } = resolveExtension(\n            'type',\n            facetWidgetTypes,\n            facet,\n          );\n\n          const name = facet.field.value;\n          const value = facets[name];\n\n          return valueToQuery({ value, facet });\n        })\n        .filter((f) => !!f),\n      ...(urlSearchText\n        ? [\n            {\n              i: 'SearchableText',\n              o: 'plone.app.querystring.operation.string.contains',\n              v: urlSearchText,\n            },\n          ]\n        : []),\n    ],\n    sort_on: sortOnParam || data.query?.sort_on,\n    sort_order: sortOrderParam || data.query?.sort_order,\n    b_size: data.query?.b_size,\n    limit: data.query?.limit,\n    depth: data.query?.depth,\n    block: id,\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query, // base query\n  facets, // facet values\n  id, // block id\n  searchText, // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings, // data.facets extracted from block data\n}) {\n  const { types: facetWidgetTypes } =\n    config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  // Here, we are removing the QueryString of the Listing ones, which is present in the Facet\n  // because we already initialize the facet with those values.\n  const configuredFacets = facetSettings\n    ? facetSettings.map((facet) => facet?.field?.value)\n    : [];\n\n  let copyOfQuery = query.query ? [...query.query] : [];\n\n  const queryWithoutFacet = copyOfQuery.filter((query) => {\n    return !configuredFacets.includes(query.i);\n  });\n\n  const params = {\n    query: [\n      ...(queryWithoutFacet || []),\n      ...(facetSettings || []).map((facet) => {\n        if (!facet?.field) return null;\n\n        const { valueToQuery } = resolveExtension(\n          'type',\n          facetWidgetTypes,\n          facet,\n        );\n\n        const name = facet.field.value;\n        const value = facets[name];\n\n        return valueToQuery({ value, facet });\n      }),\n    ].filter((o) => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    depth: query.depth,\n    block: id,\n  };\n\n  // Note Ideally the searchtext functionality should be restructured as being just\n  // another facet. But right now it's the same. This means that if a searchText\n  // is provided, it will override the SearchableText facet.\n  // If there is no searchText, the SearchableText in the query remains in effect.\n  // TODO eventually the searchText should be a distinct facet from SearchableText, and\n  // the two conditions could be combined, in comparison to the current state, when\n  // one overrides the other.\n  if (searchText) {\n    params.query = params.query.reduce(\n      // Remove SearchableText from query\n      (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n      [],\n    );\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText,\n    });\n  }\n\n  return params;\n}\n\nconst getSearchFields = (searchData) => {\n  return Object.assign(\n    {},\n    ...SEARCH_ENDPOINT_FIELDS.map((k) => {\n      return searchData[k] ? { [k]: searchData[k] } : {};\n    }),\n    searchData.query ? { query: serializeQuery(searchData['query']) } : {},\n  );\n};\n\n/**\n * A hook that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n\n  /**\n   * Required to maintain parameter compatibility.\n    With this we will maintain support for receiving hash (#) and search (?) type parameters.\n  */\n  const oldState = React.useMemo(() => {\n    return {\n      ...qs.parse(location.search),\n      ...qs.parse(location.hash),\n    };\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign(\n    {},\n    ...Array.from(Object.keys(oldState)).map((k) => ({ [k]: oldState[k] })),\n  );\n\n  const setSearchData = React.useCallback(\n    (searchData) => {\n      const newParams = qs.parse(location.search);\n\n      let changed = false;\n\n      Object.keys(searchData)\n        .sort()\n        .forEach((k) => {\n          if (searchData[k]) {\n            newParams[k] = searchData[k];\n            if (oldState[k] !== searchData[k]) {\n              changed = true;\n            }\n          }\n        });\n\n      if (changed) {\n        history.push({\n          search: qs.stringify(newParams),\n        });\n      }\n    },\n    [history, oldState, location.search],\n  );\n\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n\n  return isEditMode\n    ? [internalState, setInternalState]\n    : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = (q) => {\n  return JSON.parse(q)?.map((kvp) => ({\n    ...kvp,\n    o: kvp.o.replace(/^paqo/, PAQO),\n  }));\n};\nconst serializeQuery = (q) => {\n  return JSON.stringify(\n    q?.map((kvp) => ({ ...kvp, o: kvp.o.replace(PAQO, 'paqo') })),\n  );\n};\n\nconst withSearch = (options) => (WrappedComponent) => {\n  const { inputDelay = 1000 } = options || {};\n\n  function WithSearch(props) {\n    const { data, id, editable = false } = props;\n\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(\n      id,\n      editable,\n    );\n\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const urlQuery = locationSearchData.query\n      ? deserializeQuery(locationSearchData.query)\n      : [];\n    const urlSearchText =\n      locationSearchData.SearchableText ||\n      urlQuery.find(({ i }) => i === 'SearchableText')?.v ||\n      '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    // TODO: Improve the hook dependencies out of the scope of https://github.com/plone/volto/pull/4662\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const configuredFacets =\n      data.facets?.map((facet) => facet?.field?.value) || [];\n\n    // Here we are getting the initial value of the facet if Listing Query contains the same criteria as\n    // facet.\n    const queryData = data?.query?.query\n      ? deserializeQuery(JSON.stringify(data?.query?.query))\n      : [];\n\n    let intializeFacetWithQueryValue = [];\n\n    for (let value of configuredFacets) {\n      const queryString = queryData.find((item) => item.i === value);\n      if (queryString) {\n        intializeFacetWithQueryValue = [\n          ...intializeFacetWithQueryValue,\n          { [queryString.i]: queryString.v },\n        ];\n      }\n    }\n\n    const multiFacets = data.facets\n      ?.filter((facet) => facet?.multiple)\n      .map((facet) => facet?.field?.value);\n    const [facets, setFacets] = React.useState(\n      Object.assign(\n        {},\n        ...urlQuery.map(({ i, v }) => ({ [i]: v })),\n        // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n        ...intializeFacetWithQueryValue,\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map((f) =>\n          locationSearchData[f]\n            ? {\n                [f]:\n                  multiFacets.indexOf(f) > -1\n                    ? [locationSearchData[f]]\n                    : locationSearchData[f],\n              }\n            : {},\n        ),\n      ),\n    );\n    const previousUrlQuery = usePrevious(urlQuery);\n\n    // During first render the previousUrlQuery is undefined and urlQuery\n    // is empty so it resetting the facet when you are navigating but during reload we have urlQuery and we need\n    // to set the facet at first render.\n    const preventOverrideOfFacetState =\n      previousUrlQuery === undefined && urlQuery.length === 0;\n\n    React.useEffect(() => {\n      if (\n        !isEqual(urlQuery, previousUrlQuery) &&\n        !preventOverrideOfFacetState\n      ) {\n        setFacets(\n          Object.assign(\n            {},\n            ...urlQuery.map(({ i, v }) => ({ [i]: v })), // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n            // support for simple filters like ?Subject=something\n            // TODO: since the move to hash params this is no longer working.\n            // We'd have to treat the location.search and manage it just like the\n            // hash, to support it. We can read it, but we'd have to reset it as\n            // well, so at that point what's the difference to the hash?\n            ...configuredFacets.map((f) =>\n              locationSearchData[f]\n                ? {\n                    [f]:\n                      multiFacets.indexOf(f) > -1\n                        ? [locationSearchData[f]]\n                        : locationSearchData[f],\n                  }\n                : {},\n            ),\n          ),\n        );\n      }\n    }, [\n      urlQuery,\n      configuredFacets,\n      locationSearchData,\n      multiFacets,\n      previousUrlQuery,\n      preventOverrideOfFacetState,\n    ]);\n\n    const [sortOn, setSortOn] = React.useState(data?.query?.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data?.query?.sort_order);\n\n    const [searchData, setSearchData] = React.useState(\n      getInitialState(data, facets, urlSearchText, id),\n    );\n\n    const deepFacets = JSON.stringify(facets);\n    const deepData = JSON.stringify(data);\n    React.useEffect(() => {\n      setSearchData(\n        getInitialState(\n          JSON.parse(deepData),\n          JSON.parse(deepFacets),\n          urlSearchText,\n          id,\n          sortOn,\n          sortOrder,\n        ),\n      );\n    }, [deepData, deepFacets, urlSearchText, id, sortOn, sortOrder]);\n\n    const timeoutRef = React.useRef();\n    const facetSettings = data?.facets;\n\n    const deepQuery = JSON.stringify(data.query);\n    const onTriggerSearch = React.useCallback(\n      (\n        toSearchText = undefined,\n        toSearchFacets = undefined,\n        toSortOn = undefined,\n        toSortOrder = undefined,\n      ) => {\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(\n          () => {\n            const newSearchData = normalizeState({\n              id,\n              query: data.query || {},\n              facets: toSearchFacets || facets,\n              searchText: toSearchText ? toSearchText.trim() : '',\n              sortOn: toSortOn || undefined,\n              sortOrder: toSortOrder || sortOrder,\n              facetSettings,\n            });\n            if (toSearchFacets) setFacets(toSearchFacets);\n            if (toSortOn) setSortOn(toSortOn || undefined);\n            if (toSortOrder) setSortOrder(toSortOrder);\n            setSearchData(newSearchData);\n            setLocationSearchData(getSearchFields(newSearchData));\n          },\n          toSearchFacets ? inputDelay / 3 : inputDelay,\n        );\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [\n        // Use deep comparison of data.query\n        deepQuery,\n        facets,\n        id,\n        setLocationSearchData,\n        searchText,\n        sortOn,\n        sortOrder,\n        facetSettings,\n      ],\n    );\n\n    const removeSearchQuery = () => {\n      let newSearchData = { ...searchData };\n      newSearchData.query = searchData.query.reduce(\n        // Remove SearchableText from query\n        (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n        [],\n      );\n      setSearchData(newSearchData);\n      setLocationSearchData(getSearchFields(newSearchData));\n    };\n\n    const querystringResults = useSelector(\n      (state) => state.querystringsearch.subrequests,\n    );\n    const totalItems =\n      querystringResults[id]?.total || querystringResults[id]?.items?.length;\n\n    return (\n      <WrappedComponent\n        {...props}\n        searchData={searchData}\n        facets={facets}\n        setFacets={setFacets}\n        setSortOn={setSortOn}\n        setSortOrder={setSortOrder}\n        sortOn={sortOn}\n        sortOrder={sortOrder}\n        searchedText={urlSearchText}\n        searchText={searchText}\n        removeSearchQuery={removeSearchQuery}\n        setSearchText={setSearchText}\n        onTriggerSearch={onTriggerSearch}\n        totalItems={totalItems}\n      />\n    );\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n\n  return WithSearch;\n};\n\nexport default withSearch;\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}