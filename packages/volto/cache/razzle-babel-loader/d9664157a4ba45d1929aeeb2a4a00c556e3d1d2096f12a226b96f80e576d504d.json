{"ast":null,"code":"var _jsxFileName = \"/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Block/Order/Order.jsx\";\nvar __jsx = React.createElement;\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport find from 'lodash/find';\nimport min from 'lodash/min';\nimport { flattenTree, getProjection, removeChildrenOf } from './utilities';\nimport SortableItem from './SortableItem';\nimport { injectLazyLibs } from '@plone/volto/helpers/Loadable/Loadable';\nexport function Order({\n  items = [],\n  onMoveBlock,\n  onDeleteBlock,\n  onSelectBlock,\n  indentationWidth = 25,\n  removable,\n  dndKitCore,\n  dndKitSortable,\n  dndKitUtilities,\n  errors\n}) {\n  const {\n    0: activeId,\n    1: setActiveId\n  } = useState(null);\n  const {\n    0: overId,\n    1: setOverId\n  } = useState(null);\n  const {\n    0: offsetLeft,\n    1: setOffsetLeft\n  } = useState(0);\n  const {\n    0: currentPosition,\n    1: setCurrentPosition\n  } = useState(null);\n  const {\n    DndContext,\n    closestCenter,\n    PointerSensor,\n    useSensor,\n    useSensors,\n    DragOverlay,\n    MeasuringStrategy,\n    defaultDropAnimation\n  } = dndKitCore;\n  const {\n    SortableContext,\n    arrayMove,\n    verticalListSortingStrategy\n  } = dndKitSortable;\n  const {\n    CSS\n  } = dndKitUtilities;\n  const measuring = {\n    droppable: {\n      strategy: MeasuringStrategy.Always\n    }\n  };\n  const dropAnimationConfig = {\n    keyframes({\n      transform\n    }) {\n      return [{\n        opacity: 1,\n        transform: CSS.Transform.toString(transform.initial)\n      }, {\n        opacity: 0,\n        transform: CSS.Transform.toString(_objectSpread(_objectSpread({}, transform.final), {}, {\n          x: transform.final.x + 5,\n          y: transform.final.y + 5\n        }))\n      }];\n    },\n    easing: 'ease-out',\n    sideEffects({\n      active\n    }) {\n      active.node.animate([{\n        opacity: 0\n      }, {\n        opacity: 1\n      }], {\n        duration: defaultDropAnimation.duration,\n        easing: defaultDropAnimation.easing\n      });\n    }\n  };\n  const flattenedItems = useMemo(() => removeChildrenOf(flattenTree(items), activeId ? [activeId] : []), [activeId, items]);\n  const projected = activeId && overId ? getProjection(flattenedItems, activeId, overId, offsetLeft, indentationWidth, arrayMove) : null;\n  const sensorContext = useRef({\n    items: flattenedItems,\n    offset: offsetLeft\n  });\n  const sensors = useSensors(useSensor(PointerSensor));\n  const sortedIds = useMemo(() => flattenedItems.map(({\n    id\n  }) => id), [flattenedItems]);\n  const activeItem = activeId ? flattenedItems.find(({\n    id\n  }) => id === activeId) : null;\n  useEffect(() => {\n    sensorContext.current = {\n      items: flattenedItems,\n      offset: offsetLeft\n    };\n  }, [flattenedItems, offsetLeft]);\n  const announcements = {\n    onDragStart({\n      active\n    }) {\n      return `Picked up ${active.id}.`;\n    },\n    onDragMove({\n      active,\n      over\n    }) {\n      return getMovementAnnouncement('onDragMove', active.id, over === null || over === void 0 ? void 0 : over.id);\n    },\n    onDragOver({\n      active,\n      over\n    }) {\n      return getMovementAnnouncement('onDragOver', active.id, over === null || over === void 0 ? void 0 : over.id);\n    },\n    onDragEnd({\n      active,\n      over\n    }) {\n      return getMovementAnnouncement('onDragEnd', active.id, over === null || over === void 0 ? void 0 : over.id);\n    },\n    onDragCancel({\n      active\n    }) {\n      return `Moving was cancelled. ${active.id} was dropped in its original position.`;\n    }\n  };\n  return __jsx(DndContext, {\n    accessibility: {\n      announcements\n    },\n    sensors: sensors,\n    collisionDetection: closestCenter,\n    measuring: measuring,\n    onDragStart: handleDragStart,\n    onDragMove: handleDragMove,\n    onDragOver: handleDragOver,\n    onDragEnd: handleDragEnd,\n    onDragCancel: handleDragCancel,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 126,\n      columnNumber: 5\n    }\n  }, __jsx(SortableContext, {\n    items: sortedIds,\n    strategy: verticalListSortingStrategy,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 7\n    }\n  }, flattenedItems.map(({\n    id,\n    parentId,\n    depth,\n    data\n  }) => __jsx(SortableItem, {\n    key: id,\n    id: id,\n    parentId: parentId,\n    data: data,\n    depth: min([id === activeId && projected ? projected.depth : depth, 1]),\n    indentationWidth: indentationWidth,\n    onRemove: removable ? () => handleRemove(id) : undefined,\n    onSelectBlock: onSelectBlock,\n    errors: (errors === null || errors === void 0 ? void 0 : errors[id]) || {},\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 11\n    }\n  })), /*#__PURE__*/createPortal(__jsx(DragOverlay, {\n    dropAnimation: dropAnimationConfig,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 155,\n      columnNumber: 11\n    }\n  }, activeId && activeItem ? __jsx(SortableItem, {\n    id: activeId,\n    depth: activeItem.depth,\n    clone: true,\n    data: find(flattenedItems, {\n      id: activeId\n    }).data,\n    indentationWidth: indentationWidth,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 15\n    }\n  }) : null), document.body)));\n  function handleDragStart({\n    active: {\n      id: activeId\n    }\n  }) {\n    setActiveId(activeId);\n    setOverId(activeId);\n    const activeItem = flattenedItems.find(({\n      id\n    }) => id === activeId);\n    if (activeItem) {\n      setCurrentPosition({\n        parentId: activeItem.parentId,\n        overId: activeId\n      });\n    }\n    document.body.style.setProperty('cursor', 'grabbing');\n  }\n  function handleDragMove({\n    delta\n  }) {\n    setOffsetLeft(delta.x);\n  }\n  function handleDragOver({\n    over\n  }) {\n    var _over$id;\n    setOverId((_over$id = over === null || over === void 0 ? void 0 : over.id) !== null && _over$id !== void 0 ? _over$id : null);\n  }\n  function handleDragEnd({\n    active,\n    over\n  }) {\n    if (projected && over) {\n      const {\n        depth,\n        parentId\n      } = projected;\n      const clonedItems = JSON.parse(JSON.stringify(flattenedItems));\n      const overIndex = clonedItems.findIndex(({\n        id\n      }) => id === over.id);\n      const activeIndex = clonedItems.findIndex(({\n        id\n      }) => id === active.id);\n      const activeTreeItem = clonedItems[activeIndex];\n      const oldParentId = activeTreeItem.parentId;\n      clonedItems[activeIndex] = _objectSpread(_objectSpread({}, activeTreeItem), {}, {\n        depth,\n        parentId\n      });\n\n      // Translate position depending on parent\n      if (parentId === oldParentId) {\n        // Move from and to toplevel or move within the same grid block\n\n        let destIndex = clonedItems[overIndex].index;\n        if (clonedItems[overIndex].depth > clonedItems[activeIndex].depth) {\n          destIndex = find(clonedItems, {\n            id: clonedItems[overIndex].parentId\n          }).index;\n        }\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id\n          },\n          destination: {\n            position: destIndex,\n            parent: parentId\n          }\n        });\n      } else if (parentId && oldParentId) {\n        // Move from one gridblock to another\n\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id\n          },\n          destination: {\n            position: overIndex < activeIndex ? clonedItems[overIndex - 1].parentId ? clonedItems[overIndex - 1].index + 1 : clonedItems[overIndex].index : overIndex + 1 < clonedItems.length ? clonedItems[overIndex + 1].index : clonedItems[overIndex].index + 1,\n            parent: parentId\n          }\n        });\n      } else if (oldParentId) {\n        // Moving to the main container from a gridblock\n\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id\n          },\n          destination: {\n            position: overIndex > activeIndex ? overIndex + 1 < clonedItems.length ? clonedItems[overIndex + 1].index : clonedItems[overIndex].index + 1 : clonedItems[overIndex].index,\n            parent: parentId\n          }\n        });\n      } else {\n        // Moving from the main container to a gridblock\n\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id\n          },\n          destination: {\n            position: overIndex < activeIndex ? clonedItems[overIndex - 1].parentId ? clonedItems[overIndex - 1].index + 1 : clonedItems[overIndex].index : overIndex + 1 < clonedItems.length ? clonedItems[overIndex + 1].index : clonedItems[overIndex].index + 1,\n            parent: parentId\n          }\n        });\n      }\n    }\n    resetState();\n  }\n  function handleDragCancel() {\n    resetState();\n  }\n  function resetState() {\n    setOverId(null);\n    setActiveId(null);\n    setOffsetLeft(0);\n    setCurrentPosition(null);\n    document.body.style.setProperty('cursor', '');\n  }\n  function handleRemove(id) {\n    onDeleteBlock(id);\n  }\n  function getMovementAnnouncement(eventName, activeId, overId) {\n    if (overId && projected) {\n      if (eventName !== 'onDragEnd') {\n        if (currentPosition && projected.parentId === currentPosition.parentId && overId === currentPosition.overId) {\n          return;\n        } else {\n          setCurrentPosition({\n            parentId: projected.parentId,\n            overId\n          });\n        }\n      }\n      const clonedItems = JSON.parse(JSON.stringify(flattenTree(items)));\n      const overIndex = clonedItems.findIndex(({\n        id\n      }) => id === overId);\n      const activeIndex = clonedItems.findIndex(({\n        id\n      }) => id === activeId);\n      const sortedItems = arrayMove(clonedItems, activeIndex, overIndex);\n      const previousItem = sortedItems[overIndex - 1];\n      let announcement;\n      const movedVerb = eventName === 'onDragEnd' ? 'dropped' : 'moved';\n      const nestedVerb = eventName === 'onDragEnd' ? 'dropped' : 'nested';\n      if (!previousItem) {\n        const nextItem = sortedItems[overIndex + 1];\n        announcement = `${activeId} was ${movedVerb} before ${nextItem.id}.`;\n      } else {\n        if (projected.depth > previousItem.depth) {\n          announcement = `${activeId} was ${nestedVerb} under ${previousItem.id}.`;\n        } else {\n          let previousSibling = previousItem;\n          while (previousSibling && projected.depth < previousSibling.depth) {\n            const parentId = previousSibling.parentId;\n            previousSibling = sortedItems.find(({\n              id\n            }) => id === parentId);\n          }\n          if (previousSibling) {\n            announcement = `${activeId} was ${movedVerb} after ${previousSibling.id}.`;\n          }\n        }\n      }\n      return announcement;\n    }\n    return;\n  }\n}\nexport default injectLazyLibs(['dndKitCore', 'dndKitSortable', 'dndKitUtilities'])(Order);","map":{"version":3,"names":["React","useEffect","useMemo","useRef","useState","createPortal","find","min","flattenTree","getProjection","removeChildrenOf","SortableItem","injectLazyLibs","Order","items","onMoveBlock","onDeleteBlock","onSelectBlock","indentationWidth","removable","dndKitCore","dndKitSortable","dndKitUtilities","errors","activeId","setActiveId","overId","setOverId","offsetLeft","setOffsetLeft","currentPosition","setCurrentPosition","DndContext","closestCenter","PointerSensor","useSensor","useSensors","DragOverlay","MeasuringStrategy","defaultDropAnimation","SortableContext","arrayMove","verticalListSortingStrategy","CSS","measuring","droppable","strategy","Always","dropAnimationConfig","keyframes","transform","opacity","Transform","toString","initial","_objectSpread","final","x","y","easing","sideEffects","active","node","animate","duration","flattenedItems","projected","sensorContext","offset","sensors","sortedIds","map","id","activeItem","current","announcements","onDragStart","onDragMove","over","getMovementAnnouncement","onDragOver","onDragEnd","onDragCancel","__jsx","accessibility","collisionDetection","handleDragStart","handleDragMove","handleDragOver","handleDragEnd","handleDragCancel","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","parentId","depth","data","key","onRemove","handleRemove","undefined","dropAnimation","clone","document","body","style","setProperty","delta","_over$id","clonedItems","JSON","parse","stringify","overIndex","findIndex","activeIndex","activeTreeItem","oldParentId","destIndex","index","source","position","parent","destination","length","resetState","eventName","sortedItems","previousItem","announcement","movedVerb","nestedVerb","nextItem","previousSibling"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/components/manage/Blocks/Block/Order/Order.jsx"],"sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport find from 'lodash/find';\nimport min from 'lodash/min';\n\nimport { flattenTree, getProjection, removeChildrenOf } from './utilities';\nimport SortableItem from './SortableItem';\n\nimport { injectLazyLibs } from '@plone/volto/helpers/Loadable/Loadable';\n\nexport function Order({\n  items = [],\n  onMoveBlock,\n  onDeleteBlock,\n  onSelectBlock,\n  indentationWidth = 25,\n  removable,\n  dndKitCore,\n  dndKitSortable,\n  dndKitUtilities,\n  errors,\n}) {\n  const [activeId, setActiveId] = useState(null);\n  const [overId, setOverId] = useState(null);\n  const [offsetLeft, setOffsetLeft] = useState(0);\n  const [currentPosition, setCurrentPosition] = useState(null);\n\n  const {\n    DndContext,\n    closestCenter,\n    PointerSensor,\n    useSensor,\n    useSensors,\n    DragOverlay,\n    MeasuringStrategy,\n    defaultDropAnimation,\n  } = dndKitCore;\n  const { SortableContext, arrayMove, verticalListSortingStrategy } =\n    dndKitSortable;\n  const { CSS } = dndKitUtilities;\n\n  const measuring = {\n    droppable: {\n      strategy: MeasuringStrategy.Always,\n    },\n  };\n\n  const dropAnimationConfig = {\n    keyframes({ transform }) {\n      return [\n        { opacity: 1, transform: CSS.Transform.toString(transform.initial) },\n        {\n          opacity: 0,\n          transform: CSS.Transform.toString({\n            ...transform.final,\n            x: transform.final.x + 5,\n            y: transform.final.y + 5,\n          }),\n        },\n      ];\n    },\n    easing: 'ease-out',\n    sideEffects({ active }) {\n      active.node.animate([{ opacity: 0 }, { opacity: 1 }], {\n        duration: defaultDropAnimation.duration,\n        easing: defaultDropAnimation.easing,\n      });\n    },\n  };\n\n  const flattenedItems = useMemo(\n    () => removeChildrenOf(flattenTree(items), activeId ? [activeId] : []),\n    [activeId, items],\n  );\n  const projected =\n    activeId && overId\n      ? getProjection(\n          flattenedItems,\n          activeId,\n          overId,\n          offsetLeft,\n          indentationWidth,\n          arrayMove,\n        )\n      : null;\n  const sensorContext = useRef({\n    items: flattenedItems,\n    offset: offsetLeft,\n  });\n  const sensors = useSensors(useSensor(PointerSensor));\n\n  const sortedIds = useMemo(\n    () => flattenedItems.map(({ id }) => id),\n    [flattenedItems],\n  );\n  const activeItem = activeId\n    ? flattenedItems.find(({ id }) => id === activeId)\n    : null;\n\n  useEffect(() => {\n    sensorContext.current = {\n      items: flattenedItems,\n      offset: offsetLeft,\n    };\n  }, [flattenedItems, offsetLeft]);\n\n  const announcements = {\n    onDragStart({ active }) {\n      return `Picked up ${active.id}.`;\n    },\n    onDragMove({ active, over }) {\n      return getMovementAnnouncement('onDragMove', active.id, over?.id);\n    },\n    onDragOver({ active, over }) {\n      return getMovementAnnouncement('onDragOver', active.id, over?.id);\n    },\n    onDragEnd({ active, over }) {\n      return getMovementAnnouncement('onDragEnd', active.id, over?.id);\n    },\n    onDragCancel({ active }) {\n      return `Moving was cancelled. ${active.id} was dropped in its original position.`;\n    },\n  };\n\n  return (\n    <DndContext\n      accessibility={{ announcements }}\n      sensors={sensors}\n      collisionDetection={closestCenter}\n      measuring={measuring}\n      onDragStart={handleDragStart}\n      onDragMove={handleDragMove}\n      onDragOver={handleDragOver}\n      onDragEnd={handleDragEnd}\n      onDragCancel={handleDragCancel}\n    >\n      <SortableContext items={sortedIds} strategy={verticalListSortingStrategy}>\n        {flattenedItems.map(({ id, parentId, depth, data }) => (\n          <SortableItem\n            key={id}\n            id={id}\n            parentId={parentId}\n            data={data}\n            depth={min([\n              id === activeId && projected ? projected.depth : depth,\n              1,\n            ])}\n            indentationWidth={indentationWidth}\n            onRemove={removable ? () => handleRemove(id) : undefined}\n            onSelectBlock={onSelectBlock}\n            errors={errors?.[id] || {}}\n          />\n        ))}\n        {createPortal(\n          <DragOverlay dropAnimation={dropAnimationConfig}>\n            {activeId && activeItem ? (\n              <SortableItem\n                id={activeId}\n                depth={activeItem.depth}\n                clone\n                data={find(flattenedItems, { id: activeId }).data}\n                indentationWidth={indentationWidth}\n              />\n            ) : null}\n          </DragOverlay>,\n          document.body,\n        )}\n      </SortableContext>\n    </DndContext>\n  );\n\n  function handleDragStart({ active: { id: activeId } }) {\n    setActiveId(activeId);\n    setOverId(activeId);\n\n    const activeItem = flattenedItems.find(({ id }) => id === activeId);\n\n    if (activeItem) {\n      setCurrentPosition({\n        parentId: activeItem.parentId,\n        overId: activeId,\n      });\n    }\n\n    document.body.style.setProperty('cursor', 'grabbing');\n  }\n\n  function handleDragMove({ delta }) {\n    setOffsetLeft(delta.x);\n  }\n\n  function handleDragOver({ over }) {\n    setOverId(over?.id ?? null);\n  }\n\n  function handleDragEnd({ active, over }) {\n    if (projected && over) {\n      const { depth, parentId } = projected;\n      const clonedItems = JSON.parse(JSON.stringify(flattenedItems));\n      const overIndex = clonedItems.findIndex(({ id }) => id === over.id);\n      const activeIndex = clonedItems.findIndex(({ id }) => id === active.id);\n      const activeTreeItem = clonedItems[activeIndex];\n      const oldParentId = activeTreeItem.parentId;\n\n      clonedItems[activeIndex] = { ...activeTreeItem, depth, parentId };\n\n      // Translate position depending on parent\n      if (parentId === oldParentId) {\n        // Move from and to toplevel or move within the same grid block\n\n        let destIndex = clonedItems[overIndex].index;\n        if (clonedItems[overIndex].depth > clonedItems[activeIndex].depth) {\n          destIndex = find(clonedItems, {\n            id: clonedItems[overIndex].parentId,\n          }).index;\n        }\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id,\n          },\n          destination: {\n            position: destIndex,\n            parent: parentId,\n          },\n        });\n      } else if (parentId && oldParentId) {\n        // Move from one gridblock to another\n\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id,\n          },\n          destination: {\n            position:\n              overIndex < activeIndex\n                ? clonedItems[overIndex - 1].parentId\n                  ? clonedItems[overIndex - 1].index + 1\n                  : clonedItems[overIndex].index\n                : overIndex + 1 < clonedItems.length\n                  ? clonedItems[overIndex + 1].index\n                  : clonedItems[overIndex].index + 1,\n            parent: parentId,\n          },\n        });\n      } else if (oldParentId) {\n        // Moving to the main container from a gridblock\n\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id,\n          },\n          destination: {\n            position:\n              overIndex > activeIndex\n                ? overIndex + 1 < clonedItems.length\n                  ? clonedItems[overIndex + 1].index\n                  : clonedItems[overIndex].index + 1\n                : clonedItems[overIndex].index,\n            parent: parentId,\n          },\n        });\n      } else {\n        // Moving from the main container to a gridblock\n\n        onMoveBlock({\n          source: {\n            position: clonedItems[activeIndex].index,\n            parent: oldParentId,\n            id: active.id,\n          },\n          destination: {\n            position:\n              overIndex < activeIndex\n                ? clonedItems[overIndex - 1].parentId\n                  ? clonedItems[overIndex - 1].index + 1\n                  : clonedItems[overIndex].index\n                : overIndex + 1 < clonedItems.length\n                  ? clonedItems[overIndex + 1].index\n                  : clonedItems[overIndex].index + 1,\n            parent: parentId,\n          },\n        });\n      }\n    }\n\n    resetState();\n  }\n\n  function handleDragCancel() {\n    resetState();\n  }\n\n  function resetState() {\n    setOverId(null);\n    setActiveId(null);\n    setOffsetLeft(0);\n    setCurrentPosition(null);\n\n    document.body.style.setProperty('cursor', '');\n  }\n\n  function handleRemove(id) {\n    onDeleteBlock(id);\n  }\n\n  function getMovementAnnouncement(eventName, activeId, overId) {\n    if (overId && projected) {\n      if (eventName !== 'onDragEnd') {\n        if (\n          currentPosition &&\n          projected.parentId === currentPosition.parentId &&\n          overId === currentPosition.overId\n        ) {\n          return;\n        } else {\n          setCurrentPosition({\n            parentId: projected.parentId,\n            overId,\n          });\n        }\n      }\n\n      const clonedItems = JSON.parse(JSON.stringify(flattenTree(items)));\n      const overIndex = clonedItems.findIndex(({ id }) => id === overId);\n      const activeIndex = clonedItems.findIndex(({ id }) => id === activeId);\n      const sortedItems = arrayMove(clonedItems, activeIndex, overIndex);\n\n      const previousItem = sortedItems[overIndex - 1];\n\n      let announcement;\n      const movedVerb = eventName === 'onDragEnd' ? 'dropped' : 'moved';\n      const nestedVerb = eventName === 'onDragEnd' ? 'dropped' : 'nested';\n\n      if (!previousItem) {\n        const nextItem = sortedItems[overIndex + 1];\n        announcement = `${activeId} was ${movedVerb} before ${nextItem.id}.`;\n      } else {\n        if (projected.depth > previousItem.depth) {\n          announcement = `${activeId} was ${nestedVerb} under ${previousItem.id}.`;\n        } else {\n          let previousSibling = previousItem;\n          while (previousSibling && projected.depth < previousSibling.depth) {\n            const parentId = previousSibling.parentId;\n            previousSibling = sortedItems.find(({ id }) => id === parentId);\n          }\n\n          if (previousSibling) {\n            announcement = `${activeId} was ${movedVerb} after ${previousSibling.id}.`;\n          }\n        }\n      }\n\n      return announcement;\n    }\n\n    return;\n  }\n}\n\nexport default injectLazyLibs([\n  'dndKitCore',\n  'dndKitSortable',\n  'dndKitUtilities',\n])(Order);\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}