{"ast":null,"code":"import _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Editor, Text, Transforms } from 'slate';\nimport { deserialize } from '@plone/volto-slate/editor/deserialize';\nimport { createBlock, createDefaultBlock, normalizeExternalData } from '@plone/volto-slate/utils/blocks';\nimport { MIMETypeName } from '@plone/volto-slate/utils/mime-types';\nimport { isBlockActive } from '../../utils/blocks';\nexport const insertData = editor => {\n  editor.dataTransferHandlers = _objectSpread(_objectSpread({}, editor.dataTransferHandlers), {}, {\n    'application/x-slate-fragment': (dt, fullMime) => {\n      const decoded = decodeURIComponent(window.atob(dt));\n      const parsed = JSON.parse(decoded);\n      editor.beforeInsertFragment && editor.beforeInsertFragment(parsed);\n      editor.insertFragment(parsed);\n      return true;\n    },\n    'text/html': (dt, fullMime) => {\n      const parsed = new DOMParser().parseFromString(dt, 'text/html');\n      const body = parsed.getElementsByTagName('google-sheets-html-origin').length > 0 ? parsed.querySelector('google-sheets-html-origin > table') : parsed.body;\n      let fragment;\n\n      // eslint-disable-next-line no-console\n      console.debug('clipboard operation', {\n        clipboard: dt,\n        parsedBody: body\n      });\n      const val = deserialize(editor, body);\n      fragment = Array.isArray(val) ? val : [val];\n      fragment = editor.normalizeExternalData(fragment);\n      editor.insertFragment(fragment);\n\n      // eslint-disable-next-line no-console\n      console.debug('result clipboard operation', {\n        clipboard: dt,\n        parsedBody: body,\n        deserializedValue: val,\n        normalizedFragment: fragment,\n        editorChildren: editor.children\n      });\n      return true;\n    },\n    'text/plain': (dt, fullMime) => {\n      const text = dt;\n      if (!text) return;\n      const paras = text.split('\\n');\n\n      // If just 1 line insert text\n      if (paras.length === 1) {\n        Transforms.insertText(editor, paras[0]);\n        return true;\n      }\n\n      // Check if inside a list\n      const fragment = isBlockActive(editor, 'ul') || isBlockActive(editor, 'ol') ? paras.map(p => createBlock('li', [{\n        text: p\n      }])) : paras.map(p => createDefaultBlock([{\n        text: p\n      }]));\n\n      // check if fragment is p with text and insert as fragment if so\n      const fragmentContainsText = f => {\n        var trigger = false;\n        if (f && f[0]) {\n          f.forEach(frag => {\n            if (frag.type === 'p') {\n              if (frag.children) {\n                frag.children.forEach(child => {\n                  if (child.text) {\n                    trigger = true;\n                  }\n                });\n              }\n            }\n          });\n        }\n        return trigger;\n      };\n\n      // When there's already text in the editor, insert a fragment, not nodes\n      const containsText = fragmentContainsText(fragment);\n      if (fragment && containsText) {\n        Transforms.insertFragment(editor, fragment);\n      }\n      if (Editor.string(editor, [])) {\n        if (Array.isArray(fragment) && fragment.findIndex(b => Editor.isInline(editor, b) || Text.isText(b)) > -1) {\n          // console.log('insert fragment', fragment);\n          // TODO: we want normalization also when dealing with fragments\n          Transforms.insertFragment(editor, fragment);\n          return true;\n        }\n      }\n\n      // always normalize when dealing with plain text\n      const nodes = normalizeExternalData(editor, fragment);\n      if (!containsText) {\n        Transforms.insertNodes(editor, nodes);\n      }\n      return true;\n    }\n  });\n\n  // TODO: use the rtf data to get the embedded images.\n  // const text = data.getData('text/rtf');\n\n  const {\n    insertData\n  } = editor;\n\n  // TODO: move this to extensions/insertData\n  // TODO: update and improve comments & docs related to\n  // `dataTransferFormatsOrder` and `dataTransferHandlers` features\n  editor.insertData = data => {\n    if (editor.beforeInsertData) {\n      editor.beforeInsertData(data);\n    }\n    for (let i = 0; i < editor.dataTransferFormatsOrder.length; ++i) {\n      const dt = editor.dataTransferFormatsOrder[i];\n      if (dt === 'files') {\n        const {\n          files\n        } = data;\n        if (files && files.length > 0) {\n          // or handled here\n          return editor.dataTransferHandlers['files'](files);\n        }\n        continue;\n      }\n      const satisfyingFormats = data.types.filter(y => new MIMETypeName(dt).matches(new MIMETypeName(y)));\n      for (let j = 0; j < satisfyingFormats.length; ++j) {\n        const y = satisfyingFormats[j];\n        if (editor.dataTransferHandlers[dt](data.getData(y), y)) {\n          // handled here\n          return true;\n        }\n      }\n    }\n    // not handled until this point\n    return insertData(data);\n  };\n  return editor;\n};","map":{"version":3,"names":["Editor","Text","Transforms","deserialize","createBlock","createDefaultBlock","normalizeExternalData","MIMETypeName","isBlockActive","insertData","editor","dataTransferHandlers","_objectSpread","application/x-slate-fragment","dt","fullMime","decoded","decodeURIComponent","window","atob","parsed","JSON","parse","beforeInsertFragment","insertFragment","text/html","DOMParser","parseFromString","body","getElementsByTagName","length","querySelector","fragment","console","debug","clipboard","parsedBody","val","Array","isArray","deserializedValue","normalizedFragment","editorChildren","children","text/plain","text","paras","split","insertText","map","p","fragmentContainsText","f","trigger","forEach","frag","type","child","containsText","string","findIndex","b","isInline","isText","nodes","insertNodes","data","beforeInsertData","i","dataTransferFormatsOrder","files","satisfyingFormats","types","filter","y","matches","j","getData"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto-slate/src/editor/extensions/insertData.js"],"sourcesContent":["import { Editor, Text, Transforms } from 'slate';\nimport { deserialize } from '@plone/volto-slate/editor/deserialize';\nimport {\n  createBlock,\n  createDefaultBlock,\n  normalizeExternalData,\n} from '@plone/volto-slate/utils/blocks';\nimport { MIMETypeName } from '@plone/volto-slate/utils/mime-types';\nimport { isBlockActive } from '../../utils/blocks';\n\nexport const insertData = (editor) => {\n  editor.dataTransferHandlers = {\n    ...editor.dataTransferHandlers,\n    'application/x-slate-fragment': (dt, fullMime) => {\n      const decoded = decodeURIComponent(window.atob(dt));\n      const parsed = JSON.parse(decoded);\n      editor.beforeInsertFragment && editor.beforeInsertFragment(parsed);\n      editor.insertFragment(parsed);\n\n      return true;\n    },\n    'text/html': (dt, fullMime) => {\n      const parsed = new DOMParser().parseFromString(dt, 'text/html');\n\n      const body =\n        parsed.getElementsByTagName('google-sheets-html-origin').length > 0\n          ? parsed.querySelector('google-sheets-html-origin > table')\n          : parsed.body;\n\n      let fragment;\n\n      // eslint-disable-next-line no-console\n      console.debug('clipboard operation', {\n        clipboard: dt,\n        parsedBody: body,\n      });\n\n      const val = deserialize(editor, body);\n      fragment = Array.isArray(val) ? val : [val];\n      fragment = editor.normalizeExternalData(fragment);\n\n      editor.insertFragment(fragment);\n\n      // eslint-disable-next-line no-console\n      console.debug('result clipboard operation', {\n        clipboard: dt,\n        parsedBody: body,\n        deserializedValue: val,\n        normalizedFragment: fragment,\n        editorChildren: editor.children,\n      });\n\n      return true;\n    },\n    'text/plain': (dt, fullMime) => {\n      const text = dt;\n      if (!text) return;\n\n      const paras = text.split('\\n');\n\n      // If just 1 line insert text\n      if (paras.length === 1) {\n        Transforms.insertText(editor, paras[0]);\n        return true;\n      }\n\n      // Check if inside a list\n      const fragment =\n        isBlockActive(editor, 'ul') || isBlockActive(editor, 'ol')\n          ? paras.map((p) => createBlock('li', [{ text: p }]))\n          : paras.map((p) => createDefaultBlock([{ text: p }]));\n\n      // check if fragment is p with text and insert as fragment if so\n      const fragmentContainsText = (f) => {\n        var trigger = false;\n        if (f && f[0]) {\n          f.forEach((frag) => {\n            if (frag.type === 'p') {\n              if (frag.children) {\n                frag.children.forEach((child) => {\n                  if (child.text) {\n                    trigger = true;\n                  }\n                });\n              }\n            }\n          });\n        }\n        return trigger;\n      };\n\n      // When there's already text in the editor, insert a fragment, not nodes\n      const containsText = fragmentContainsText(fragment);\n      if (fragment && containsText) {\n        Transforms.insertFragment(editor, fragment);\n      }\n\n      if (Editor.string(editor, [])) {\n        if (\n          Array.isArray(fragment) &&\n          fragment.findIndex(\n            (b) => Editor.isInline(editor, b) || Text.isText(b),\n          ) > -1\n        ) {\n          // console.log('insert fragment', fragment);\n          // TODO: we want normalization also when dealing with fragments\n          Transforms.insertFragment(editor, fragment);\n          return true;\n        }\n      }\n\n      // always normalize when dealing with plain text\n      const nodes = normalizeExternalData(editor, fragment);\n      if (!containsText) {\n        Transforms.insertNodes(editor, nodes);\n      }\n\n      return true;\n    },\n  };\n\n  // TODO: use the rtf data to get the embedded images.\n  // const text = data.getData('text/rtf');\n\n  const { insertData } = editor;\n\n  // TODO: move this to extensions/insertData\n  // TODO: update and improve comments & docs related to\n  // `dataTransferFormatsOrder` and `dataTransferHandlers` features\n  editor.insertData = (data) => {\n    if (editor.beforeInsertData) {\n      editor.beforeInsertData(data);\n    }\n\n    for (let i = 0; i < editor.dataTransferFormatsOrder.length; ++i) {\n      const dt = editor.dataTransferFormatsOrder[i];\n      if (dt === 'files') {\n        const { files } = data;\n        if (files && files.length > 0) {\n          // or handled here\n          return editor.dataTransferHandlers['files'](files);\n        }\n        continue;\n      }\n      const satisfyingFormats = data.types.filter((y) =>\n        new MIMETypeName(dt).matches(new MIMETypeName(y)),\n      );\n      for (let j = 0; j < satisfyingFormats.length; ++j) {\n        const y = satisfyingFormats[j];\n        if (editor.dataTransferHandlers[dt](data.getData(y), y)) {\n          // handled here\n          return true;\n        }\n      }\n    }\n    // not handled until this point\n    return insertData(data);\n  };\n\n  return editor;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}