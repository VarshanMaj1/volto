{"ast":null,"code":"import _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { withRouter } from 'react-router';\nimport { connect } from 'react-redux';\nimport config from '@plone/volto/registry';\nimport { matchAllRoutes } from './utils';\nimport { load, loadSuccess, loadFail, beginGlobalLoad, endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\nimport { isPromise, getMutableState, getImmutableState } from './utils';\nimport { AsyncConnectWithContext } from './AsyncConnect';\nexport { loadOnServer, loadAsyncConnect } from './ssr';\n\n// options is: { location, store: { dispatch }, route, match, routes }\nconst wrapWithDispatch = (Component, asyncItems = []) => {\n  return [{\n    key: 'voltoLoadAsyncProps',\n    promise: options => {\n      const {\n        store: {\n          dispatch\n        },\n        location: {\n          pathname\n        }\n      } = options;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const connects = foundAsyncItems.map(item => {\n        const {\n          key\n        } = item;\n        if (!key) return item;\n        const next = item.promise(options);\n        if (isPromise(next)) {\n          dispatch(load(key));\n          // add action dispatchers\n          next.then(data => dispatch(loadSuccess(key, data))).catch(err => dispatch(loadFail(key, err)));\n        } else if (next) {\n          dispatch(loadSuccess(key, next));\n        }\n        return _objectSpread(_objectSpread({}, item), {}, {\n          promise: next\n        });\n      });\n      Component.reduxAsyncConnect = connects;\n      return connects;\n    }\n  }];\n};\nconst applyExtenders = (asyncItems, pathname) => {\n  const {\n    asyncPropsExtenders = []\n  } = config.settings;\n  const extenders = matchAllRoutes(asyncPropsExtenders, pathname);\n  const foundAsyncItems = extenders.reduce((acc, extender) => extender.route.extend(acc), asyncItems);\n  let uniqueAsyncItems = foundAsyncItems.reduce((a, d) => {\n    if (!a.some(el => el.key === d.key)) {\n      a.push(d);\n    }\n    return a;\n  }, []);\n  return uniqueAsyncItems;\n};\n\n/**\n * A replacement for redux-connect's asyncConnect.\n *\n * It was needed because asyncConnect works as a direct wrapper on top of\n * a Component, so the config registry is not yet initialized. To solve this\n * problem we replace the original reduxAsyncConnect implementation (which was\n * a list of asyncConnected \"object promises\") with as single promise exposed\n * as { key: 'voltoLoadAsyncProps', promise: ... }.\n *\n * In more details, the original asyncConnect worked by replacing all our\n * \"object promises\" with a special version that's integrated with its own\n * Redux actions. We do another wrap, which takes the initial passed \"object\n * promises\", finds registered, per route, \"extenders\", calls these extenders\n * with the \"object promises\" and that's our \"object promises\" (which it calls\n * internally \"asyncItems\").\n */\n/**\n * Higher-order function that enhances a React component with asynchronous data fetching and Redux integration.\n *\n * @param {Array} asyncItems - An array of async items to fetch.\n * @param {Function} [mapStateToProps] - A function that maps the Redux state to component props.\n * @param {Function} [mapDispatchToProps] - A function that maps Redux dispatch to component props.\n * @param {Function} [mergeProps] - A function that merges the props from mapStateToProps, mapDispatchToProps, and the component's own props.\n * @param {Object} [options] - Additional options for configuring the async connect behavior.\n * @returns {Function} - A function that takes a React component and returns an enhanced component with async connect functionality.\n */\nexport function asyncConnect(asyncItems, mapStateToProps, mapDispatchToProps, mergeProps, options) {\n  return Component => {\n    Component.reduxAsyncConnect = wrapWithDispatch(Component, asyncItems);\n    const finalMapStateToProps = (state, ownProps) => {\n      const {\n        pathname\n      } = state.router.location;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const mutableState = getMutableState(state);\n      const asyncStateToProps = foundAsyncItems.reduce((result, {\n        key\n      }) => {\n        if (!key) {\n          return result;\n        }\n        return _objectSpread(_objectSpread({}, result), {}, {\n          [key]: mutableState.reduxAsyncConnect[key]\n        });\n      }, {});\n      if (typeof mapStateToProps !== 'function') {\n        return asyncStateToProps;\n      }\n      return _objectSpread(_objectSpread({}, mapStateToProps(getImmutableState(mutableState), ownProps)), asyncStateToProps);\n    };\n    return connect(finalMapStateToProps, mapDispatchToProps, mergeProps, options)(Component);\n  };\n}\nexport const ReduxAsyncConnect = connect(null, {\n  beginGlobalLoad,\n  endGlobalLoad\n})(withRouter(AsyncConnectWithContext));","map":{"version":3,"names":["withRouter","connect","config","matchAllRoutes","load","loadSuccess","loadFail","beginGlobalLoad","endGlobalLoad","isPromise","getMutableState","getImmutableState","AsyncConnectWithContext","loadOnServer","loadAsyncConnect","wrapWithDispatch","Component","asyncItems","key","promise","options","store","dispatch","location","pathname","foundAsyncItems","applyExtenders","connects","map","item","next","then","data","catch","err","_objectSpread","reduxAsyncConnect","asyncPropsExtenders","settings","extenders","reduce","acc","extender","route","extend","uniqueAsyncItems","a","d","some","el","push","asyncConnect","mapStateToProps","mapDispatchToProps","mergeProps","finalMapStateToProps","state","ownProps","router","mutableState","asyncStateToProps","result","ReduxAsyncConnect"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/helpers/AsyncConnect/index.js"],"sourcesContent":["import { withRouter } from 'react-router';\nimport { connect } from 'react-redux';\nimport config from '@plone/volto/registry';\nimport { matchAllRoutes } from './utils';\n\nimport {\n  load,\n  loadSuccess,\n  loadFail,\n  beginGlobalLoad,\n  endGlobalLoad,\n} from '@plone/volto/actions/asyncConnect/asyncConnect';\n\nimport { isPromise, getMutableState, getImmutableState } from './utils';\nimport { AsyncConnectWithContext } from './AsyncConnect';\nexport { loadOnServer, loadAsyncConnect } from './ssr';\n\n// options is: { location, store: { dispatch }, route, match, routes }\nconst wrapWithDispatch = (Component, asyncItems = []) => {\n  return [\n    {\n      key: 'voltoLoadAsyncProps',\n      promise: (options) => {\n        const {\n          store: { dispatch },\n          location: { pathname },\n        } = options;\n\n        const foundAsyncItems = applyExtenders(asyncItems, pathname);\n\n        const connects = foundAsyncItems.map((item) => {\n          const { key } = item;\n          if (!key) return item;\n          const next = item.promise(options);\n\n          if (isPromise(next)) {\n            dispatch(load(key));\n            // add action dispatchers\n            next\n              .then((data) => dispatch(loadSuccess(key, data)))\n              .catch((err) => dispatch(loadFail(key, err)));\n          } else if (next) {\n            dispatch(loadSuccess(key, next));\n          }\n          return {\n            ...item,\n            promise: next,\n          };\n        });\n\n        Component.reduxAsyncConnect = connects;\n        return connects;\n      },\n    },\n  ];\n};\n\nconst applyExtenders = (asyncItems, pathname) => {\n  const { asyncPropsExtenders = [] } = config.settings;\n  const extenders = matchAllRoutes(asyncPropsExtenders, pathname);\n\n  const foundAsyncItems = extenders.reduce(\n    (acc, extender) => extender.route.extend(acc),\n    asyncItems,\n  );\n\n  let uniqueAsyncItems = foundAsyncItems.reduce((a, d) => {\n    if (!a.some((el) => el.key === d.key)) {\n      a.push(d);\n    }\n    return a;\n  }, []);\n\n  return uniqueAsyncItems;\n};\n\n/**\n * A replacement for redux-connect's asyncConnect.\n *\n * It was needed because asyncConnect works as a direct wrapper on top of\n * a Component, so the config registry is not yet initialized. To solve this\n * problem we replace the original reduxAsyncConnect implementation (which was\n * a list of asyncConnected \"object promises\") with as single promise exposed\n * as { key: 'voltoLoadAsyncProps', promise: ... }.\n *\n * In more details, the original asyncConnect worked by replacing all our\n * \"object promises\" with a special version that's integrated with its own\n * Redux actions. We do another wrap, which takes the initial passed \"object\n * promises\", finds registered, per route, \"extenders\", calls these extenders\n * with the \"object promises\" and that's our \"object promises\" (which it calls\n * internally \"asyncItems\").\n */\n/**\n * Higher-order function that enhances a React component with asynchronous data fetching and Redux integration.\n *\n * @param {Array} asyncItems - An array of async items to fetch.\n * @param {Function} [mapStateToProps] - A function that maps the Redux state to component props.\n * @param {Function} [mapDispatchToProps] - A function that maps Redux dispatch to component props.\n * @param {Function} [mergeProps] - A function that merges the props from mapStateToProps, mapDispatchToProps, and the component's own props.\n * @param {Object} [options] - Additional options for configuring the async connect behavior.\n * @returns {Function} - A function that takes a React component and returns an enhanced component with async connect functionality.\n */\nexport function asyncConnect(\n  asyncItems,\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  options,\n) {\n  return (Component) => {\n    Component.reduxAsyncConnect = wrapWithDispatch(Component, asyncItems);\n\n    const finalMapStateToProps = (state, ownProps) => {\n      const { pathname } = state.router.location;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const mutableState = getMutableState(state);\n      const asyncStateToProps = foundAsyncItems.reduce((result, { key }) => {\n        if (!key) {\n          return result;\n        }\n\n        return {\n          ...result,\n          [key]: mutableState.reduxAsyncConnect[key],\n        };\n      }, {});\n\n      if (typeof mapStateToProps !== 'function') {\n        return asyncStateToProps;\n      }\n\n      return {\n        ...mapStateToProps(getImmutableState(mutableState), ownProps),\n        ...asyncStateToProps,\n      };\n    };\n\n    return connect(\n      finalMapStateToProps,\n      mapDispatchToProps,\n      mergeProps,\n      options,\n    )(Component);\n  };\n}\n\nexport const ReduxAsyncConnect = connect(null, {\n  beginGlobalLoad,\n  endGlobalLoad,\n})(withRouter(AsyncConnectWithContext));\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}