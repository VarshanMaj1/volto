{"ast":null,"code":"import _objectSpread from \"/Users/varshanmaji/Projects/volto/node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isCmsUi } from '@plone/volto/helpers/Url/Url';\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = ({\n  dispatch,\n  getState\n}) => next => action => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  switch (action.type) {\n    case LOCATION_CHANGE:\n      const {\n        location\n      } = action.payload;\n      const {\n        pathname: path\n      } = location;\n      const currentPath = getState().router.location.pathname;\n      const result = next(action);\n      if (isCmsUi(path)) {\n        // Next path: isCmsUI, Non Content. There is no\n        // loading here, so skip counting altogether.\n        // Will update the delayed location constantly.\n        dispatch({\n          type: PROTECT_SKIPPED,\n          location\n        });\n      } else {\n        dispatch({\n          type: PROTECT_START,\n          location,\n          // Only reset before the fetch, if we depart from\n          // a not isCmsUi, Content pass. However, reset will\n          // not occur if moving between two content paths,\n          // only the postponed location will be booked.\n          resetBeforeFetch: isCmsUi(currentPath)\n        });\n      }\n      return result;\n    default:\n      return next(action);\n  }\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = action => action.type.endsWith('_PENDING');\nconst isResponseAction = action => action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT\n};\nexport const protectLoadEnd = ({\n  dispatch,\n  getState\n}) => next => action => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  const {\n    isCounting,\n    resetBeforeFetch,\n    requestCount\n  } = getState().loadProtector;\n  if (resetBeforeFetch) {\n    const type = mapActions[action.type];\n    if (type) {\n      dispatch({\n        type\n      });\n    }\n  }\n  if (isCounting && requestCount === 1 && isResponseAction(action)) {\n    setTimeout(() => dispatch({\n      type: PROTECT_END\n    }), 0);\n  }\n  return next(action);\n};\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location\n      });\n    case PROTECT_END:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false\n      });\n    case PROTECT_SKIPPED:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location\n      });\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation\n        });\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          resetBeforeFetch: false\n        });\n      } else {\n        return state;\n      }\n    default:\n      const {\n        isCounting,\n        requestCount\n      } = state;\n      if (isCounting && isRequestAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount + 1\n        });\n      } else if (isCounting && isResponseAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount - 1\n        });\n      } else {\n        return state;\n      }\n  }\n}","map":{"version":3,"names":["isCmsUi","LOCATION_CHANGE","PROTECT_START","PROTECT_END","PROTECT_SKIPPED","GET_CONTENT_PENDING","GET_CONTENT_SUCCESS","GET_CONTENT_FAIL","RESET_CONTENT","protectLoadStart","dispatch","getState","next","action","type","location","payload","pathname","path","currentPath","router","result","resetBeforeFetch","isRequestAction","endsWith","isResponseAction","mapActions","protectLoadEnd","isCounting","requestCount","loadProtector","setTimeout","state","_objectSpread","postponedLocation"],"sources":["/Users/varshanmaji/Projects/volto/packages/volto/src/middleware/storeProtectLoadUtils.js"],"sourcesContent":["import { isCmsUi } from '@plone/volto/helpers/Url/Url';\n\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart =\n  ({ dispatch, getState }) =>\n  (next) =>\n  (action) => {\n    if (typeof action === 'function') {\n      return next(action);\n    }\n    switch (action.type) {\n      case LOCATION_CHANGE:\n        const { location } = action.payload;\n        const { pathname: path } = location;\n        const currentPath = getState().router.location.pathname;\n        const result = next(action);\n        if (isCmsUi(path)) {\n          // Next path: isCmsUI, Non Content. There is no\n          // loading here, so skip counting altogether.\n          // Will update the delayed location constantly.\n          dispatch({\n            type: PROTECT_SKIPPED,\n            location,\n          });\n        } else {\n          dispatch({\n            type: PROTECT_START,\n            location,\n            // Only reset before the fetch, if we depart from\n            // a not isCmsUi, Content pass. However, reset will\n            // not occur if moving between two content paths,\n            // only the postponed location will be booked.\n            resetBeforeFetch: isCmsUi(currentPath),\n          });\n        }\n        return result;\n      default:\n        return next(action);\n    }\n  };\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = (action) => action.type.endsWith('_PENDING');\nconst isResponseAction = (action) =>\n  action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT,\n};\n\nexport const protectLoadEnd =\n  ({ dispatch, getState }) =>\n  (next) =>\n  (action) => {\n    if (typeof action === 'function') {\n      return next(action);\n    }\n    const { isCounting, resetBeforeFetch, requestCount } =\n      getState().loadProtector;\n    if (resetBeforeFetch) {\n      const type = mapActions[action.type];\n      if (type) {\n        dispatch({ type });\n      }\n    }\n    if (isCounting && requestCount === 1 && isResponseAction(action)) {\n      setTimeout(\n        () =>\n          dispatch({\n            type: PROTECT_END,\n          }),\n        0,\n      );\n    }\n    return next(action);\n  };\n\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location,\n      };\n    case PROTECT_END:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n      };\n    case PROTECT_SKIPPED:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location,\n      };\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return {\n          ...state,\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation,\n        };\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return {\n          ...state,\n          resetBeforeFetch: false,\n        };\n      } else {\n        return state;\n      }\n    default:\n      const { isCounting, requestCount } = state;\n      if (isCounting && isRequestAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount + 1,\n        };\n      } else if (isCounting && isResponseAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount - 1,\n        };\n      } else {\n        return state;\n      }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}